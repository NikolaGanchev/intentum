{
    "l0": {
        "title": "Урок 0",
        "text": "където ще се запознаем",
        "p1p": "Здравей!",
        "p2p": "Аз съм автора на Интентум. И моята цел е до края на този „курс“ да имаш всички нужни знания в информатиката и програмирането, за да можеш да продължиш да учиш и без мен. И да правиш без мен. „Курсът“ е разделен на 42 урока (без урок 0) и 8 теста. Това би трябвало да обхваща всичко нужно за един старт в програмирането и да покрива целия материал по информатика от 8-ми до 12-ти клас, без да отнема 5 години. Всеки урок има тематично заглавие, което показва какво ще правиш в него.",
        "p3p": "Уроците не са сложни и са максимално опростени – вярвам че всеки може да се научи да програмира, ако обяснението е лесно. Това и причината да създам този източник – аз самия започнах от една книга за програмирането на английски, от която почти нищо не разбрах за програмирането. А на български източници почти няма. Един ден, някой ме попита „Ти как се научи?“, аз започнах да се оплаквам, че няма какво да му препоръчам, и изведнъж ми хрумна сам да се занимая с тази задача. И ето ме тук",
        "p4p": "Уроците до които не си стигнал са заключени. За да отключиш урок, трябва да минеш предния, или да натиснеш ключалката, която се намира на мястото на старт бутона. Аз обаче не препоръчвам да се пропускат уроци. Идеята на отключването е да можеш да си на едно ниво и на компютър, и на телефон, без да се налагат профили (и съответно, връзка с интернет) – не да пропускаш важен материал.",
        "p5p": "Уроците си имат и секции, като на края на всяка секция има въпрос и ключалка, криеща по-долния материал. Този въпрос е за самопроверка – независимо как отговориш, долния материал ще се разкрие. Твоя е задачата да прецениш дали не ти трябва още един прочит!",
        "p6p": "Казах че има и 8 теста. Не се плаши! Независимо какво направиш на тест, продължаваш на следващия урок. Тестовете са за самопроверка – до установиш собственото си ниво и да прецениш дали трябва да продължиш със следващия урок или да се върнеш назад.",
        "p7p": "Както забелязваш, особено важна ще е самопроверката. Колкото ти разчиташ на мен да има лесни и добре написани уроци, толкова и аз разчитам на теб сам да осъзнаваш кога трябва да наблегнеш на нещо. Желание се изисква и от двете страни.",
        "p8p": "В момента може да си представяш програмирането като някаква древна магия, използваема единствено от наследниците на Айнщайн и тези които решават кубични уравнения на салфетки, пишейки с кал, докато изкачват Мусала. Това не е така, и дори не се изисква да си особено добър математик. Предполагам обаче, че мога да ти докажа това само по един начин.",
        "p9p": "Засега това е от мен. Ще се срещнем отново в следващия урок – първия истински. Пожелавам ти късмет!"
    },
    "l1": {
        "title": "Урок 1",
        "text": "където ще научиш, че цифрите не са само 10",
        "p1p": "Вече сме в първия урок! Добре дошъл/дошла!",
        "p2p": "Предполагам, че заглавието на урока те е изненадало, и в момента се чудиш „Как така да не са 10 цифрите? Учителят от началното училище не спря да ми го повтаря“. Е, за да ти отговоря, първо трябва да те върна във въпросното начално училище.",
        "p3p": "Тогава си учил/а числата. И когато си ги учил, са те карали да пишеш нещо подобно:",
        "p4p": "56 = 5*10 + 6",
        "p5p": "Има логика. Да пробваме с трицифрено число:",
        "p6p": "156 = 1*100 + 5*10 + 6",
        "p7p": "Нека да запишем това в пълния му вариант – в крайна сметка, 6 всъщност се умножава по 1:",
        "p8p": "156 = 1*100 + 5*10 + 6*1",
        "p9p": "Първо да видим какво е общото между числата 100 и 10. От тук чувам как мислиш „И двете се делят на 10“. И си прав. Не само това, но и двете са степени на 10 –> 10 е 101 , а 100 е 102 . Да го запишем („^“ е знак за степен):",
        "p10p": "156 = 1 * 10^2 + 5 * 10^1 + 6*1",
        "p11p": "Аз обаче мога да ти кажа, че всъщност между всички три множителя има връзка – 100, 10 и 1. И трите всъщност са степени на 10. И в момента, може да се сетиш за нещо, което ти е било казано преди дълго време – което и да е число, повдигнато на степен 0, е 1. Тоест, 100 е 1. Сега получаваме:",
        "p12p": "156 = 1 * 10^2 + 5 * 10^1+ 6*10^0",
        "p13p": "Добре, значи да пробваме със шестцифрено число:",
        "p14p": "907 156 = 9 * 10^5+ 0 * 10^4 + 7 * 10^3 + 1 * 10^2 + 5 * 10^1 + 6*10^1",
        "p15p": "Можем да продължим още, но с всяко число ще получим нещо подобно. Изводът е, че всяко число в десетичната бройна система е равно на сбора от всичките му цифри, където всяка цифра се умножава по десет на степен позицията и. Тоест, каквото написахме горе, но в думи. Позицията на цифра се определя отдясно наляво – най-дясната цифра е 0,  всяка следваща е с 1 по-голяма. Например:",
        "p16p": "1 907 156 - Цифра",
        "p17p": "6 543 210 - Позиция",
        "p18p": "Поради факта че цифрите тук са 10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) и умножаваме по степен на 10, казваме че имаме десетична бройна система. А базата е 10.",
        "p19tq": "Каква би била базата на система с 2 цифри?",
        "p20fq": "Запиши на какво е равно числото 796 спрямо образеца 156 = 1 * 10^2 + 5 * 10^1 + 6*10^0, където „^“ значи степен.",
        "p21p": "След като изяснихме това, да напуснем началното училище и да се върнем в настоящето. И тук идва истинската цел на урока: да разбереш двоичната бройна система.",
        "p22p": "На всички им е известно, че компютрите разбират само 0 и 1. Съответно, те използват бройна система, където има само две цифри – 0 и 1. Една нула или единица е бит. И базата на тази система е 2.",
        "p23p": "Само с тази информация можем да дешифрираме нулите и единици. Например, имаме числото 010. Позициите са както следва:",
        "p24p": "210",
        "p25p": "Знаем, че ни трябва сбор от цифрите умножени по базата на степен позицията. Базата е 2, а позициите ги имаме:",
        "p26p": "010 = 0 * 2^2 + 1 * 2^1 + 0 * 2^0 = 0 * 4 + 1 * 2 + 0 * 1 = 2",
        "p27p": "Това е. Току що превърнахме числото 010 (база 2) в число в база 10 – 2. Да пробваме с нещо по-сложно – 1 байт – тоест 8 бита или с други думи, 8 цифри:",
        "p28p": "10110110 = 1 * 2^7 + 0 * 2^6 + 1 * 2^5 + 1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0 =  1 * 128 + 0 * 64 + 1 * 32 + 1 * 16 + 0 * 8 + 1 * 4 + 1 * 2 + 0 * 1 = 128 + 32 + 16 + 4 + 2 = 182",
        "p29p": "И ето че превърнахме в десетична бройна система и това дълго число.",
        "p30fq": "Превърни 11101110 в десетична бройна система",
        "p31tq": "110 в двоична бройна система е равно на колко в десетична?",
        "p32p": "Да направим обратното и да вземем отново числото 156. Този път, няма да умножаваме по 10, а ще делим на 10. С остатък. Получаваме: ",
        "p33p": "156 / 10 = 15  (15 * 10 = 150 -> остатък 6)",
        "p34p": "15 / 10 = 1 (1*10 = 10 -> остатък 5)",
        "p35p": "1 / 10 = 0 (0*10 = 0 -> остатък 1)",
        "p36p": "Забелязваме нещо. Ако вземем остатъците отдясно наляво, получаваме началното число: 156. За да направим това делим на базата 10, и получаваме число в десетична бройна система. Тогава да пробваме да делим на база 2, и може би ще получим число в двоична бройна система:",
        "p37p": "156 / 2 = 78 (остатък 0)",
        "p38p": "78  / 2 = 39 (остатък 0)",
        "p39p": "39 / 2 = 19 (ост. 1)",
        "p40p": "19 / 2 = 9 (ост. 1)",
        "p41p": "9 / 2 = 4 (ост. 1)",
        "p42p": "4 / 2 = 2 (ост. 0)",
        "p43p": "2 / 2 = 1 (ост. 0)",
        "p44p": "1 / 2 = 0 (ост. 1)",
        "p45p": "Значи, следвайки горната логика, получаваме числото 10011100, което изглежда в двоична бройна система (не забравяй, че четем отдясно наляво). Да направим проверка:",
        "p46p": "10011100 = 1 * 2^7 + 0 * 2^6 + 0 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0 = 1 * 128 + 0 * 64 + 0 * 32 + 1 * 16 + 1 * 8 + 1 * 4 + 0 * 1 = 128 + 16 + 8 + 4 = 156",
        "p47p": "Значи сме работили правилно!",
        "p48p": "И това е цялата двоичната бройна система. Нито е прекалено сложна, нито нещо неразбираемо. Надявам се да си хванал. Въпреки това, се тествай:",
        "p49fq": "На колко е равно 238 в двоична бройна система?",
        "p50p": "Свърших с материала за урока, но още не съм обяснил откъде идва заглавието. Всъщност е просто. По същия начин, по който можем да имаме бройни системи с бази по-малки от 10, можем да имаме и такива с по-големи от 10. Една широко използвана с по-голяма база е шестнадесетичната бройна система – с 16 цифри, тоест база 16. „Как така?“ питаш ти, и отговора е, че цифрите са тези  - 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A (10), B (11), C (12), D (13), E (14), F (15). Използват се букви за по-големите от 9. Главно се ползва за цветове. Например, числото EFEFEF е цвета на фона в по-голямата част на приложението. В десетична система това е 15 724 527, и виждаш че EFEFEF е сравнително по-лесно за изписване – има практическа полза.",
        "p51rq": "Избери си цвят и потърси числото му в база 16 в Интернет, като имаш предвид, че тези записи на цветове много често се наричат и hex, или хексове."
    },
    "l2": {
        "title": "Урок 2",
        "text": "където ще научиш как се събират и изваждат числа… отново",
        "p1p": "В този урок ще се научиш да събираш и изваждаш с други бройни системи. Подобно на цялата тема за други бройни системи, и това не е сложно.",
        "p2h": "Събиране",
        "p3p": "Нека първо да съберем две числа в десетичната бройна система. Нека да са 96 и 56.",
        "p4pre": "\n 96 \n + \n 56 \n152",
        "p5p": "Правил/а си това много пъти – слагаш двете числа едно под друго. Събираш първата колона отдясно наляво. Ако сборът е по-малък от 10, го записваш долу. Ако е по-голям или равен на 10, например 12, слагаш едно на ум на следващата колонка и записваш последната цифра – 2  (или записано по друг начин, разликата на 12 и 10). Това се повтаря с всички колонки.",
        "p6p": "Събирането на числа в двоичната бройна система всъщност е същото. Само че вместо да следим за 10, следим за 2 – базата на системата. Тоест, ако сборът на колонка е по-малък от 2, го записваме, иначе слагаме едно на ум на следващата колонка и записваме разликата на сбора и 2. Нека да пробваме:",
        "p7pre": "\n 101 \n + \n 011 \n1000",
        "p8p": "Първо събираме 1 и 1. Получава се 2, което е равно на две. Следователно пишем 1 на ум над следващата колонка и записваме 2-2 = 0. На следващата колонка събираме 0 и 1 и получаваме 1, но имаме 1 на ум, следователно сборът е 2. Слагаме 1 на ум, записваме 0 и продължаваме. На следващата колонка събираме 1 и 0, получаваме 1. Имаме 1 на ум, събираме и него, и получаваме 2. Пишем 1 на ум на следващата колонка. Записваме 0. Последната колонка е празна, затова пишем просто 1 (от предното 1 на ум). Получаваме 1000. Нека да направим проверка. 101 е 5. 011 е 3. 1000 е 8. Значи сме работили правилно.",
        "p10fq": "Колко е 10101101 + 01100110?",
        "p11h": "Изваждане",
        "p12pre": "\n101\n-\n011\n010",
        "p13p": "Тук, първо изваждаме 1 от 1. Получаваме 0, и я записваме долу. След това се опитваме да извадим 1 от 0.  Но не можем, защото 0 е по-малко от 1. Значи, взимаме 1 на ум от следващата колонка. Получаваме 2-1, което вече е 1. Записваме 1 долу. След това, трябва да извадим 1-0. Обаче сме взели 1 на ум, тоест ни остава 0-0. Записваме 0 долу. И имаме резултат. Да направим проверка: 101 е 5. 011 е 3. 010 е 2. Значи сме работили правилно.",
        "p14fq": "Запиши резултата на 10011 – 101",
        "p15h": "Умножение",
        "p16p": "Умножението на двоични числа е абсолютно същото като на десетични. Разлика няма. Важно е да не забравяш че събираш двоични числа, не десетични.",
        "p17pre": "\n  1101*11 \n  1101\n 1101\n100111",
        "p18fq": "Запиши резултата на 101 * 011",
        "p19h": "Деление",
        "p20p": "Делението на числа в други бройни системи е сравнително по-трудоемко. Най-лесния начин е да превърнеш числата в десетична бройна система, да ги разделиш, и резултата да превърнеш в двоично число. Например:",
        "p21pre": "\n110 / 011\n110 = 1 * 4 + 1*2 + 0*1 = 6\n011 = 0*4 + 1*2 + 0*1 = 3",
        "p22p": "Вече виждаме, че 6/3 = 2. Превръщаме 2 в двоична бройна система и получаваме 010. Следователно:",
        "p23pre": "110 / 011 = 010"
    },
    "l3": {
        "title": "Урок 3",
        "text": "където ще научиш как текст става нули и единици",
        "p1p": "Вече разбра, че компютъра действа само с нули и единици – от процесора, до паметта. Разбра и как представя нашите десетични числа само с две цифри, и как извършва аритметични действия с тях. Сега идва въпросът „Но как представя текст?“.",
        "p2p": "Първо, ще се върнем малко във времето. Далечната 1960, когато една група хора трябва да измислят начин, да превърнат символите в числа. Съответно, те мислят, и през 1963 година излиза ASCII (Американски стандартен код за обмен на информация, чете се „аски“). Той е сравнително просто решение – всеки нужен символ е свързан с число. Компютъра единствено запазва числото, а по-късно може да го разчете и да представи символа, на който съответства.",
        "p3p": "Общо има 128 символа, и всеки от тях се записва със 7 бита.",
        "p4p": "33 от тях не могат да се разпечатат – не се виждат по никакъв начин. Те обозначават команди, като край на заглавие, абзац, изтриване и т.н.",
        "p5p": "Потърси в Интернет ASCII таблицата – символите, които могат или не могат да се разпечатат, със съответстващите им букви. Преди малките букви са големите, а преди големите – цифрите и препинателните знаци.",
        "p6p": "Така всеки компютър знае, че например символ 32 е празно място, а символ 61 е малко латинско „a“.",
        "p7fq": "Колко са символите в ASCII?",
        "p8p": "Тук може би забелязваш лек проблем – има само латинските символи, препинателните знаци и цифрите. А какво става ако имаш съобщение на кирилица? Или на японски? Ами китайски? И къде се побират емотиконите в това цялото нещо. И отговора е, ами, никъде. Но този проблем не се появява за дълго време. В държавите, които използват непозволени символи се ползват различни кодирания на символите. Но се появява проблем – на компютър с ASCII, 61 е малко „a“. Но какво става ако не него се пусне файл, запазен с кодиране, в което 61 е “и”? Отговорът е \"пълен хаос\". Да не говорим и че се създават и много алтернативни кодирания, като например Windows-1251, където 0438 (в база 16, тоест 1080 в десетична бройна система) е „и“. Какво се случва, когато компютър, който опитва да чете ASCII, където символ 1080 няма, стигне до това? Символа обикновено се показва като въпросителни.",
        "p9p": "Тези проблеми се срещат и днес. Не си представяй, че са изчезнали. Но са много по-малко, благодарение на една причина – Unicode (от универсален код, чете се „юникоуд“, пише се уникод).",
        "p10p": "Уникод е създаден от няколко човека през 1991г. Той действа с няколко оптимизации – най-често използваните символи са първите, и те се запаметяват използвайки само 8 бита, а другите – с по 32. Това позволява невероятно количество символи – в последния стандарт през 2021 има 137 439 символа, обхващащи 146 писмености, мъртви и живи, множество символи и емоджита. Днес е в няколко различни версии, като UTF-8, UTF-16, UTF-32. В днешно време се използва почти навсякъде, заради това огромно разнообразие.",
        "p11tq": "Защо Unicode е толкова популярен?",
        "p11a1": "Плаща ти се, за да го използваш",
        "p11a2": "Корупционна схема",
        "p11a3": "Има най-много и разнообразни символи",
        "p11a4": "Заема най-много място",
        "p12p": "Това е какво ще ти е нужно относно това как компютрите се справят със символи.",
        "p13t": "Всяка буква и място, което напишеш, е символ, който се запазва като число."
    },
    "l4": {
        "title": "Урок 4",
        "text": "където ще научиш, че разширенията са лъжа",
        "p1p": "Информацията в компютър се разделя на файлове – парчета информация. Всеки файл си има име и големина – обикновено измервана в байтове (1 байт = 8 бита). Файловете се групират в папки, като във всяка папка може да има файлове и други папки. Така се оформя модел на организация, подобен на дърво – всяка папка е нов клон, в който има файлове и от който започват още клони – папки.",
        "p2tq": "Във всяка папка може да има:",
        "p2a1": "Само папки",
        "p2a2": "Само файлове",
        "p2a3": "Хард дискове",
        "p2a4": "Папки и файлове",
        "p3p": "В повечето операционни системи (Windows, Linux, MacOS), главната папка се нарича “C” (“це”), често наричана и корен („root“), защото се явява корен на файловото дърво. Пътят („path“) на файл или папка е последователността папки, през които потребител трябва да премине, за да стигне до файла или папката. Пътищата са 2 вида: абсолютни и относителни. Абсолютният път винаги започва от главната папка и завършва на файл или папка. Той е абсолютен. Относителният път може да започва от която и да е папка. Тоест, той се отнася към други папки и файлове.",
        "p4tq": "Откъде започва абсолютен път?",
        "p4a1": "От коренът на файловото дърво",
        "p4a2": "От която и да е папка",
        "p4a3": "От който и да е файл",
        "p4a4": "От файла, до който е",
        "p5p": "Когато пътищата се записват, между всяка папка или файл се записва разделител. В Linux и MacOS, това обикновено е „/“. В Windows, разделителят е „\\“. Това обаче не е практично в програмирането, заради множеството запазени символи с „\\“. Например, в повечето файлове „\\n“ означава нов ред и не се показва на потребителя, а \\t означава таб.",
        "p6tq": "Какво означава символът „\\n“?",
        "p6a1": "Нов ред",
        "p6a2": "Празно пространство",
        "p6a3": "Таб",
        "p6a4": "Главна буква",
        "p7p": "Нека да разгледаме пример. Ние сме в Windows. Влезли сме в потребител на име „Gosho“. Този потребител има файл на име „nominacii.docx“ в папката си „Документи“ („Documents“). Тази папка се намира в папката му потребители („Users“), която е в кореновата му папка („C“).",
        "p8p": "Така би изглеждал абсолютния път до този файл:",
        "p9pre": "C:\\Users\\Gosho\\Documents\\nominacii.docx",
        "p10p": "Първо да отбележим, че кореновата папка се записва с „:“ преди разделителя. Тоест имаме „C:\\“.",
        "p11p": "Забележи, че това е Windows. Тоест, разделител е „\\“. С разделител „/“ бихме имали съшия ефект: ",
        "p12pre": "C:/Users/Gosho/Documents/nominacii.docx",
        "p13p": "Този случай обаче е по-практически за целите на програмирането. Горе, „\\n“ в „\\nominacii.docx“, би било интерпретирано като нов ред от повечето езици, което ще доведе до грешки. За остатъка на този „курс“, ще използвам главно „/“ поради тази причина.",
        "p14p": "Освен това, можем да поставим и разделител след края на пътя, но не е препоръчително:",
        "p15pre": "C:/Users/Gosho/Documents/nominacii.docx/",
        "p16tq": "Защо не е препоръчително да използваме „\\” за разделител в програмирането?",
        "p16a1": "Грозно е",
        "p16a2": "Не работи в Windows",
        "p16a3": "Защото може да се интерпретира като различни контролни символи",
        "p17p": "Да си представим обаче, че нашия потребител иска да започне от папка на име „Проекти“ („Proekti“), която се намира в „Документи“ и да стигне до „nominacii.docx“. За това ще използваме относителен път.",
        "p18p": "Първо да видим абсолютният път на папката „Proekti“:",
        "p19pre": "C:/Users/Gosho/Documents/Proekti",
        "p20p": "След това, абсолютния път на файла nominacii.docx:",
        "p21pre": "C:/Users/Gosho/Documents/nominacii.docx",
        "p22p": "Забелязваме, че и двете са в папка „Documents“. Само че едното е папка, а другото - файл.",
        "p23p": "В относителните пътища имаме активна (или работна) папка. От нея започва пътят. Има няколко специални символи за навигация. „./“ означава работната папка. Тоест, ако работна папка е  „Proekti“, и в нея има файл „proekt1.txt“, можем да достигнем този файл чрез пътя:",
        "p24pre": "./proekt1.txt",
        "p25p": "Тоест, „./“ просто значи „папката, в която съм“.",
        "p26p": "Но ако искаме да достигнем елемент в предна папка от работната, използваме „../“. Това значи „предната папка от работната“. Спрямо „Proekti“, това е папката „Documents“. Така, ако искаме да достигнем „nominacii.docx“ от Proekti използваме пътя:",
        "p27pre": "../nominacii.docx",
        "p28p": "Така можем да се връщаме и повече папки назад. Например, ако в „Gosho“ има файл с име „hello.txt”, можем от работна папка „Proekti“ да го достигнем така: ",
        "p29pre": "../../hello.txt",
        "p30p": "Както си забелязал/а, не съм писал име на папка или потребител с кирилица. Това е така, защото някои системи поддържат единствено ASCII и кирилицата създава проблеми с тях.",
        "p31tq": "В относителен път „./“ е:",
        "p31a1": "работната папка",
        "p31a2": "предната папка",
        "p31a3": "следващата папка",
        "p31a4": "файл",
        "p32p": "Както си забелязал, заглавието на този урок казва, че разширенията са лъжа. Но не сме говорили за това. Като става на въпрос, от началото на урока не съм написал думата „разширение“ и веднъж. Разширенията на файл са последната част от него, отделена с „.“ от остатъка. Всички разширения до сега са написани като част от имената на файловете:",
        "p33p": "nominacii.docx – „.docx“ е разширението",
        "p34p": "proekt1.txt, „hello.txt“ – „.txt“ е разширението",
        "p35p": "Но реалността е, че разширенията са лъжа. Предложение, ако трябва да сме точни.",
        "p36p": "Първо, всеки файл е просто текст или двоичен формат (нули и единици, без текстово значение). Нищо друго. А разширенията са част от името.",
        "p37p": "Разширенията са само предложение. Когато операционната система види „.docx” файл, знае да го отвори с Word. Когато види „.mp3” файл, знае че е музика. Но това не ни пречи да го отворим с друго приложение. Можем да натиснем файла с десен бутон на мишката, да натиснем „Отвори с“. Да натиснем „Още приложения“. Да намерим Notepad, и да отворим файла с него. И виждаме само текст. Може файла да е двоичен – тоест вече е на нули и единици. Когато го отворим, виждаме странни символи – няма кодиране, което да може да бъде прочетено. ",
        "p38p": "Файлът може дори и да няма разширение. Популярната платформа Heroku използва някои файлове без разширения – например „Procfile“ – чете ги и ги отваря като текстови.",
        "p39p": "Един от най-честите проблеми на програмистите е да запазват информация, заедно с това за какво е предназначена тя. Например, искаш да запазиш езика на приложение и после да го прочетеш от файл. Можеш просто да направиш файл „ezik.txt“ и да го запишеш там. Но е непрактично. После можеш да имаш настройка като режим – тъмен или светъл. И за нея ли ще създадеш файл? За това съществуват ключ-стойност форматите. Да ги разгледаме:",
        "p40h": "XML",
        "p41p": "XML е един от най-старите формати. Той е на основата на тагове. Един таг може да е отваряш и затварящ. Отварящ таг изглежда така:",
        "p42pre": "<име на тага>",
        "p43p": "Затварящ таг изглежда така:",
        "p44pre": "</ име на тага>",
        "p45p": "Съответно, това позволява запазване на информация. Например (ще използвам английското съкращение „lang“ за език и английската дума „mode“ за режим – прието е да не се пишат тагове на друго освен латиница):",
        "p46pre": "<lang> Български </lang >\n<mode> Светъл </mode>",
        "p47p": "Друго уникално свойство на xml е, че между таговете може да има и други тагове („settings“ - настройки):",
        "p48pre": "<settings>\n\t<lang> Български </lang >\n\t<mode> Светъл </mode>\n</settings>",
        "p49p": "Забележи как с всяко следващо ниво на тагове слагаме повече място вляво.",
        "p50p": "Използвайки този формат, програмистът може после да поиска стойността на lang в settings и да получи „Български“.",
        "p51p": "XML се използва широко – „.docx“ са архиви, но когато се разархивират са главно .xml файлове. Също и целия интернет зависи от xml – неговия подезик html е основната структура на всеки сайт. Mоже да носи и информация в таговете – така се добавя картина в уебсайт:",
        "p52pre": "<img src=„път към картина“></img>",
        "p53p": "Тук „src” дава пътят към картината (относителен). След това браузърът иска стойността на „src“ в „img“ и получава пътят, с който да зареди картината",
        "p54fq": "Напиши отварящ и затварящ таг „version“, между които е записано 17.2",
        "p55h": "JSON",
        "p56p": "XML обаче не е удобен за пренос на голямо количество информация. Всяко име на таг се пише по два пъти (за отварящ и затварящ), което е много байтове информация. Затова се използва JSON (нотация на обекти на Javascript). Първо, този формат се чете много лесно от Javascript, динамичния език на всеки уебсайт, както подсказва и името. Да си представим, че ти си правиш профил в някоя мрежа. Слагаш си име име, e-mail, възраст и парола. След това натискаш „регистрация“. Към сървъра тръгва съобщение, което изглежда така: ",
        "p57pre": "{\n\t\"ime\": \"Gosho\",\n\t\"email\": \"gosho@email.email\",\n\t\"parola\": \"dobraparola\",\n\t\"vuzrast\": 18\n}",
        "p58p": "Toва е JSON. Започва с „{“ и завършва с „}“. Отляво винаги има ключ – например „ime“. След това има „:“, което значи край на ключа. Всеки ключ е обграден в кавички. След „:“ е стойността. Тя може да е няколко вида. Първият е текст, заобграден с кавички. Може да е просто число, като 18. Може да е списък: ",
        "p59pre": "{\n\t\"spisuk\": [\"яйца\", \"хляб\", \"масло\"]\n}",
        "p60p": "Или дори още един обект JSON:",
        "p61pre": "{\t\"ime\": \"Gosho\",\n\t\"email\": \"gosho@email.email\",\n\t\"parola\": \"dobraparola\",\n\t\"vuzrast\": 18,\n\t\"dopulnitelno\": {\n\t\t\"spisuk\": [\"яйца\", \"хляб\", \"масло\"]\n\t}\n}",
        "p62p": "След края на стойност има запетайка, следващ ключ и така нататък.",
        "p63w": "След последната стойност няма запетая.",
        "p63p": "JSON е най-честия формат за пренасяне на информация в Интернет",
        "p64tq": "Стойността на ключ в JSON не може да е:",
        "p64a1": "списък",
        "p64a2": "текст",
        "p64a3": "число",
        "p64a4": "файл",
        "p65rq": "Намери информация за файловите формати TOML и YAML"
    },
    "l5": {
        "title": "Урок 5",
        "text": "където ще научиш как са управлявали компютрите преди графиката",
        "p1p": "В този урок ще се върнем към древните времена, когато е нямало графични интерфейси. Когато всеки, който е работил с компютър е навигирал само чрез текст в един тъмен прозорец - ще разгледаме конзолата.",
        "p2p": "Конзолата е различна според операционната система. На Windows е CMD или PowerShell. На Linux най-вероятно е Bash. На MacOS е Terminal („терминал“). Последните две са базирани на Unix конзолата, тоест имат подобни команди. CMD и PowerShell се различават малко. Тук ще покрия главно CMD и Unix конзолите.",
        "p3p": "Когато отвориш конзола, тя ще стартира с активна папка в потребителя ти. Ще видиш нещо подобно:",
        "p4con": "<<prefix>>C:/Users/Потребител>",
        "p5p": "След „>“ ще имаш поле за писане. Можеш да напишеш команда и да натиснеш „Enter“ („нов ред“) за да я изпълниш. Първата команда, която ще разгледаме е „tree“ („дърво“). Тази команда показва всички папки и файлове като дърво. Понякога е полезна, особено ако работиш в среда без графичен интерфейс. Действа и много добре за показване на „умения“ и хвалене.",
        "p6tq": "tree командата показва:",
        "p6a1": "Картинка на дървото",
        "p6a2": "Структурата на файловете",
        "p6a3": "Структурата на папките",
        "p6a4": "Структурата на папките и файловете",
        "p7p": "Освен това, в случая „C:/Users/Потребител>“ е нашата работна папка. Можем да я сменим. Това става чрез командата „cd“ от „change directory“ („промени директория“ (директория е синоним на папка)). Конзолата действа с относителни адреси. Тоест, ако напишем:",
        "p8con": "<<prefix>>C:/Users/Потребител> cd ./",
        "p9p": "Ще останем в същата папка. Ако напишем:",
        "p10con": "<<prefix>>C:/Users/Потребител> cd ../",
        "p11p": "Ще получим:",
        "p12con": "<<prefix>>C:/Users>",
        "p13p": "Защото сме се върнали папка назад. За да се върнем в „Потребител“ можем да напишем:",
        "p14con": "<<prefix>>C:/Users> cd Потребител",
        "p15p": "Което ще има резултат:",
        "p16con": "<<prefix>>C:/Users/Потребител>",
        "p17p": "Ако искаме да навигираме до папка, в чието име има празно място, заграждаме името в кавички:",
        "p18con": "<<prefix>>C:/Users/Потребител> cd \"Папка с празно място\"",
        "p19p": "Ако отново имаме абсолютния път „C:/Users/Gosho/Documents/nominacii.docx“, и имаме конзола в „C:/Users/“, можем директно да стигнем до „Documents“ по следния начин:",
        "p20con": "<<prefix>>C:/Users/> cd ‘’Gosho/Documents/",
        "p21p": "Ще имаме резултат:",
        "p22con": "<<prefix>>C:/Users/Gosho/Documents/>",
        "p23tq": "При работна папка \"C:/Users/Gosho/Documents/\" и изпълнена команда \"cd ./\" ще отидем в папка:",
        "p23a1": "Ще останем в сегашната",
        "p23a2": "Ще отидем в \"Gosho\"",
        "p23a3": "Ще отидем в \"Users\"",
        "p23a4": "Ще отидем в \"C:/\"",
        "p24p": "От конзолата могат и да се пускат приложения. Ако имаш файл с име „program.exe“ (поне на Windows) в работната си папка и напишеш в конзолата „program.exe“, програмата ще стартира.",
        "p25con": "<<prefix>>C:/Users/Gosho/> program.exe",
        "p26p": "Много от програмите имат и аргументи. Те се пишат във формат „-ключ стойност“. Например: („light“ - светъл)",
        "p27con": "<<prefix>>C:/Users/Gosho/> program.exe -mode light",
        "p28p": "Програмата ще получи тази информация. В уроците напред ще се научиш да четеш и пишеш в конзолата чрез програми и да взимаш и ползваш аргументи.",
        "p28tq": "Кое е валиден ключ за аргумент?",
        "p28a1": "-mode",
        "p28a2": "*mode",
        "p28a3": "mode",
        "p28a4": "/mode",
        "p29rq": "Потърси как се създават, трият, копират и местят файлове в твоята конзола."
    },
    "l6": {
        "title": "Урок 6",
        "text": "където ще научиш какво е алгоритъм",
        "p1p": "Аххх – алгоритъм! Една от по-криворазбраните думи като цяло. И сега ще си говорим точно за нея.",
        "p2p": "Да изясним първо какво е алгоритъм. Алгоритъм е последователност от действия за постигане на резултат.",
        "p3p": "Това е всичко. Алгоритъм е например сутрешната рутина:",
        "p4p": "Ставам. Измивам си зъбите. Закусвам. Резултатът е, че съм готов за деня.",
        "p5p": "За постигане на един и същ резултат може да има няколко различни алгоритъма:",
        "p6p": "Ставам. Измивам си зъбите. Къпя се. Закусвам. Пак съм готов.",
        "p7p": "Ставам. Гледам часовника. Закъснявам с 30 минути. Мия си зъбите докато се обличам. Отново съм готов.",
        "p8p": "Резултатът също е общ. Например, ако сортирам една купчина предмети по един начин и друга по същия начин, купчините не са еднакви. Но резултата от алгоритъма за сортиране е еднакъв – елементите са сортирани. По същия начин, алгоритъма за тотото винаги има еднакъв резултат – винаги има изтеглени 6 числа, нищо че са различни всеки път.",
        "p9p": "Да се извърши един и същ алгоритъм два пъти и да се очаква различен резултат е лошо, а ако се получи, значи има грешка в алгоритъма – очаква се реултатът от алгоритъма за пране да е „чисти дрехи“, не „наводнена стая“.",
        "p10tq": "При две извършвания един алгоритъм се очаква да има:",
        "p10a1": "Различни действия",
        "p10a2": "Различен резултат",
        "p10a3": "Еднакъв резултат",
        "p10a4": "Различни алгоритми",
        "p11p": "Подобно е в програмирането. Всяка програма действа с множество алгоритми. Ти ще създадеш много. Някои ще прочетеш, защото са били измислени от хора по-умни от мен и теб. Да разгледаме един.",
        "p12p": "Представи си, че пред теб има 10 числа в редица. Всъщност, не си представяй. Ето ги:",
        "p13p": "1, 5, 78, 6, 9, 127, 6758, 89, 9680, 9679",
        "p14p": "Намери най-голямото число.",
        "p15p": "„9680!”, разбира се. Но как го намери? „Видях го“ не е валиден отговор. Компютрите не виждат. Нека да създадем алгоритъм за намиране на най-голямото число:",
        "p16p": "Ти най-вероятно първо си взел числото, което ти е изглеждало най-голямо. На компютъра обаче не му „изглежда“, така че за целта на този алгоритъм ще изберем първото число. „1“ в този случай. След това ще погледнем следващото число. То е 5, което е по-голямо от 1. Значи нашето число вече е 5. След това имаме 78. То е по-голямо от 5, значи нашето число вече е 78. След това има 6. 6 е по-малко от 78. Значи го пропускаме и 78 остава нашето число. Това продължава до края на редицата числа. Накрая, гарантирано нашето число ще бъде най-голямото – 9680.",
        "p17tq": "Как да модифицираме горния алгоритъм, за да намира най-малкото число от редицата?",
        "p17a1": "Слагаме минус пред крайния резултат",
        "p17a2": "Вместо за по-голямо, проверяваме за по-малко",
        "p17a3": "Обръщаме редицата преди това",
        "p17a4": "Изваждаме сбора на числата от редицата от резултата",
        "p18p": "Това е един от множеството алгоритми, които ще срещнеш, но със сигурност е един от най-простите и най-често използваните. ",
        "p19t": "Ако ще използваш алгоритъм достатъчно, ще го научиш от повторение. Ако не го използваш достатъчно, за да го научиш, значи че не ти се и налага. От теб се иска само да запомниш, че го има, в случай че ти потрябва, за да можеш да го потърсиш. Освен ако нямаш специалната задача да научиш алгоритъм наизуст. А аз няма да ти давам такива задачи."
    },
    "l7": {
        "title": "Урок 7",
        "text": "където ще научиш връзката между бисквитите и паметта",
        "p1p": "Това е един от по-сложните уроци, тоест внимавай. Ще се занимаем с паметта.",
        "p2p": "Първо да ти обясня, че компютърът има 2 типа памет – RAM и ROM. ROM паметта е в хард дискове, SSD-та и т.н. Това е постоянна памет – тя продължава да съществува дори и да няма ток към нея. На нея се съхраняват файловете и някои други неща. Представи си, ако всеки път когато рестартираше компютъра си, трябваше да преинсталираш операционната си система… и всичките ти файлове се губеха… и трябваше да преинсталираш всяко приложение... Хаос, нали? Това е проблема, който решава ROM паметта. Тя обикновено е и голяма – трябва да има място за всичко. Къде обикновено се проваля е в бързината -  ROM паметта исторически не е бърза. ",
        "p3p": "Вторият тип памет е RAM паметта. Тя обикновено е много по-бърза и много по-малко от ROM. Тя обаче зависи от източника на енергия – в момента, в който той вече отсъства, тя се изпразва напълно. На нея зареждат приложенията – например, когато отворите калкулатора и напишете число в него, то се запазва в RAM. Така го виждате докато пишете. Текстът, който пишете в Word е запазен в ROM, но го виждате защото е бил зареден в RAM. RAM  е паметта, до която приложенията имат директен достъп. Затова и всичко се затваря, когато рестартираш компютъра си. Запазването в ROM е малко по-сложно.",
        "p4tq": "RAM е памет, която:",
        "p4a1": "e енергийно зависима",
        "p4a2": "върви само на екологична енергия",
        "p4a3": "запазва в перманентна форма",
        "p4a4": "e вида на хард дисковете",
        "p5p": "Да преминем на двете части, на които се разделя RAM паметта при всяка програма.",
        "p6h": "Heap",
        "p7p": "Heap (чете се „хийп“, означава „купчина“) е единия вид памет, до който има достъп всяка програма. Както показва името, той е купчина от информация – буквално. Представи си купчина играчки, нахвърляни една върху друга. Друго важно нещо за хийпа е, че той има случайна подредба. Освен това е доста голям. Тоест, ако процесора получи команда от типа „запази ми 4 байта на хийпа“, той ще започне да минава през хийпа от началото му. В някакъв момент ще намери празно място. След това ще преброи битовете до края на празното място, и ако има достатъчно, ще отдели паметта като заета – 4 байта, както гласи съобщението. Веднъж заета, паметта седи така до един от два случая – или бива маркирана като свободна на по-късен етап, или при край на изпълнението на програмата. Това е хубаво, но след като заемем памет на хийпа, как стигаме до нея? Все пак тя е случайно разхвърляна. И всеки, който е търсил играчка в купчината знае колко е сложно това. Да не говорим, че целия процес на заемане на памет не е особено бърз – просто паметта е много.",
        "p8tq": "Хийпът е:",
        "p8a1": "голям",
        "p8a2": "малък",
        "p8a3": "подреден",
        "p8a4": "много бърз",
        "p9h": "Stack",
        "p10p": "За да реши предните проблеми, на помощ идва Stack паметта („стак / стек“). Тя не е голяма, но е подредена и бърза. Тя е и общото между пакетите обикновени бисквити и компютрите. Остави ме да обясня:",
        "p11p": "Стакът е много прост. Той е като кутия, при която е открита горната част:",
        "p12alt": "Правоъгълник с открита горна част",
        "p13p": "В тази кутия могат да се слагат единствено други кутии, които са една върху друга:",
        "p14alt": "Кутията от по-горе, този път с три други правоъгълника вътре, поставени един върху друг",
        "p15p": "Както забелязваш, към кутия може да се прибави само от горе. И може да се извади само последното добавено нещо. Като пакетите с обикновени бисквити. Това е стакът. Но как решава проблемите с хийпа? ",
        "p16p": "Всеки път когато програмата навлезе в нов блок код, към стака се добавя още една кутия. Можем да запазваме на кутийката на блока в стака. Ако обаче ни трябва хийпа заради големината му, изпращаме подобно на горното съобщение на процесора. Той заема паметта и ни отговаря с адрес. Ние можем да запазим този адрес в кутийката ни на стака. Ако имаме нужда, можем да използваме този адрес, за да се върнем на заетата памет, да я променим, или да кажем да бъде маркирана като свободна за заемане. ",
        "p17p": "Има един проблем обаче. Когато нашия блок код свърши, кутийката ни в стака изчезва. С нея изчезва и запаметения адрес. Тоест, ние вече нямаме достъп до заетата памет от хийпа – тя ще продължи да съществува до затваряне на програмата. Това се нарича memory leak – теч на памет. Течовете на памет водят до огромни проблеми със сигурността и ресурсната тежест на програмите. В следващия урок ще разберем как различните езици за програмиране се справят с това.",
        "p18tq": "Течовете на памет се получават от:",
        "p18a1": "Разливане на вода върху RAM",
        "p18a2": "Разливане на вода върху ROM",
        "p18a3": "провал да се маркира като свободна памет от стака",
        "p18a4": "провал да се маркира като свободна памет от хийпа",
        "p19p": "Може би си забелязал/a, че след този урок има тест. Късмет!"
    },
    "t1": {
        "title": "Тест 1",
        "text": "където ще провериш уменията си с компютри",
        "p1fqc": "Превърни двоичното 1111 0101 в десетично число:",
        "p1a": "245",
        "p2fqc": "Превърни десетичното 136 в двоично число:",
        "p2a": "1000 1000",
        "p3fqc": "Пресметни 1011 1010 – 0010 0100, като знаеш че и двете числа са двоични. Резултата запиши като число в база 16:",
        "p3a": "91",
        "p4fqc": "Пресметни 1011 умножено по 10, като знаеш че и двете числа са двоични. Резултата запиши като десетично число:",
        "p4a": "22",
        "p5tqc": "Къде най-често се използват така наречените „хексове“?",
        "p5a1": "Координати",
        "p5a2": "Цветове",
        "p5a3": "Мерни единици",
        "p5a4": "Аритметични действия",
        "p6tqc": "ASCII поддържал ли е кирилица?",
        "p6a1": "Да",
        "p6a2": "Не",
        "p7tqc": "Каква оптимизация използва UTF-8, за да съхранява ефективно всички символи?",
        "p7a1": "Съхранява най-често използваните с 4 бита",
        "p7a2": "Съхранява най-често използваните с 8 бита",
        "p7a3": "Съхранява рядко използваните с 2 байта",
        "p7a4": "Съхранява най-често използваните с 8 байта",
        "p8tqc": "Пътят „../“ като относителен означава:",
        "p8a1": "Предишна папка",
        "p8a2": "Сегашна папка",
        "p8a3": "Сегашен файл",
        "p8a4": "Работна папка",
        "p9tqc": "Разширението на файла НЕ:",
        "p9a1": "помага за организацията на файловете",
        "p9a2": "е част от името на файл",
        "p9a3": "показва за коя програма е предназначен файла",
        "p9a4": "лимитира с каква програма може да бъде отворен файла",
        "p10tqc": "XML НЕ се използва за:",
        "p10a1": ".docx файлове",
        "p10a2": "HTML",
        "p10a3": "YAML",
        "p11tqc": "JSON следва модела:",
        "p11a1": "ключ-стойност",
        "p11a2": "информация – размер",
        "p11a3": "стойност – обяснение",
        "p11a4": "файл-стойност",
        "p12tqc": "Командата „cd“:",
        "p12a1": "променя директорията",
        "p12a2": "създава файл",
        "p12a3": "изтрива директорията",
        "p12a4": "изтрива файл",
        "p13tqc": "За алгоритмите е вярно, че:",
        "p13a1": "се очаква да имат повече от един резултат",
        "p13a2": "са последователност от действия",
        "p13a3": "при всяко изпълнение действията се променят",
        "p13a4": "при всяко изпълнение не действат",
        "p14tqc": "ROM паметта зависи от енергия:",
        "p14a1": "Да",
        "p14a2": "Не",
        "p15tqc": "RAM паметта зависи от енергия:",
        "p15a1": "Да",
        "p15a2": "Не",
        "p16tqc": "Приложенията зареждат на RAM паметта:",
        "p16a1": "Да",
        "p16a2": "Не",
        "p17tqc": "Хийпът е:",
        "p17a1": "хаотичен",
        "p17a2": "подреден",
        "p18tqc": "Можем да извадим елемент от стака, дори ако върху него има друг елемент:",
        "p18a1": "Да",
        "p18a2": "Не",
        "p19fqc": "Какво се случва, когато загубим адреса на парче памет в хийпа, без да сме го маркирали като свободно?",
        "p19a1": "memory leak",
        "p19a2": "теч на памет",
        "p20fqc": "Опитай да си обобщиш какво научи в предния раздел в няколко изречения."
    },
    "l8": {
        "title": "Урок 8",
        "text": "където ще научиш какво ще учиш",
        "p1p": "Какво е програмен език? Програмен език е език, с който се програмира, очевидно. Програмните езици са синтетични, изкуствени, конструирани и създадени от хора – те си приличат. Приличат си много. Почти всеки език има концепциите на почти всеки друг език. В повечето случаи даже и думите са еднакви – като нашите говорими езици от латинското семейство, или от германското семейство, или от славянското семейство. Стига да знаеш един език от семейството, другите са много по-малка пречка. А един бонус на програмните езици, е че те имат по около 100 думи, а не по 1000 страници думи като нормалните езици. Какво искам да ти кажа е, че програмния език няма особено значение. Важни са концепциите. И за остатъка от този „курс“ ще научиш повечето от тях. След това ще си свободен да ползваш всеки програмен език.",
        "p2p": "Програмните езици водят началото си преди много време. Първоначално, на процесорите е трябвало да се дават команди, написани чрез дупки на картончета – дупка означавала 0, а място – 1. След това, някой е измислил Assembly. Първия „истински“ програмен език. Той не е бил много над нулите и единиците обаче – просто командите са се пишели с текст, не с числа, което е било огромно подобрение. А и е бил специфичен за всяка архитектура процесори – представяш ли си да напишеш една програма 3 пъти за 3 различни архитектури!?",
        "p3p": "След това се е случило чудо. Появил се е „C“ (“си”). Първия модерен програмен език! Той има повечето от функциите, които и всеки друг модерен програмен език има. Но преди толкова много време – през 1972г! Това е било революция – най-после кодът е приличал повече на нещо, написано в днешно време. А и е можело да напишеш код веднъж и да създадеш от него програми за множество архитектури.",
        "p4p": "Обаче „C“ не е само рози. Езикът оставя програмистът сам да контролира паметта си. Което е много хубаво, ако разбираш какво правиш, и много лошо, ако не, защото създаваш код пълен с течове на памет и проблеми.",
        "p5p": "Днес много голяма част от света продължава да върви на C. И на неговия следващ език – C++. Даже и операционната система, която ползваш, най-вероятно е написана на тях.",
        "p6p": "Езиците, споменати до сега са ниско ниво – те са близко до компютъра – дават на програмиста контрол над паметта и накрая стигат директно до компютърни команди. Това се случва, благодарение на компилатор. Компилатор е програма, която взима и чете файл, на да кажем C, и създава машинен код от него. Машинния код вече може да се разпространява и да върви на компютъра.",
        "p7p": "От създаването на C до днес много езици да били направени, станали са популярни, и даже са изчезнали – BASIC, Visual Basic, COBOL, Fortran (този продължава да се ползва в математиката). Много и продължават да съществуват – Java, C#, Python, Perl, Ruby, Javascript. А нови езици се появяват постоянно – Kotlin, Go, Rust, Typescript.",
        "p8p": "Езици като Java и C# са високо ниво – те са по-прости, по-контролирани и не позволяват контрол над паметта – обикновено всяко парче памет се запазва на хийпа с адрес в стака. От време на време, през хийпа минава програма на езика, наречена „Garbage collector“ (събирач на боклук), която проверява дали парчетата памет имат запазен адрес някъде в стака. Ако нямат – биват изтрити. Автоматично. Директно на стака се запазват обикновено примитивните типове (int, short, long, float, double, char, boolean, които ще разгледаме в следващите уроци), когато са локални (не са част от или общи за клас – ще разбереш по-късно).",
        "p9p": "Има и езици като Python („пайтън“, питон) – старата шега е, че да си направиш къща с Assembly е като да си отрежеш сам дървата и да си я построиш, със C имаш дървата, само трябва да строиш, а при Python ти доставят къщата готова. Python е интерпретиран език. Това значи, че за да пуснеш програма с него, трябва да инсталираш езика на компютъра си. Когато стартираш програмата, интерпретатора започва да чете файла в движение – това прави езика по-бавен, но му позволява да върви навсякъде – ако на устройството може да се инсталира Python, то всяка програма написана на него върви там.",
        "p10p": "Стигаме и до езиците, които ще се използват тук – Java („джава“) и C# („си шарп“). Те са два от най-ползваните езици в световен мащаб, и два от най-подобните. И двата езика са някъде между C и Python като ниво.",
        "p11p": "Уникалното при Java е, че тя е компилирана и интерпретирана. Всяка Java програма първо се компилира в нещо, наречено byte-code („байт код“). Този код се разпространява като програма. За да бъде стартиран, компютърът, на който е, трябва да има инсталирана Java. При стартиране JVM (Java virtual machine – Java виртуална машина) взима байт кода и започва да го интерпретира. Това позволява на Java бързина подобна на тази на компилираните езици и способността да върви на всеки компютър с Java.",
        "p12p": "C# е подобен. Той първо се компилира до код наречен IL. Когато се стартира на друг компютър, .NET Common Language Runtime („точка нет общ езиков изпълнител“) го компилира втори път, този път до машинен код и го пуска. Това му позволява да е бърз като компилиран език, но и да върви на всеки компютър с .NET Common Language Runtime.",
        "p13p": "Езиците за програмиране обаче не са прости. И не можем просто да ги пишем в Notepad – би било твърде трудоемко. Затова съществуват IDE-та („Integrated development environment“ – интегрирана среда за разработка). Те са редактори на текст, които позволяват бърза смяна на отворени файлове, опитват да предскажат какъв код ще напишеш, опитват да поправят грешките ти, помагат да ги откриваш сам, и обикновено имат бутон за пускане на програмата, за да не трябва да запомняш дългите команди на конзолата, които се искат, за да компилираш и пуснеш програма. Те обаче са само това – те не могат да променят езика, не могат да причиняват грешки сами и т. н.",
        "p14p": "От следващия урок започва програмирането. Истинското. И трябва да се подготвиш. Избери си кой език ще следваш – C# или Java. Няма особено значение.",
        "p15p": "Избра ли?",
        "p16p": "Ако си избрал Java, имаш два избора за IDE – Eclipse и IDEA, които аз ползвам. За начинаещи, препоръчвам Eclipse, но ако искаш, можеш да започнете и веднага от IDEA.",
        "p17p": "Ако си избрал C#, имаш един избор – Visual Studio.",
        "p18p": "Надолу ще обясня процеса на инсталация на всичко нужно и започването на проект:",
        "p19ds1": "Eclipse",
        "s19p": "Трябва да инсталираш Eclipse. Отиди на следния сайт: https://www.eclipse.org/downloads/",
        "s20p": "и натисни Download бутона. Ще бъдеш заведен на друга страница. Натисни бутона за теглене там. Операционната ти система автоматично ще бъде разпозната. След изтегляне на файла, отвори го. Ще ти излезе списък с опции. Искаш „Eclipse IDE for Java Developers”. Ще ти излезе меню, където можеш да редактираш папката за инсталация. Освен това, Eclipse инсталира Java автоматично за теб, така че избери версия от същото меню. След това следвай инструкциите за инсталация. След инсталацията стартирай програмата.",
        "s21p": "Когато програмата стартира, в горния ляв ъгъл ще видиш бутон File. Натисни го и избери опцията New. После избери Java Project. Ще ти излезе прозорец, където да именуваш проекта си – избери име на латиница. Пробвай да няма празни пространства в името. Натисни Finish. В левия панел ще се появи проекта ти. Той ще има две неща под себе си – JRE System Library и src. Интересуваш се само то src. Натисни с десния бутон на мишката на src и избери New от появилото се меню. След това избери Package. Това е пакет и ще разбереш неговата функция по-късно. Дай му име, с малки букви, на латиница и натисни Finish. Ще се появи новосъздадения пакет. Избери го и го натисни с десния бутон на мишката. Отново ще се появи менюто. Отново избери New. Този път на New избери Class. Избери име, което да започва с голяма буква и да е на латиница. Без празни пространства. Отдолу ще видиш опция за тикче „public static void main(String[] args)“. Натисни я, така че да се появи тикчето. Натисни Finish. Току-що създаде първия си Java файл! Пред теб трябва да стои нещо такова:",
        "s22cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}",
        "s23p": "Редактирай го, така че да стане:",
        "s24cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Здравей свят!\");\n\t}\n\n}",
        "s25p": "Горе намери зелена, кръгла иконка с триъгълник вътре. Натисни я. Натисни OK, ако те пита нещо. Ще се отвори конзола долу. На нея трябва да пише „Здравей свят!“. Пусна първия си код. Браво!",
        "s19ds2": "IDEA",
        "s26p": "Трябва да инсталираш IDEA. Отиди на следния сайт - https://www.jetbrains.com/idea/download/.",
        "s27p": "и натисни Download бутона под Community текста. Ще започне изтеглянето на файла. След това го стартирай и изпълни инструкциите за инсталация.",
        "s28p": "Стартирай програмата. Възможно е да те пита няколко въпроса за режима (светъл или тъмен).",
        "s29p": "Ще ти излезе меню. Избери New Project. В ляво се увери, че е избранa Java. От менюто в дясно избери Project SDK. Ще ти излезе списък. Натисни Download JDK. Натисни Download на новото меню. Това ще изтегли Java вместо теб, автоматично. Натисни Next долу вдясно. Натискай Next докато се появи менюто с Project name. Напиши име на проекта си, на латиница, без празни места. Натисни Finish. Проектът ще се отвори. Вляво ще видиш няколко неща. Интересуваш се от папката src. Натисни с десния бутон на мишката на src и избери New от появилото се меню. След това избери Package. Това е пакет и ще разбереш неговата функция по-късно. Дай му име, с малки букви, на латиница и натисни Enter. Ще се появи новосъздадения пакет. Избери го и го натисни с десния бутон на мишката. Отново ще се появи менюто. Отново избери New. Този път на New избери Java Class. Избери име, което да започва с голяма буква и да е на латиница. Без празни пространства. Натисни Enter, за да го завършиш. Току-що създаде първия си Java файл! Пред теб трябва да стои нещо такова:",
        "s30cj": "package hello;\n\npublic class Hello {\n}",
        "s31p": "Редактирай го, така че да стане:",
        "s32cj": "package hello;\n\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Здравей свят!\");\n    }\n}",
        "s33p": "Натисни с десния бутон на мишката върху текста. Ще се отвори меню. От него избери Run.",
        "s34p": "Ще се отвори конзола долу. На нея трябва да пише „Здравей свят!“. Пусна първия си код. Браво!",
        "s35t": "Интересно: Забележи текста над „Здравей свят!“. Това е командата нужна за пускане на кода. Започва с пътя към Java. След това има други настройки и пътя към файла, който си пуснал. IDE ти спестява да пишеш нещо такова, за да стартираш файл.",
        "s19ds3": "Visual Studio",
        "s36w": "Visual Studio към момента на писане на това е наличен само за Windows",
        "s37p": "Трябва да инсталираш Visual Studio. Отиди на следния сайт -https://visualstudio.microsoft.com/downloads/",
        "s38p": "и натисни Free Download бутона под Community текста. Ще се изтегли файла. Пусни го. Натискай Continue, докато се появи меню със заглавие Workloads. Избери .Net desktop development. По-късно можеш да инсталираш и други пакети. Натисни Install. Чакай да приключи инсталацията. Възможно е да се поиска рестартиране на компютъра. Извърши го. След това стартирай Visual Studio. Ще ти бъдат зададени въпроси за режима (светъл или тъмен). Избери както искаш. След това ще се появи меню. Вдясно избери опцията Create a new project. Менюто ще се промени на такова със заглавие Create a new project. При менюто на езиците (първи правоъгълник горе вдясно) избери C#. Долу избери Console App (.NET Core). Натисни Next. Избери име на проекта при Project Name. То да е на латиница и да започва с главна буква, без празни пространства. Натисни Create. Ще се отвори нов проект. В него ще е отворен файл Program.cs. Намери файла вляво. Натисни с десен бутон на мишката. Ще се появи меню. Натисни Delete и след това OK. Натисни името на проекта вляво и го натисни с десния бутон на мишката. Натисни Add от менюто и после натисни New item. Ще се появи меню. Избери Class. Долу напиши име, на латиница, започващо с главна буква, без празни пространства. Трябва да завършва на .cs, тоест не редактирай разширението. Натисни Add. Ще се появи нещо подобно:",
        "s39cc": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n    }\n}",
        "s40p": "Редактирай го, така че да стане:",
        "s41cc": "using System;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Здравей свят!\");\n        }\n    }\n}",
        "s42p": "Горе трябва да има правоъгълник с името на проекта и зелен триъгълник. Натисни го и избери името на проекта. Ще се отвори конзолата в черен прозорец. На нея трябва да пише „Здравей свят!“. Пусна първия си код. Браво!"
    },
    "l9": {
        "title": "Урок 9",
        "text": "където ще видиш код за първи път",
        "p1p": "В миналия урок принтирахме към конзолата. Всяка програма има main метод („главен“). Какво е метод, ще разбереш по-късно. Програмата винаги стартира от него. Тоест, ние ще пишем кода си вътре.",
        "p2ds1": "Java",
        "s3cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\t// Пишем кода си тук\n\t}\n\n}",
        "s2ds2": "C#",
        "s4cc": "using System;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n        static void Main(string[] args)\n        {\n            // Пишем кода си тук\n        }\n    }\n}",
        "p5p": "„//“ означава коментар. Когато го напишем на ред в програмата, остатъка от този ред вече не е код; той е коментар, който програмата не чете. През компилацията той се изтрива. Идеята е да можеш да обясниш какво прави дадено парче код до самия код. Запомни, с коментар не описвай какво си направил – това е очевидно, независимо дали четеш файл или махаш последния символ на файл. В коментар описвай защо си направил нещото – четеш файл, за да заредиш настройки, или махаш последния символ, за да не причиниш грешка. Това са неочевидни неща.",
        "p6pc": "/* Това пък е коментар на няколко реда. Той не приключва до поява на */",
        "p7w": "В края на всеки ред код се записва точка и запетая - „;“",
        "p8p": "Освен това си забелязал {} – тези скоби означават нов блок код. Забележи, че всеки блок код отива по-навътре в полето – или с един tab, или с три празни пространства. В Java, когато започва нов блок, пишем отварящата скоба { на предния ред. При C# е на следващия. Забележи, че и на двете места има main (string[] args). Важно е да се отбележи, че в Java main е с малка буква, а String – с голяма, а в C# е обратното. Това нещо „args“ съдържа аргументите дадени на програмата от конзолата. Помниш ли? Онези неща, които се пишеха така „-аргумент стойност“. Останалата част от кода също е нужна за функциониране на програмата. Да видим как се принтира на конзолата в двата езика:",
        "p9ds1": "Java",
        "s9cj": "System.out.println() // Това принтира и след това оставя един ред – идва от print line – принтирай ред\nSystem.out.print() // Това принтира, но не оставя един ред. System.out.println() използва това, \n//само че добавя един символ „\\n“, накрая, за да покаже нов ред. Спомняш ли си, че това беше символа за нов ред?",
        "s10p": "Ето го нагледно:",
        "s11cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(„Как си?“);\n\t\tSystem.out.print(„Добре. “);\n\t\tSystem.out.println(„А ти как си от 1 до 10?“);\n\t\tSystem.out.print(5);\n\t\tSystem.out.print(„И по-добри дни съм имал“);\n\n\t}\n\n}",
        "s9ds2": "C#",
        "s12cc": "Console.WriteLine() // Това принтира и след това оставя един ред – идва от write line – напиши ред\nConsole.Write() // Това принтира, но не оставя един ред. Console.WriteLine() използва това, \n//само че добавя един символ „\\n“, накрая, за да покаже нов ред. Спомняш ли си, че това беше символа за нов ред?",
        "s13p": "Ето ги нагледно:",
        "s14cc": "using System;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n        static void Main(string[] args)\n        {\n\t\tConsole.WriteLine(„Как си?“);\n\t\tConsole.Write(„Добре. “);\n\t\tConsole.WriteLine(„А ти как си от 1 до 10?“);\n\t\tConsole.Write(5);\n\t\tConsole.Write(„И по-добри дни съм имал“);\n\n        }\n    }\n}",
        "p15p": "Резултат в конзолата:",
        "p16con": "<<output>>Как си?\n<<output>>Добре. Ти как си от 1 до 10?\n<<output>>5И по-добри дни съм имал",
        "p17p": "Забелязваш сливането на последния ред. Можеш ли да го обясниш?",
        "p18p": "Това е принтирането на конзолата. Сега трябва да говорим за променливите. Променливите имат свойството да се променят. Във всеки несатиричен програмен език има променливи. Те са как се използва паметта. Винаги следват следната формула:",
        "p19pc": "num = 5; //num идва от number / число",
        "p20p": "След това, напред в кода, num може да се използва. Например:",
        "p21pc": "print(num); // В този език, приеми, че принтирането става с print  – това би принтирало 5\n//самата практика се нарича псевдокод – код, който не е на никой език, а вместо това обединява няколко за по-лесно писане и обяснение",
        "p22p": "Тук num е името, а 5 е стойността",
        "p23p": "Променливите се именуват по различен начин от език на език, но почти винаги следват определени правила:",
        "p24p": "Имената винаги са една дума",
        "p25p": "Имената не могат да съдържат друго освен букви, цифри и „_“ или „-“",
        "p26p": "Думи, които езикът използва (например class), не може да са променливи",
        "p27p": "Името на променлива не може да започва с число – обяснението за това е просто - ако може да започва с цифра, името може да е число. Това може да породи ситуация от рода на:",
        "p28pc": "6 = 5",
        "p29p": "И после, ако имаме print(6);, езика ще се чуди дали да принтира 6 или 5. Тоест, това просто не се позволява.",
        "p30p": "Освен това има и някои стандарти за именуване.",
        "p31p": "В Java и C#, повечето променливи се именуват с camelCase (камилов тип). При него първата буква от първата дума е малка, а първата буква на всяка следваща дума е главна и всички думи са слети. Например:",
        "p32pc": "имеНаПроменливаВКамиловТип = 5;",
        "p33p": "За някои други неща (като класовете) се ползва PascalCase (Паскалов тип). При него първата буква от всяка дума е главна и всички думи са слети. Например:",
        "p34pc": "ИмеНаПроменливаВПаскаловТип = 5;",
        "p35p": "Има и snake_case (змийски тип). При него всички букви са малки и всяка дума е отделена от долна черта - „_“. Например:",
        "p36pc": "име_на_променлива_в_змийски_тип = 5;",
        "p37e": "Тук пиша имената на кирилица, за да са по-лесни за четене, но когато програмираш, винаги използвай само латиница!",
        "p38p": "Освен това, винаги давай значими имена на променливите. След компилацията така или иначе ще са по няколко случайни букви, така че в оригинал ги пиши обяснителни:",
        "p39p": "Най-вероятно не е добра идея да именуваш така:",
        "p40pc": "r = 5; // това се предполага, че е радиус на кръг",
        "p41p": "Ще е по-четимо така:",
        "p42pc": "radiusCircle = 5;",
        "p43p": "Така следващ човек, или ти самият, веднага ще знае, че това е радиус на кръг, а не на пирамидите в Гиза",
        "p44p": "Трябва да ти кажа и за типовете на променливите. Това, което гледа досега е „общ“ език. В него променливите сами знаят какво съдържат. Но в Java и C# това не е така. Всяка променлива има тип. Типът определя какъв вид информация ще съдържа променливата. Това осигурява, че няма да опитаме да съхраним в една променлива и текст, и по-късно число. Първия тип, който ще учим е Integer (целочислен тип) – или съкратено, както е и в езиците – int. Целочисления тип съдържа цели числа – 56 е цяло число, тоест може да бъде такава променлива, но 56.78 не е.",
        "p45p": "int е с големина 4 байта в почти всеки език. 4 байта е 32 бита, тоест най-големия възможен int би трябвало да е 4,294,967,295. Първия от тези битове обаче се запазва за знака – „+“ или „-“. Тоест int може да съдържа числа от -2,147,483,648 до 2,147,483,647.",
        "p46p": "Освен int има и два други целочислени типа – short и long – от „къс“ и „дълъг“ на английски. short има два байта – 16 бита. Първия е знак, тоест short може да съдържа числата между -32,768 и 32,767. long на своя страна е дълъг – има цели 8 байта – 64 бита. Дори и с първия си бит използван за знак, той може да съдържа числата между -9,223,372,036,854,775,808 и 9,223,372,036,854,775,807.",
        "p47p": "Прието е да се използва int, освен ако не си сигурен, че имаш малки числа – тогава се ползва short. Ако пък имаш неадекватно големи числа се използва long.",
        "p48p": "В някои езици има и така наречените „беззнакови“ типове („unsigned“). Те обикновено се записват като uint, ushort, ulong. При тях първия бит не се ползва за знак, тоест uint може да съдържа числата от 0 до 4,294,967,295. Тях няма да ги обсъждаме повече, но е хубаво да знаеш, че ги има.",
        "p49tq": "int е голям:",
        "p49a1": "1 байт",
        "p49a2": "4 бита",
        "p49a3": "4 байта",
        "p49a4": "8 байта",
        "p50p": "Сега да преминем към кода:",
        "p51pc": "int num = 5; // Така се създава променлива с целочислен тип. Типът е преди името на променливата\nint num = 5.56 // Това би ни дало грешка, защото 5.56 не е целочислено число.\n// Ако сме създали int num = 5;, по-късно можем да го променяме. Като го променяме не записваме типа.",
        "p52ds1": "Java",
        "s53cj": "int num = 5; // Създаваме / инициализираме променливата\nint secondNum = num; // Променливите може да са равни и на други променливи и взимат моментната им стойност\nSystem.out.println(num);\nnum = 6; // Променяме стойността на променливата. Не се записва типът.\nSystem.out.println(num);\nSystem.out.println(secondNum);",
        "s52ds2": "C#",
        "s54cc": "int num = 5; // Създаваме / инициализираме променливата\nint secondNum = num; // Променливите може да са равни и на други променливи и взимат моментната им стойност\nConsole.WriteLine(num);\nnum = 6; // Променяме стойността на променливата. Не се записва типът.\nConsole.WriteLine(num);\nConsole.WriteLine(secondNum);",
        "p55p": "Резултат в конзолата:",
        "p56con": "<<output>>5\n<<output>>6\n<<output>>5",
        "p57p": "Ако запишем типа докато променяме стойността, програмният език ще реши, че създаваме нова променлива. След това ще види, че вече има променлива с такова име и ще ни даде грешка.",
        "p58e": "Всяка променлива в един блок код трябва да има уникално име спрямо всяка променлива над нея.",
        "p59p": "Например:",
        "p60pc": "int num = 5; // Създаваме / инициализираме променливата\nint num = 6; // Грешката е тук – ще получим грешка, че вече има такава променлива – програмата ще спре, или „крашне“.",
        "p61p": "По същия начин се създават и другите типове:",
        "p62pc": "short shortNum = 1;\nlong  longNum = 900000000000; //Обикновено не се позволяват и разделители на групи в число; 9,000,000 би причинило грешка.",
        "p63p": "Освен това, можем да създаваме няколко променливи с еднакъв тип на един ред по следния начин:",
        "p64pc": "int x = 5, y = 6;",
        "p65p": "Даденият код създава две променливи цели числа x и y, като x има стойност 5, а y има стойност 6."
    },
    "l10": {
        "title": "Урок 10",
        "text": "където ще научиш какво е реално число",
        "p1p": "Време е за следващите два типа. Те ти позволяват да съхраняваш и нецели числа – например 9.76, 6.78. Това са float и double.",
        "p2p": "Името float идва floating point – „плаваща точка“. Тоест, точката която е в дробните числа. Голям е 4 байта. double („двоен“) го запомнете като това, че е двойно по-голям от float – 8 байта.",
        "p3p": "Когато в код запишеш дробно число, то се възприема като double. Трябва да добавиш „f“ в края му, за да стане float.",
        "p4p": "Примери в код:",
        "p5pc": "float num = 5.67; // Получаваш грешка, че не може да дадеш на тип float стойност от тип double\nfloat num = 5.67f; // Това не дава грешка.",
        "p6pc": "double num = 5.67; // Не получаваш грешка",
        "p7p": "Подобно на int и тези типове могат да се принтират в конзолата:",
        "p8ds1": "Java",
        "s9cj": "float num = 5.68f;\ndouble otherNum = 5.67;\nSystem.out.println(num);\nSystem.out.println(otherNum);",
        "s8ds2": "C#",
        "s10cc": "float num = 5.68f;\ndouble otherNum = 5.67;\nConsole.WriteLine(num);\nConsole.WriteLine(otherNum);",
        "p11p": "Резултат:",
        "p12con": "<<output>>5.68\n<<output>>5.67",
        "p13tq": "double или float може да съдържа повече битове информация?",
        "p13a1": "double",
        "p13a2": "float",
        "p14rq": "Потърси как да присвоиш double на float в твоя език. Пробвай с Интернет или напиши грешния код в твоето IDE и виж какви стъпки за поправка ти се предлагат, когато поставиш мишката си на червената линия, показваща грешка."
    },
    "l11": {
        "title": "Урок 11",
        "text": "където ще научиш как се събират и изваждат числа… още веднъж",
        "p1p": "В програмните езици има така наречените „експресии“ или изрази. Изразите винаги достигат до даден тип променлива, независимо дали са аритметични операции или логически сравнения. Където може да се постави променлива от даден тип, може да се постави и израз, който стига до нея. Днес ще разгледаме един от типовете изрази – аритметичните операции.",
        "p2h": "Събиране",
        "p3p": "Можем да събираме две целочислени числа (int). Получаваме друг int.",
        "p4pc": "int intSbor = 5 + 4;\nprint(intSbor);",
        "p5p": "Резултат:",
        "p6con": "<<prefix>>>>9",
        "p7p": "Можем да събираме две числа от тип float или double:",
        "p8pc": "float floatSbor = 5.67f + 2.33f;\ndouble doubleSbor = 5.67 + 2.33;",
        "p9p": "Можем също и да събираме две променливи от един тип:",
        "p10pc": "int edno = 5;\nint dve = 6;\nint tri = edno + dve;\nprint(tri);",
        "p11p": "Резултат:",
        "p12con": "<<prefix>>>>11",
        "p13p": "Ако извършим каквото и да е аритметично действие върху две числа, съответно float и double, резултатът е с тип double (floatSbor и doubleSbor са създадени / декларирани по-горе):",
        "p14pc": "float floatDoubleSbor = floatSbor + doubleSbor; // Това ще даде грешка\ndouble floatDoubleSbor = floatSbor + doubleSbor; // Всичко е наред тук",
        "p15p": "Същата логика се следва и при операции между int и float или int и double – крайният резултат винаги е float или double:",
        "p16pc": "int intFloatSbot = intSbor + floatSbor; // Това ще даде грешка\nfloat floatDoubleSbor = intSbor + floatSbor; // Всичко е наред тук",
        "p17p": "Можем да поставяме колкото си искаме аритметични действия едно след друго:",
        "p18pc": "int sbor = 5 + 6 + 7 + 8 + 9 + 10 + 11;\nprint(sbor);",
        "p19p": "Резултат:",
        "p20con": "<<prefix>>>>56",
        "p21tq": "Резултатът от „5 + 6.5f + 5.12“ би бил от тип:",
        "p21a1": "int",
        "p21a2": "short",
        "p21a3": "float",
        "p21a4": "double",
        "p21p": "Аритметичните действия могат да се извършват на много различни места. Например:",
        "p23pc": "print(5+6+7);",
        "p24p": "Резултат:",
        "p25con": "<<prefix>>>>18",
        "p26h": "Изваждане",
        "p27pc": "int razlika = 6 – 5;\nprint(razlika);",
        "p28p": "Резултат:",
        "p29con": "<<prefix>>>>1",
        "p30p": "Може разликата в изваждане да е и отрицателно число:",
        "p31pc": "int otricatelnaRazlika = 5 - 6;\nprint(razlika);",
        "p32p": "Резултат:",
        "p33con": "<<prefix>>>>-1",
        "p34p": "Същите правила за действия между типове се прилагат.",
        "p35h": "Умножение",
        "p36p": "Умножението в програмирането се извършва със звездичката („*“):",
        "p37pc": "int proizvedenie = 5 * 6;\nprint(proizvedenie);",
        "p38p": "Резултат:",
        "p39con": "<<prefix>>>>30",
        "p40p": "Трябва да се отбележи, че програмните езици обикновено следват подредбата на действията (скоби -> умножение и деление -> събиране и изваждане):",
        "p41pc": "int izraz = (10 – 5*2)*6;\nprint(izraz);",
        "p42p": "Резултат:",
        "p43con": "<<prefix>>>>0",
        "p44p": "Тук първо се пресмята израза в скобите: 10 – 5*2. В него, първо се извършва умножението (5*2) и след това извждането (10 - 10). Изразът става 0 * 6, което е 0.",
        "p45pc": "int izrazSusSkobi = ((10 – 5)*2)*6;\nprint(izrazSusSkobi);",
        "p46p": "Резултат:",
        "p47con": "<<prefix>>>>60",
        "p48p": "Тук първо се пресмята израза в скобите: (10-5)*2, което е 5*2 = 10. След това 10 * 6 е равно на 60.",
        "p49p": "Същите правила за действия между типове се прилагат.",
        "p50tq": "Резултатът от „10*(6-5)“ е:",
        "p50a1": "10",
        "p50a2": "0",
        "p50a3": "55",
        "p50a4": "-44",
        "p50h": "Деление",
        "p52p": "Делението в програмирането е специфично според типа:",
        "p53pc": "int chastno = 6 / 2;\nprint(chastno);",
        "p54p": "Резултат:",
        "p55con": "<<prefix>>>>3",
        "p56p": "Това е очакваното: 6/2 е 3",
        "p57p": "Проблемът е, когато имаме деление, при което има остатък. Например 8/3. Тък като резултатът от това е грубо 2.66, а знаем, че в int може да има само цели числа, резултатът се запазва като 2:",
        "p58pc": "int chastnoSOstatuk = 8 / 3;\nprint(chastnoSOstatuk);",
        "p59p": "Резултат:",
        "p60con": "<<prefix>>>>2",
        "p61pc": "int drugoChastno = chastno / chastnoSOstatukl; // 3 / 2\nprint(drugoChastno);",
        "p62p": "Резултат:",
        "p63con": "<<prefix>>>>1",
        "p64p": "Ако имаме обаче float или double, получаваме очаквания резултат:",
        "p65pc": "float chastnoFloat =  8f / 3f;\nprint(chastnoFloat);",
        "p66p": "Резултат:",
        "p67con": "<<prefix>>>>2.6666667",
        "p68p": "Чакай… Какво?",
        "p69p": "Резултатът трябва да е 2.66. Ама не е. Оказва се, че компютрите и двоичната система не са много добри в точното представяне на дробни числа. Затова понякога има подобни грешки. Не се притеснявай – случват се често и няма специфичен начин да ги оправиш.",
        "p70p": "Същите правила за действия между типове се прилагат.",
        "p71tq": "Резултатът от 28 / 9, ако и двете числа са от тип int, е:",
        "p71a1": "3",
        "p71a2": "4",
        "p71a3": "1",
        "p71a4": "2",
        "p71h": "Деление с остатък",
        "p73p": "Делението с остатък, или модуло, е една операция която не се среща особено често в нормалната математика, но е полезна в програмирането. Тя се отбелязва с „%“ и връща само остатъкът на делението:",
        "p74pc": "int chastno = 9 / 2;\nprint(chastno);",
        "p75p": "Резултат:",
        "p76con": "<<prefix>>>>1",
        "p77p": "Можем да видим, че остатъкът от това деление е 1 – 8 се дели на 2, 9 не се. Следователно 9/2 би било 4, а 9%2 е 1. Това действа по-същия начин и при float и double.",
        "p78p": "Същите правила за действия между типове се прилагат.",
        "p79tq": "Резултатът от 28 % 9, ако и двете числа са от тип int, е:",
        "p79a1": "3",
        "p79a2": "4",
        "p79a3": "1",
        "p79a4": "2",
        "p79h": "Манипулации с 1",
        "p81p": "Много често в програмирането се налага да добавиш или извадиш 1 от число. Но понякога това е малко дълго. Например:",
        "p82pc": "int num = 2;\nnum = num + 1;\nprint(num);",
        "p83p": "Резултат:",
        "p84con": "<<prefix>>>>3",
        "p85p": "или",
        "p86pc": "int num = 3;\nnum = num - 1;\nprint(num);",
        "p87p": "Резултат:",
        "p88con": "<<prefix>>>>2",
        "p89p": "А пък програмистите са мързеливи хора. Затова са измислени операторите за манипулация с едно – „++“ и „--“. Нека да ги тестваме:",
        "p90pc": "int num = 2;\nnum++;\nprint(num);",
        "p91p": "Резултат:",
        "p92con": "<<prefix>>>>3",
        "p93p": "или",
        "p94pc": "int num = 3;\nnum--;;\nprint(num);",
        "p95p": "Резултат:",
        "p96con": "<<prefix>>>>2",
        "p97p": "Това е лесно. Проблема идва от това къде се поставят – може и преди и след променливата. Разликата, е че преди променливата първо се извършва оператора за манипулация с 1, а после другите действия. Ако е след това, първо се извършват другите действия, а след това - оператора за манипулация с 1. Дай направо да ти покажа:",
        "p98pc": "int num = 5;\nint num1 = 6;\nint num2 = num++ + num1; // Тук първо ще се извърши num + num1, тоест 5+6, което ще е 11\n// Съответно num2 ще стане 11. След това ще се извърши num++, където num ще стане 6\nprint(num);\nprint(num2);",
        "p99p": "Резултат:",
        "p100con": "<<prefix>>>>6",
        "p101con": "<<prefix>>>>11",
        "p102pc": "int num = 5;\nint num1 = 6;\nint num2 = num + ++num1; // Тук първо ще се извърши ++num1, тоест то ще стане 7\n// След това ще се извърши с num + num1 или 5+7 с резултат 12 \nprint(num1);\nprint(num2);",
        "p103p": "Резултат:",
        "p104con": "<<prefix>>>>7",
        "p105con": "<<prefix>>>>12",
        "p106p": "Дали ще ти се наложи да ползваш това като информация някога? Може би. Обикновено е добре просто да ползваш num++ на следващия ред или на предния, за да няма обърквания. Защо го включвам тук тогава? Защото е адски лесно да се направи въпрос за това на всеки изпит, следователно го има на всеки изпит.",
        "p107pc": "int num = 5;\nint num1 = 6;\nint num2 = 7;\nint num3 = num + num1++ + --num2;",
        "p108tq": "След извършената по-горна операция, num3 е равно на:",
        "p108a1": "17",
        "p108a2": "16",
        "p108a3": "19",
        "p108a4": "18",
        "p108exp": "Обяснение: първо се извършва –-num2, където num2 става 6. След това се случва събирането num + num1 + num2, което е равно на 5 + 6 + 6, тоест 17. Накрая се случва num1++, където num1 става 7.",
        "p110h": "Bitwise оператори",
        "p111p": "Bitwise („битуайз“) операторите са едно от най-големите възможни обърквания. Много е възможно да ги срещнеш някъде, но се моли това да не се случва (върху числа, има други ползи в някои езици, които са далеч по-практични).",
        "p112p": "Bitwise операторите са „<<“, „>>“, „|“, „&“, „^“, „~“. Те манипулират числата като битове.",
        "p113p": "<< и >> са така наречените шифтове. Те местят дадено число битовете към една страна. Например:",
        "p114pre": "10011100 << 1 е равно на 00111000",
        "p115pre": "10011100 >> 1 е равно на 01001110",
        "p116p": "Това може да има огромни ефектни – в първия пример 10011100 е 156, а след „<< 1“ 00111000 е равно на 56. Ефектите са почти непредвидими, а ползите малки.",
        "p117h": "|",
        "p118p": "„Логическото или“ е операция между две двоични числа, която действа така:",
        "p119pre": "\n0101 -> първо число\n0111 -> второ число\n0111 -> резултат",
        "p120p": "Тоест, ако на позиция има 1 и 0 се записва 1. Ако има два пъти 2 се записва 1. Ако има два пъти 0 се записва 0.",
        "p121h": "&",
        "p122p": "„Логическото и“ е операция между две двоични числа, която действа така:",
        "p123pre": "\n0101 -> първо число\n0111 -> второ число\n0101 -> резултат",
        "p124p": "Подобно на логическото или, само че 0 и 1 е 0. Тоест единствената ситуация, при която записваме 1 при 2 единици.",
        "p125h": "^",
        "p126p": "„Логическото ксор“ е операция между две двоични числа, която действа така:",
        "p127pre": "\n0101 -> първо число\n0111 -> второ число\n0010 -> резултат",
        "p128p": "Тук единствената ситуация, в която записваме 1 е когато двете числа са различни – 0 и 1.",
        "p129h": "~",
        "p130p": "Това е „комплимента“. При него резултатът от ~0101 е 1010 – тоест просто обръща битовете – при 1 има 0 и при 0 има 1."
    },
    "l12": {
        "title": "Урок 12",
        "text": "където ще разбереш защо учи кодирания на символи",
        "p1p": "Скоро идва времето, в което ще се научиш да запазваш текст. Преди това обаче, трябва да можеш да запазваш единични символи. В този урок ще се занимаваме с типа char.",
        "p2p": "char идва от character – „символ“ и запазва един единствен символ. Ето така:",
        "p3pc": "char a = ‘a’;",
        "p4w": "Символът се записва в единични кавички – ' '. Текстът се записва в нормални, а char може да има само един символ.",
        "p5p": "Това само по себе си не е много интересно – char запазва един символ. Но, спомни си какво казахме в урока за кодиране – всеки един символ се приема като число от компютъра. Това води до някои интересни неща – ‘a’ е по-малко от ‘b’. И ни позволява да извършваме аритметични действия върху символи:",
        "p6pc": "char a = 'a';\nchar b = 'b';\nint c = 'a' - 'b';\nprint(c);",
        "p7p": "Резултат:",
        "p8con": "<<prefix>>>>-1",
        "p9p": "Тук знаем, че според подреждането на символите, b е с едно по-голямо от a. Тоест ако извадим b от а, получаваме -1.",
        "p10p": "Можем също да присвояваме цели числа на char и да получим съответния им символ. Според повечето кодирания, ‚a‘ е числото 97. Тоест, можем да направим това:",
        "p11pc": "char aChar = 97;\nprint(aChar);",
        "p12p": "Резултат:",
        "p13con": "<<prefix>>>>a",
        "p14p": "Още повече – можем да използваме и операторите за манипулация с 1:",
        "p15pc": "char aChar = 97;\naChar++;\nprint(aChar);",
        "p16p": "Резултат:",
        "p17con": "<<prefix>>>>b",
        "p18tq": "Върху char можем да използваме:",
        "p18a1": "оператори за манипулация с 1",
        "p18a2": "събиране",
        "p18a3": "изваждане",
        "p18a4": "всички от гореизброените",
        "p19p": "Това беше char. Отвори твоето IDE, ако още не си го, и си поиграй с новите неща. Възможностите за тестване на неща са големи. Късмет!"
    },
    "l13": {
        "title": "Урок 13",
        "text": "където ще научиш как се запазва текст",
        "p1p": "Дойде време. В този урок ще се научиш да запазваш текст чрез типа string.",
        "p2p": "String, или низ на български, е последователност от символи. В началото на програмните езици, реално този тип не е съществувал както днес. Бил е представян чрез последователност от char (символи) в паметта. Оттам идва и името – низ от символи. Повечето днешни езици запазват всички низове с кодиране Уникод.",
        "p3p": "Низовете могат да извършват една главна операция, и тя е „конкатенация“ – слепяне на два низа. Прието че, когато се създаде един низ, неговите символи вече не могат да бъдат променяни – трябва да се създаде нов променен низ. Тази философия следват Java и C#.  От друга страна, индивидуални символи могат да се четат. Всеки символ в низ си има индекс. Първият символ отдясно наляво има индекс 0. Вторият има индекс 1 и така нататък. Например:",
        "p4p": "Чаши",
        "p5p": "Ч има индекс 0",
        "p6p": "А има индекс 1",
        "p7p": "Ш има индекс 2",
        "p8p": "И има индекс 3",
        "p9tq": "В низа „имена на крале“, на индекс 6 е символът:",
        "p9a1": "н",
        "p9a2": "празно пространство",
        "p9a3": "а",
        "p9a4": "к",
        "p10exp": "Обяснение: Отговорът е 'н'. Символ 0 е 'и'. Символ 1 е 'м'. Символ 2 е 'е'. Символ 3 е 'н'. Символ 4 е 'а'. Символ 5 е празно пространство. Символ 6 е 'н'.",
        "p11p": "Сега да видим кодови примери:",
        "p12ds1": "Java",
        "s13p": "String се създава чрез следния код:",
        "s14cj": "String zdravei = “здравей”;",
        "s15p": "Забележи, че String се пише с главна буква, за разлика от другите типове, които си изучавал досега. След това следва името на променливата, както обикновено. Самият низ винаги се записва между двойни кавички – противоположно на единичните на char. Така езикът различава единия от другия тип.",
        "s16p": "String може и да се принтира към конзолата:",
        "s17cj": "String zdravei = “здравей”;\nSystem.out.println(zdravei);",
        "s18p": "Резултат:",
        "s19con": "<<prefix>>>>здравей",
        "s20p": "Към String може да се добавя – конкатенация. Това става със знакът плюс. Може да се добавят низове, цели числа, нецели числа:",
        "s21cj": "String zdravei = “здравей”;\nString zdraveiIvan = zdravei + “Иван” + 5;\nSystem.out.println(zdraveiIvan);",
        "s22p": "Резултат:",
        "s23con": "<<prefix>>>>здравейИван5",
        "s24p": "Конкатенацията не прибавя празни пространства сама – това трябва да го свършим ние:",
        "s25cj": "String zdravei = “здравей”;\nString zdraveiIvan = zdravei + “ Иван”; // Отбележи мястото преди думата Иван в низа\nSystem.out.println(zdraveiIvan);",
        "s26p": "Резултат:",
        "s27con": "<<prefix>>>>здравей Иван",
        "s28p": "Можем да съберем два низа и на място (конкатенацията е вид експресия):",
        "s29cj": "System.out.println(“Здравей” + “ Георги”);",
        "s30p": "Резултат:",
        "s31con": "<<prefix>>>>Здравей Георги",
        "s32p": "Можем да използваме и съкратен оператор, който не сме ползвали досега. Вместо да пишем:",
        "s33cj": "String zdravei = “здравей”;\nzdravei = zdravei + “ Иван”; //zdravei ще има нова стойност „Здравей Иван“",
        "s34p": "Можем да напишем:",
        "s35cj": "String zdravei = “здравей”;\nzdravei += “ Иван”; // Забележи, че пишем „+=“. Това означава да добавим стойността, която даваме и пак ще има резултат „здравей Иван“. Действа и с другите оператори за аритметични операции, като -, *, /.",
        "s36p": "Можем да вземем символ от низ по следния начин:",
        "s37cj": "String zdravei = “здравей”;\nchar firstCharOfZdravei = zdravei.charAt(0);\nSystem.out.println(firstCharOfZdravei);",
        "s38p": "Резултат:",
        "s39con": "<<prefix>>>>з",
        "s40p": "Тук създаваме променлива от тип char с име firstCharOfZdravei (Първи символ от zdravei). Това е равно на zdravei (името на променливата ни) след това точка и charAt(). В скобите на charAt се записва индекса. Тук индекса е 0, което е „з“ от „здравей“ – първия символ. .charAt() се нарича метод, а в случая нулата е аргумент. System.out.println() се записва по подобен начин – тук .println() също е метод, а между скобите е аргумента. Другите типове, които сме учили досега нямат методи. В по-късен урок ще разгледаме всички методи на низовете и ще се научите как да създавате свои методи.",
        "s41p": "Вече можем да разберем и как действа System.out.println():",
        "s42cj": "String zdraveiIvan = “Здравей Иван”;\nString otgovor = “Здравей и ти”;\nSystem.out.println(zdraveiIvan);\nSystem.out.println(otgovor);",
        "s43p": "Резултат:",
        "s44con": "<<prefix>>>>Здравей Иван",
        "s45con": "<<prefix>>>>Здравей и ти",
        "s46p": "Е равносилно на конкатенация съм символа за нов ред – „\n“:",
        "s47cj": "String zdraveiIvan = “Здравей Иван”;\nString otgovor = “Здравей и ти”;\nSystem.out.print(zdraveiIvan + “\n”); // Забележи, че тук записваме само .print(), тоест очакваме Здравей ИванЗдравей и ти на един ред. Но заради добавянето на „\n“ получаваме нов ред.\nSystem.out.println(otgovor);",
        "s48p": "Резултат:",
        "s49con": "<<prefix>>>>Здравей Иван",
        "s50con": "<<prefix>>>>Здравей и ти",
        "s51ds2": "C#",
        "s52p": "string се създава чрез следния код:",
        "s53cc": "string zdravei = “здравей”;",
        "s54p": "Забележи, че string се пише с малка буква. След това следва името на променливата, както обикновено. Самият низ винаги се записва между двойни кавички – противоположно на единичните на char. Така езикът различава единия от другия тип.",
        "s55p": "String може и да се принтира към конзолата:",
        "s56cc": "string zdravei = “здравей”;\nConsole.WriteLine(zdravei);",
        "s57p": "Резултат:",
        "s58con": "<<prefix>>>>здравей",
        "s59p": "Към string може да се добавя – конкатенация. Това става със знакът плюс. Може да се добавят низове, цели числа, нецели числа:",
        "s60cc": "string zdravei = “здравей”;\nstring zdraveiIvan = zdravei + “Иван” + 5;\nConsole.WriteLine(zdraveiIvan);",
        "s61p": "Резултат:",
        "s62con": "<<prefix>>>>здравейИван5",
        "s63p": "Конкатенацията не прибавя празни пространства сама – това трябва да го свършим ние:",
        "s64cc": "string zdravei = “здравей”;\nstring zdraveiIvan = zdravei + “ Иван”; // Отбележи мястото преди думата Иван в низа\nConsole.WriteLine(zdraveiIvan);",
        "s65p": "Резултат:",
        "s66con": "<<prefix>>>>здравей Иван",
        "s67p": "Можем да съберем два низа и на място:",
        "s68cc": "Console.WriteLine(“Здравей” + “Георги”);",
        "s69p": "Резултат:",
        "s70con": "<<prefix>>>>Здравей Георги",
        "s71p": "Можем да използваме и съкратен оператор, който не сме ползвали досега. Вместо да пишем:",
        "s72cc": "string zdravei = “здравей”;\nzdravei = zdravei + “ Иван”; //zdravei ще има нова стойност „Здравей Иван“",
        "s73p": "Можем да напишем:",
        "s74cc": "string zdravei = “здравей”;\nzdravei += “ Иван”; // Забележи, че пишем „+=“. Това означава да добавим стойността, която даваме и пак ще има резултат „здравей Иван“. Действа и с другите оператори за аритметични операции, като -, *, /.",
        "s75p": "Можем да вземем символ от низ по следния начин:",
        "s76cc": "string zdravei = “здравей”;\nchar firstCharOfZdravei = zdravei[0];\nConsole.WriteLine(firstCharOfZdravei);",
        "s77p": "Резултат:",
        "s78con": "<<prefix>>>>з",
        "s79p": "Тук създаваме променлива от тип char с име firstCharOfZdravei (Първи символ от zdravei). Това е равно на zdravei (името на променливата ни) след това [] – оператора за достъп до индекс. В него се записва индекса. В по-късен момент той ще се завърне в нашите уроци.",
        "s80p": "Вече можем и да разберем как действа Console.WriteLine():",
        "s81cc": "string zdraveiIvan = “Здравей Иван”;\nstring otgovor = “Здравей и ти”;\nConsole.WriteLine(zdraveiIvan);\nConsole.WriteLine(otgovor);",
        "s82p": "Резултат:",
        "s83con": "<<prefix>>>>Здравей Иван",
        "s84con": "<<prefix>>>>Здравей и ти",
        "s85p": "Е равносилно на конкатенация съм символа за нов ред – „\n“:",
        "s86cc": "string zdraveiIvan = “Здравей Иван”;\nstring otgovor = “Здравей и ти”;\nConsole.Write(zdraveiIvan + “\n”); // Забележи, че тук записваме само .Write(), тоест очакваме Здравей ИванЗдравей и ти на един ред. Но заради добавянето на „\n“ получаваме нов ред.\nConsole.WriteLine(otgovor);",
        "s87p": "Резултат:",
        "s88con": "<<prefix>>>>Здравей Иван",
        "s89con": "<<prefix>>>>Здравей и ти",
        "p90p": "Независимо кой език използваш, най-вероятно ще ти се наложи да запишеш кавички в низ:",
        "p91pre": "\"думата \"здраве\" е съществително\"",
        "p92p": "Следният низ би дал грешка, защото се гледат първите кавички и директно следващите – програмен език би възприел това като низ „думата “, здраве извън който и да е низ и „ е съществително“ като още един низ.",
        "p93p": "За разрешаване на следния проблем се използва escape character („символ за бягство“) – „\\“. Пред кавичките, които са част от низа се записва „\\“, което сигнализира на езика, че те не трябва да се приемат като начало или край на нов низ:",
        "p94pre": "\"думата \\\"здраве\\\" е съществително\""
    },
    "l14": {
        "title": "Урок 14",
        "text": "където ще научиш общото между библиотеките и компютрите",
        "p1p": "В днешния урок ще обсъждаме библиотеки. Не, не тези в които ходиш да вземеш книги. Ще обсъждаме библиотеки в програмирането.",
        "p2p": "Преди много, много години всеки път, когато трябва да се създаде нещо, някой е сядал и го е пишел. Искаш случайно число? Напиши кода. Искаш да покажеш нещо на екрана? Напиши кода. Това е било изморително. Затова са се родили библиотеките. Библиотека в програмирането е съвкупност от код за извършване на някаква, обикновено обща цел. Библиотеката може да бъде написана от един човек и да се разпространи между стотици и милиони програмисти. Всеки може да я ползва, без дори да знае сам как действа кода вътре. В днешно време има библиотеки, за всички грозни и трудоемки неща, които програмистите не искат да правят сами – автентикация, криптиране, хаширане, графични интерфейси, четене на файлове. Схващаш. В някакъв момент се зараждат и стандартните библиотеки – почти всеки език има една. Стандартните библиотеки включват много неща, които е хубаво да има, но не е добра идея да се включват в езика – генератори на случайни числа, математически константи, четци на файлове. Например, в Java „System.out.println()“ всъщност е част от стандартната библиотека. В C# това е „Console.WriteLine()”. Библиотеките се импортират в кода.",
        "p3tq": "Библотеките в програмирането:",
        "p3a1": "не се импортират",
        "p3a2": "са съвкупности от код",
        "p3a3": "обикновено са случайно събрани и без обща цел",
        "p3a4": "съдържат книги",
        "p4p": "Да разгледаме как:",
        "p5ds1": "Java",
        "s6p": "В Java импортите на части от библиотеки се пишат горе – след package и преди class. Ползва се думата import. След това се пише пакетния път до частта от библиотеката, която искаме да импортираме. Така:",
        "s7cj": "package hello;\n\nimport java.util.Random;\n\npublic class Hello {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t}\n\n}",
        "s8p": "Виждаш, че тук пишем „import java.util.Random“ Спомняш ли си какво е пакет? Създаде един по-рано в тези уроци. Тук минаваме първо през пакета java, после пакета util. Накрая е класа Random – подобен на този, който създаде ти по-рано, за да пишеш кода и в него. Щом сме го импортирали, можем да използваме Random. Random всъщност е тип, подобно на String. Можем да създадем променлива от него. Това става по следния начин:",
        "s9cj": "Random rand = new Random();",
        "s10p": "Тук записваме типа Random. След това името на променливата – rand. След това създаваме променлива с new Random() – „нов случаен“. Вече имаме променливата rand. Как създаваме случайно число? Чрез rand.nextInt():",
        "s11cj": "int randomInt = rand.nextInt();",
        "s12p": "Това обаче ще създаде случаен int в цялата граница на стойностите на int – може да е 2, може да е 1 656 789. Ако искаме да лимитираме rand.nextInt(), пишем число в скобите. То е максимума, който може да бъде създаден този път.",
        "s13p": "Например:",
        "s14cj": "int randomInt = rand.nextInt(23); // тук числото винаги е по-малко от 23\nint randomInt2 = rand.nextInt(34); // А тук винаги е по-малко от 34",
        "s15p": "Има подобни методи и за другите типове – сам разгледай .nextDouble(), .nextFloat() и .nextLong().",
        "s16ds2": "C#",
        "s17p": "В C# импортите на части от библиотеки се пишат най-горе. Ползва се думата using. Може би вече си забелязал, че ти имаш един импорт горе – using System. Това ти позволява да използваш стандартната библиотека на C# - неща като Console.WriteLine(). След това се пише пътя до частта от библиотеката, която искаме да импортираме. Така:",
        "s18cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\t\n\t}\n}",
        "s19p": "Виждаш, че тук пишем „using System;“ Щом сме импортирали стандартната библиотека, можем да използваме Random. Random всъщност е тип, подобно на string. Можем да създадем променлива от него. Това става по следния начин:",
        "s20cc": "Random rand = new Random();",
        "s21p": "Тук записваме типа Random. След това името на променливата – rand. След това създаваме променлива с new Random() – „нов случаен“. Вече имаме променливата rand. Как създаваме случайно число? Чрез rand.Next():",
        "s22cc": "int randomInt = rand.Next();",
        "s23p": "Това обаче ще създаде случаен int в цялата граница на стойностите на int – може да е 2, може да е 1 656 789. Ако искаме да лимитираме rand.Next(), пишем число в скобите. То е максимума, който може да бъде създаден този път.",
        "s24p": "Например:",
        "s25cc": "int randomInt = rand.Next(23); // тук числото винаги е по-малко от 23\nint randomInt2 = rand.Next(34); // А тук винаги е по-малко от 34",
        "s26p": "Можем да лимитираме и долната стойност. Тогава пишем две различни числа в скобите, разделени от запетайки. Първото е минималната стойност, а второто – максималната:",
        "s27cc": "int randomInt = rand.Next(23, 46); // тук числото винаги е между 23 и 46",
        "s28p": "Има подобни методи и за другите типове – сам разгледай .NextDouble() и .NextBytes()",
        "p29rq": "Разучи Math библиотеката в твоя език – как се използва числото „пи“? Как се вдига на степен? Как се намира корен квадратен на число?"
    },
    "l15": {
        "title": "Урок 15",
        "text": "където ще научиш как се ползва конзолата… от другата страна",
        "p1p": "Досега само сме извеждали към конзолата. Днес ще се научиш да въвеждаш от конзолата към програмите си.",
        "p2p": "Накратко, въвеждането би действало така в нашия псевдокод:",
        "p3pc": "string in = input();\nprint(in);",
        "p4p": "Вход:",
        "p5con": "<<prefix>>>>Здравей!",
        "p6p": "Резултат:",
        "p7con": "<<prefix>>>>Здравей!",
        "p8p": "Тук програмата ще стигне до реда string in = input();, при което ще започне да чака вход от конзолата. Ти ще можеш да напишеш каквото си искаш в конзолата и след това ще натиснеш Enter (нов ред), което ще въведе символа за нов ред \n и това ще бъде прочетено. Когато това се случи, стойността, която си написал в конзолата ще се пренесе в програмата и променливата in ще стане равна на нея. Програмата ще продължи хода си, принтирайки in в конзолата.",
        "p9tq": "Какво става с програмата, когато стигне до input() в горния пример?:",
        "p9a1": "изключва се",
        "p9a2": "спира да отговаря",
        "p9a3": "паузира, докато чака вход",
        "p9a4": "продължава работата си",
        "p10p": "Да видим как става в Java и C#:",
        "p11ds1": "Java",
        "s12p": "В Java четенето на файлове става с типа Scanner, част от стандартната библиотека. Всъщност Scanner (скенер) чете всички файлове – в миналото (и в момента в много случаи) конзолата е просто файл, в който пишеш, така че е останало така.",
        "s13p": "Тъй като Scanner е част от стандартната библиотека, и не от самия език, първо трябва да го импортираме във файла. Това става с:",
        "s14cj": "import java.util.Scanner;",
        "s15p": "Не забравяй къде се поставят импортите – между package и class.",
        "s16p": "Споменах, че Scanner е тип. Подобно на Random. Спомняш ли си как създаде нов Random? Създай по същия начин променлива с тип Scanner и име sc или input (вход).",
        "s17p": "Кода ти трябва да изглежда така:",
        "s18cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner();\n\t}\n}",
        "s19p": "Ако пуснеш този код обаче, ще получиш грешка. Тя е, че трябва Scanner да получи аргумент. Има логика – трябва да знае кой файл да чете. Очаква аргумента между скобите. Тук бихме въвели низ с пътя до файл – абсолютен или относителен. Например:",
        "s20cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(„C:\\mnogovajenfile.txt“);\n\t}\n}",
        "s21p": "Това би дало грешка – спомняш ли си защо?",
        "s22p": "Да, заради \\. Тоест би било правилно така:",
        "s23cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(„C:/mnogovajenfile.txt“);\n\t}\n}",
        "s24p": "Но на нас ни трябва конзолата. А път до нея не знаем. За наша радост, някой е измислил нщо за този случай. Като аргумент няма да дадем път, а ще дадем System.in. Забележи, че принтираме на конзолата със System.out.println() (система.навън), а въвеждаме от нея със System.in (система.навътре). Това е конзолата. Крайният код изглежда така:",
        "s25cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t}\n}",
        "s26p": "Съответно вече имаме променливата input.  Тя се казва и обект и е с типа Scanner. Да въведем първия си низ чрез .nextLine()  - „следващ ред“:",
        "s27cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tString pozdrav = input.nextLine();\n\t\tSystem.out.println(pozdrav);\n\t}\n}",
        "s28p": "Вход:",
        "s29con": "<<prefix>>>>Здравей",
        "s30p": "Резултат:",
        "s31con": "<<prefix>>>>Здравей",
        "s32p": "Тук създаваме променлива pozdrav от тип низ, която е равна на input.nextLine(). Програмата чака да въведеш нещо в конзолата и да натиснеш Enter, след което продължава и принтира на конзолата поздрава, който си въвел.",
        "s33p": "Scanner също има и други методи. Например .nextInt(), .nextLong(), .nextByte() и така нататък. Разгледай ги сам. Аз само трябва да те предупредя за нещо.",
        "s34e": "При Scanner в Java има грешка / бъг. Ако първо поискаш цяло число (int) и след това String, ще получиш празен String.",
        "s35cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint inputInt = input.nextInt();\n\t\tString scannerBug = input.nextLine();\n\t}\n}",
        "s36p": "Вход:",
        "s37con": "<<prefix>>>>5",
        "s38con": "<<output>> //Програмата вече е спряла работата си тук",
        "s39p": "Какво се случва тук, е че input.nextInt() не взима символа \"\\n\" когато натиснеш Enter. Тоест, input.nextLine() взима този оставащ \"\\n\" и тъй като чака този символ, веднага спира да чете и ти връща празен низ. Това се поправя по следния начин:",
        "s40cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint inputInt = input.nextInt();\n\t\tinput.nextLine();\n\t\tString fixedScannerBug = input.nextLine();\n\t}\n}",
        "s41p": "Вход:",
        "s42con": "<<prefix>>>>5",
        "s43con": "<<prefix>>>>Здравей",
        "s44p": "Тук се взима цялото число. След това input.nextLine(); на следващия ред взима самотния „\n“ и тъй като празния низ не се дава на никоя променлива, изчезва в небитието. След това следващия input.nextLine() може спокойно да вземе каквото напишеш на следващия ред.",
        "s45ds2": "C#",
        "s46p": "В C# четенето от конзолата става подобно на принтирането на конзолата. Само че, вместо Console.WriteLine(), ползваме Console.ReadLine():",
        "s47cc": "using System; // Не забравяй, че ни трябва System, за да използваме Console\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tstring pozdrav = Console.ReadLine();\n\t\tConsole.WriteLine(pozdrav);\n\t}\n}",
        "s48p": "Тук създаваме променлива pozdrav от тип низ която е равна на Console.ReadLine(). Програмата чака да въведеш нещо в конзолата и да натиснеш Enter, след което продължава и принтира на конзолата поздрава, който си въвел.",
        "s49p": "Ако искаш да получиш нещо различно от низ, трябва да използваш по-различен метод – Convert. Той действа така:",
        "s50cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tint num = Convert.ToInt32(Console.ReadLine());\n\t\tConsole.WriteLine(num);\n\t}\n}",
        "s51p": "Convert.ToInt32() получава Console.ReadLine() като аргумент, следователно конвертира резултата към int32 или с други думи int с 32 бита – 4 байта – или нашия нормален int. Има също и Conver.ToInt64(), което е long и Convert.ToInt16(), което е 16 бита – 2 байта, или short. Има също и .ToDouble() и .ToChar().",
        "p52p": "Задача:",
        "p53rq": "Състави програма, която пита потребителя на колко години е от конзолата и взема неговия вход като цяло число. След това поискай името на потребителя като низ. Накрая принтирай информацията във формата \"Име, възраст\"."
    },
    "t2": {
        "title": "Тест 2",
        "text": "където ще провериш способността си да запазваш информация",
        "p1tqc": "Програмните езици:",
        "p1a": "са естествени",
        "p1a2": "са създадени от хората",
        "p2tqc": "Един от първите програмни езици е Python:",
        "p2a": "Да",
        "p2a2": "Не",
        "p3tqc": "Garbage collector осигурява липсата на:",
        "p3a1": "грешки в кода",
        "p3a2": "бъгове",
        "p3a3": "крашове",
        "p3a4": "течове на паметта",
        "p4tqc": "Интерпретацията се случва всеки път когато се стартира файл в интерпретиран език:",
        "p4a1": "Да",
        "p4a2": "Не",
        "p5tqc": "Компилацията:",
        "p5a1": "превръща един програмен език в друг",
        "p5a2": "поправя грешки",
        "p5a3": "се случва, когато се отвори файл с byte-code",
        "p5a4": "нито едно от посочените",
        "p6tqc": "int обикновено има големина от:",
        "p6a1": "4 байта",
        "p6a2": "2 байта",
        "p6a3": "1 байта",
        "p6a4": "8 байта",
        "p7tqc": "Как се запазва знака на short?",
        "p7a1": "Не се",
        "p7a2": "Като един от битовете",
        "p7a3": "Като един от байтовете",
        "p7a4": "Нито едно от посочените",
        "p8tqc": "Името long (дълъг) идва от факта, че:",
        "p8a1": "типът има големина от много битове",
        "p8a2": "името е дълго",
        "p8a3": "името е иронично",
        "p8a4": "нито едно от посочените",
        "p9tqc": "Беззнаковите (unsigned) типове могат да съдържат по-големи числа, защото:",
        "p9a1": "не се губи бит за запазване на знака",
        "p9a2": "не се губи бит за посока на числото",
        "p9a3": "няма беззнакови типове",
        "p9a4": "беззнаковите типове не се различават по големина от нормалните",
        "p10tqc": "Името на double (двойно) идва от:",
        "p10a1": "това, че може да съдържа два пъти по-големи числа от long",
        "p10a2": "има два пъти по-голяма големина от float",
        "p10a3": "има два пъти по-малка големина от float",
        "p10a4": "нито едно от посочените",
        "p11tqc": "Какво трябва да се постави след число, за да се индикира, че то е от тип float:",
        "p11a1": "f",
        "p11a2": "float",
        "p11a3": "a",
        "p11a4": "l",
        "p12pc": "int num = 10;\nint num1 = 12;\nint num2 = 13;\nint num3 = num++ - ++num1 + num2--;",
        "p13tqc": "След изпълнение на кода по-горе, num3 ще е равно на:",
        "p13a1": "9",
        "p13a2": "10",
        "p13a3": "11",
        "p13a4": "12",
        "p14tqc": "Ако x е двоично число, равно на 10100101, то тогава x >> 3 ще е равно на:",
        "p14a1": "00010100",
        "p14a2": "00101000",
        "p14a3": "01010010",
        "p14a4": "00101001",
        "p15tqc": "Можеш да събираш променливи от тип char с променливи от тип int.",
        "p15a1": "Твърдението е вярно",
        "p15a2": "Твърдението е невярно",
        "p16tqc": "Символът на идекс 5 в низа „низове“ е:",
        "p16a1": "о",
        "p16a2": "в",
        "p16a3": "е",
        "p16a4": "з",
        "p17tqc": "Низовете могат да се конкатенират с цели числа:",
        "p17a1": "Твърдението е вярно",
        "p17a2": "Твърдението е невярно",
        "p18tqc": "Библиотеките в програмирането:",
        "p18a1": "съдържат код, който обикновено има обща цел",
        "p18a2": "съдържат код, който обикновено няма обща цел",
        "p18a3": "са стандартни",
        "p18a4": "винаги идват с програмния език",
        "p19tqc": "В Java и C# уравнението (6*5-4*20) / 5 е равно на:",
        "p19a1": "-10",
        "p19a2": "-16",
        "p19a3": "10",
        "p19a4": "5",
        "p20fqc": "Опитай да си обобщиш какво научи в предния раздел в няколко изречения."
    },
    "l16": {
        "title": "Урок 16",
        "text": "където ще научиш как се сравнява",
        "p1p": "В програмирането идва един момент, в който трябва да сравниш нещо. Независимо дали е две числа или два символа. В този урок ще се научиш да правиш именно това.",
        "p2p": "Първо виж следното твърдение:",
        "p3p": "„Аз не излъгах“",
        "p4p": "Какво може да е това твърдение? Какви могат да бъдат твърденията?",
        "p5p": "Ако си отговорил „верни и грешни“, ти си прав. Това са двете състояния на всяко едно твърдение.",
        "p6p": "Когато пишем код, действаме по същия начин. Ние представяме твърдение, а компютъра ни казва дали е вярно или грешно. Пишем твърдението 5 < 6 и компютъра ни казва „Това е вярно“. Пишем 7 > 8 и компютъра ни казва „Това е грешно“. Това е най-важното, което трябва да разбереш в този урок.",
        "p7p": "В началото, вярно и грешно се е представяло от числата 1 и 0 – 1 значи вярно, а 0 значи грешно. Има логика. В някакъв момент, някой е решил да измисли нещо малко по-четимо и сме стигнали до днешните „true“ (правилно – англ.) и „false“ (грешно – англ.), налични в почти всеки език, който съм срещал и който ти най-вероятно ще срещнеш. Забавно е всъщност, че в някои езици границата между 1 и „true“ и 0 и „false“ е толкова малка, че нещо от този род работи:",
        "p8pc": "int num = (false + true + true)  * true;",
        "p9p": "Което приключва с num равно на 2.",
        "p10p": "Ние обаче не се интересуваме от тези езици. Интересуваме се от Java и C#.",
        "p11p": "Подобно на всичко друго, и „true“ и „false“ имат специален тип променлива за себе си. Нарича се boolean („буулиан“) или на български – булев. Типът е кръстен на един английски математик на име Джордж Бул.",
        "p12p": "Булевите типове се побират в един байт – нямат и нужда от повече (най-вероятно ще попиташ защо не е 1 бит, отговора е че повечето процесори не могат да използват нещо по-малко от 1 байт). В крайна сметка, имат точно две възможни стойности.",
        "p13p": "Да видим как се декларират в различните езици:",
        "p14ds1": "Java",
        "s15cj": "package tutorial;\n\npublic class Booleans {\n\t\n\tpublic static void main(String[] args) {\n\t\tboolean b = true;\n\t\tboolean b1 = false;\n\t}\n}",
        "s16p": "Забележи, че името в Java се изписва напълно – boolean. В нашия псевдокод ще използвам bool, съкращението използвано и в C#, защото е по-кратко. То обаче не съществува в Java.",
        "s17ds2": "C#",
        "s18cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tbool b = true;\n\t\tbool b1 = false;\n\t}\n}",
        "p19p": "Това е създаването на такава променлива. Но в момента, тя не ни е много полезна. Защо ни е да знаем дали нещо е вярно или грешно, ако така или иначе го преценяваме ние?!",
        "p20p": "Затова сега ще те науча на сравняваш. Ще използвам нашия псевдокод.",
        "p21h": ">, <",
        "p22p": "Първите оператори за сравняване са по-голямо и по-малко. Знаеш ги, надявам се. Така действат те:",
        "p23pc": "bool sravnenie = 5 < 7;\nprint(bool);",
        "p24p": "Резултат:",
        "p25con": "<<prefix>>>>true",
        "p26p": "Това е. Създаваме променливата и я присвояваме на твърдение. Компютърът преценява дали твърдението е правилно и дава стойност true или false. Можем да сравняваме и на място:",
        "p27pc": "print(5 > 7);",
        "p28p": "Резултат:",
        "p29con": "<<prefix>>>>false",
        "p30p": "Тук очевидно 5 не е по-голямо от 7.",
        "p31p": "Можем да сравняваме и променливи:",
        "p32pc": "int num = 1;\nint num2 = 2;\nprint(num < num2);",
        "p33p": "Резултат:",
        "p34con": "<<prefix>>>>true",
        "p35p": "… и понякога даже ако не са от един тип:",
        "p36pc": "print(5f < 6.7);",
        "p37p": "Резултат:",
        "p38con": "<<prefix>>>>true",
        "p39h": "==, !=",
        "p40p": "Хората много често сравняват две числа, за да видят дали са равни. И обикновено, това се прави с „=“. Но има лек проблем – ние вече използваме „=“ за присвояване. Как се очаква компилатора да знае дали сравняваме променливата num с 5 или се опитваме да присвоим 5 на num?",
        "p41pc": "int num = 6;\nbool b = num = 5; // Можеш да видиш как това е объркващо и колко грешки може да причини",
        "p42p": "Вместо това, използваме „==“. Така и програмистът, и компилаторът занаят какво имаме предвид:",
        "p43pc": "int num = 6;\nbool b = num == 5;\nprint(b);",
        "p44p": "Резултат:",
        "p45con": "<<prefix>>>>false",
        "p46p": "6 не е равно на 5.",
        "p47p": "Идва и друг проблем. Понякога искаме да проверим дали две числа не са равни, а не дали са равни. В математиката, това се представя със символ равно с черта преминаваща през него – „зачеркваща равенството“, един вид. Но тук нито можем да ползваме равно, нито можем да го зачеркваме. Затова някой е измислил „!=“ и всички са приели, че изглежда достатъчно близко до истинското нещо. И го ползваме до днес.",
        "p48pc": "int num = 6;\nbool b = num != 5;\nprint(b);",
        "p49p": "Резултат:",
        "p50con": "<<prefix>>>>true",
        "p51p": "Тук num не е равно на 5, значи твърдението е вярно. b е true.",
        "p52p": "В някакъв момент, всички са приели, че „!“ ще обръща значението на boolean.",
        "p53p": "Така че можем да правим такива неща:",
        "p54pc": "bool b = !(5<6); // 5 е по-малко от 6, значи в скобите става true. ! обръща стойността, и b става false.\nprint(b);",
        "p55p": "Резултат:",
        "p56con": "<<prefix>>>>false",
        "p57h": ">=, <=",
        "p58p": "Друго нещо, на което трябва да наблегна е, че 6 не по-малко от 6. Тоест 6 < 6 не е true. Не е true и 6 > 6. Когато обаче искаме да използваме двете условия, използваме >= и <=. Това е съответно по-голямо или равно и по-малко или равно. Тоест, 6 >= 6 е вярно. Също е вярно и 6 >= 3. Оставям на теб да тестваш това. И запомни, равното е винаги отдясно спрямо знака.",
        "p59w": "В Java String не трябва да се сравнява с „==“. В този случай, това проверява дали адресите на двете променливи в хийпа са еднакви. Това не е гарантирано вярно във всички версии на Java, дори низовете да са равни. Вместо това, използвай .equals(вториНиз) (равна е на). Това важи и за други обекти от специални типове като Random и Scanner (въпреки, че най-вероятно никога няма да ти се наложи да сравняваш тези):",
        "p60cj": "String test = “hello”;\nString test1 = “hello”;\nSystem.out.println(test == test1);",
        "p61p": "Резултат:",
        "p62con": "<<prefix>>>>false или true",
        "p63p": "Въпреки, че тук низовете са очевидно равни, има висок шанс на много версии на Java резултатът да е false. Вместо това, използвай това:",
        "p64cj": "String test = “hello”;\nString test1 = “hello”;\nSystem.out.println(test.equals(test1));",
        "p65p": "Резултат:",
        "p66con": "<<prefix>>>>true",
        "p67p": "Тук използваме .equals() и знаем, че резултатът винаги е реален.",
        "p68p": "Може би си забелязал, че в този урок не съм задал нито един въпрос. Това е, защото сега ще получиш първата си истинска задача!",
        "p69rq": "Състави програма, в която въвеждаш две числа от конзолата. Ако първото е по-голямо, изведи true към конзолата, иначе изведи false."
    },
    "l17": {
        "title": "Урок 17",
        "text": "където ще научиш как се сравнява… няколко пъти на веднъж",
        "p1p": "Първото, което ще разгледаме днес са логическите оператори. По-точно „логическото и“ и „логическото или“. Може да си спомняш, че веднъж сме споменавали тези имена – в урока за аритметични действия. Тогава обаче беше относно числа. Тук е относно булеви променливи.",
        "p2p": "„Логическо и“ е оператора „&&“. Той се поставя между две твърдения и стига дп резултат true, ако и двете са верни. Иначе резултатът е false. Това са случаите:",
        "p3pre": "true && true = true",
        "p4pre": "true && false = false",
        "p5pre": "false && true = false",
        "p6pre": "false && false = false",
        "p7p": "В код се използва, където може да се прави и всяко друго сравнение:",
        "p8pc": "bool b = 5 < 7 && 6 < 7;\nprint(b);",
        "p9p": "Резултат:",
        "p10con": "<<prefix>>>>true",
        "p11p": "Това е вярно, защото и 5<7 и 6<7 е вярно. Ако обаче направим:",
        "p12pc": "print(5 < 7 && 7 < 7);",
        "p13p": "Резултат:",
        "p14con": "<<prefix>>>>false",
        "p15p": "Резултатът е false, защото 5 е по-малко от 7, но 7 не е по-малко от 7. Тоест имаме 1 грешно, тоест целия резултат става грешен.",
        "p16p": "„Логическо или“ е този оператор – „||“. Той се поставя между две твърдения и изкарва резултат true, ако има поне едно вярно твърдение. Иначе резултата е false. Това са случаите:",
        "p17pre": "true && true = true",
        "p18pre": "true && false = true",
        "p19pre": "false && true = true",
        "p20pre": "false && false = false",
        "p21p": "В код се използва, където може да се прави и всяко друго сравнение:",
        "p22pc": "bool b = 5 < 7 || 7 < 7;\nprint(b);",
        "p23p": "Резултат:",
        "p24con": "<<prefix>>>>true",
        "p25p": "Това е вярно, защото и 5<7 е вярно, тоест за „логическото или“ няма значение, че 7 не епо-малко от 7. Има 1 вярно, тоест целия резултат е верен. Ако обаче направим:",
        "p26pc": "print(7 < 7 && 8 < 7);",
        "p27p": "Резултат:",
        "p28con": "<<prefix>>>>false",
        "p29p": "Резултатът е false, защото 7 не е по-малко от 7 и 8 не е по-малко от 7. Тоест всички твърдения са грешни, тоест целия резултат става грешен.",
        "p30tq": "true или false е твърдението \"(6 < 8 || 9 < 0) && 6 + 1 != 7\"?",
        "p30a1": "true",
        "p30a2": "false",
        "p30exp": "Обяснение: Първо гледаме скобите. 6 е по-малко от 8, тоест вярно. 9 обаче не е по-малко от. Въпреки това, между двете твърдения има логическо или, тоест целият резултат в скобите е true. След това имаме твърдението, че 6 + 1 не е равно на 7, което е грешно. Операторът е логическо и. От едната страна имаме true от скобите, от другата имаме false, тоест резултатът е false.",
        "p32h": "Ternary",
        "p33p": "Този тип изрази очевидно няма превод на български – попаднах на най-различни от най-различни източници. Затова просто ще го наричам с английското произношение – тернари.",
        "p34p": "За да разбереш как действа тернари, ще направим заедно една задача. Тя е следната:",
        "p35rq": "Въведи 2 числа от конзолата. Изведи на конзолата по-голямото.",
        "p36p": "Аз ще я напиша тук в псевдокод. Ти я напиши в избрания си език, като един вид предизвикателство.",
        "p37p": "Първо взимаме две числа от конзолата:",
        "p38pc": "int num = input();\nint num1 = input();",
        "p39p": "Въпросът е: Как да запаметим по-голямото число? Тук идва на помощ тернари:",
        "p40pc": "int bigger = (num > num1)? num: num1;",
        "p41p": "Опитай се да разбереш какво прави тернари без да ти го обяснявам.",
        "p42p": "Разбра ли?",
        "p43p": "Първо имаме променлива. Тя се казва bigger, от по-голям. Тя е с тип int. Тя е равна на тернарито.",
        "p44p": "В тернарито първо имаме твърдение в скоби – тук е условие. Виждаш ли го?",
        "p45pc": "(num > num1)",
        "p46p": "След това имаме „?“. Това значи, че условието е приключило.",
        "p47p": "След това идва важната част – стойността на тернарито, ако условието е вярно – num. След това има отделение чрез „:“. След него стойността, ако условието е грешно – num1. Стойността на тернарито ще стане и стойност на bigger. Да изразим това в думи:",
        "p48p": "Ако първото число е по-голямо от второто число, bigger ще стане равно на първото число. Иначе, ако първото число е по-малко от или равно на второто число, bigger ще стане равно на второто число.",
        "p49p": "Разбра ли вече?",
        "p50p": "Значи, във всеки случай bigger ще е по-голямото число. Можем само да го изведем:",
        "p51pc": "print(bigger);",
        "p52p": "Цялата задача става:",
        "p53pc": "int num = input();\nint num1 = input();\nint bigger = (num > num1)? num: num1;\nprint(bigger);",
        "p54p": "Написа ли тази програма в твоя език?",
        "p55rq": "За край на този урок ще ти дам една друга задача. Представи си, че ти си професор в университет. Дал си изпит на студентите с максимални 100 точки. Искаш да направиш програма, в която въвеждаш точките на ученик. След това програмата извежда оценката на ученика – тя се смята по формулата (точки*6)/100 (знам, може би доста щадяща за университет). Накрая, ако ученикът има оценка над или равна на 3, да се извежда на конзолата „Ученикът минава“. Иначе да се извежда „Ученикът не минава“.",
        "p56p": "Късмет!"
    },
    "l18": {
        "title": "Урок 18",
        "text": "където ще научиш как се контролира програма",
        "p1p": "В предния урок научи за булевия тип и за тернарито. В този урок ще учиш за по-големия (и по-полезен) брат на второто.",
        "p2p": "Първо искам да ти кажа, че подобно и на други неща, булевите типове имат конвенция за именуване. Прието е името да се изписва в този формат: „isClicked“. Буквален български превод – е натиснато. Не го споменах досега нарочно, и в остатъка на този урок ще разбереш защо.",
        "p3p": "if. else. Това са двете най-важни думи за този урок – „ако“ и „иначе“. Така се проверява нещо в код. Например, ако бутона е натиснат, изпълни един код. Ако дадено твърдение е вярно, изпълни код. Иначе изпълни друг. Да видим примера:",
        "p4ds1": "Java",
        "s5cj": "package tutorial;\n\npublic class Ifs {\n\t\n\tpublic static void main(String[] args) {\n\t\tint num = -2;\n\t\tif (num > 0) {\n\t\t\tSystem.out.println(\"Числото е позитивно\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Числото е негативно или нула\");\n\t\t}\n\t}\n}",
        "s6ds2": "C#",
        "s7cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tint num = -2;\n\t\tif (num > 0) \n\t\t{\n\t\t\tConsole.WriteLine(\"Числото е позитивно\");\n\t\t}\n\t\telse \n\t\t{\n\t\t\tConsole.WriteLine(\"Числото е негативно или нула\");\n\t\t}\n\t}\n}",
        "p8p": "Тук числото е -2. Когато се стигне до if, имаме скоби. Там е твърдението – в този случай условие. Ако то е правилно, изпълняваме първия блок кода и продължаваме напред, пропускайки втория. Резултата в конзолата е „Числото е позитивно“. Ако пък не е вярно, както в нашия случай, пропускайки първия блок код, отиваме директно във втория, който е след else. Резултата към конзолата е „Числото е негативно или нула“.",
        "p9p": "Блоковете код могат да използват променливи, които вече са декларирани над тях; ако създадете променлива в if или else блока, няма да можете да я ползвате надолу, тъй като е възможно тя никога да не се създаде. Например така:",
        "p10w": "Tук ще пиша в псевдокода. Ще започвам нов блок код с “{” на същия ред. Ако използваш C#, не забравяй, че ти трябва да ги поставяш на следващия ред.",
        "p11pc": "int inp = input();\nif (inp >= 0) {\n\tprint(“Валидни точки”).\n\tint result = inp * 50;\n}\n// Както е показано тук, може да има if и без else – това няма значение.\nprint(result);",
        "p12p": "Тук има грешка – възможно е числото in да е било по-малко от 0. Тогава if блока е бил пропуснат и променливата result никога не е била създадена. Така че не може да се принтира. Всеки език би показал грешка за това.",
        "p13p": "Блоковете от код след if и else, стига да са един ред, могат да се записват и без {}. Само трябва да са на правилно разстояние от началото на реда. Това е удобно в някои случай, но лично аз не го използвам често:",
        "p14pc": "int num = 5;\nbool isEven = num % 2 == 0;\nif (isEven)\n\tprint(“Четно”);\nelse print(“Нечетно”); // Може даже и на същия ред",
        "p15p": "Тук създаваме променливата num. След това имаме булевата променлива isEven – „е четно“. Тя е равна на num % 2 == 0. Това е проверката за четно число – % е деление с остатък, както знаеш. Ако числото е четно и го разделиш на 2, остатъка винаги ще е нула – 46 % 2 = 0; Ако искаш да направиш проверка за нечетно, можеш да използваш num % 2 == 1 или if (!isEven) (да обърнеш стойността на isEven чрез „!“). После идва и причината за подобното именуване на булевите променливи – получава се почти валидно английско изречение – if (isEven)… else… – Ако е четно… иначе…. Това го прави по-лесно за четене. След това имаме първия ред, който няма нужда от блок и само е на нов ред. След него е „else“, разстояние и кода.",
        "p16p": "Последното нещо, което трябва да ти обясня през този урок е else if – но изглежда вече съм си свършил половината работа. Да се върнем на първия пример. Там имаме един общ случай, ако числото е негативно и равно на нула. Това може да поправим чрез else if.  Това е просто долепен if до else на друг if, записан на същия ред – като в примера горе:",
        "p17pc": "int num = 0;\nif (num > 0) {\n\tprint(\"Числото е позитивно\");\n}\nelse if (num < 0) {\n\tprint(\"Числото е негативно\");\n}\n// Това е същото като да напиша:\n// else {\n// \tif() {}\n// }\nelse {\n\tprint(\"Числото е 0\");\n}",
        "p18p": "Резултат:",
        "p19con": "<<prefix>>>>Числото е 0",
        "p20p": "Първата проверка е дали числото е по-голямо от 0. То не е, значи пропускаме този блок. Отиваме на втората проверка – else if. Числото не е и по-малко от 0, значи пропускаме и този блок. Стигаме до else, който принтира „Числото е 0“ към конзолата.",
        "p21p": "Както забеляза, и в този урок нямаше въпроси, и може би вече предполагаш, че ще ти дам задача. Прав си:",
        "p22rq": "Приеми цяло число x от конзолата. Ако е по-голямо от 60, изведи ново число по-формулата x*60 – 10. Ако е равно на 60 или по-голямо от 20, изведи ново число по формулата x*20  - 5. Ако не влиза в нито едно от тези условия, изведи ново число по формулата x*(-1) + 10."
    },
    "l19": {
        "title": "Урок 19",
        "text": "където ще научиш как да пишеш проверки",
        "p1p": "В този урок главно трябва да ти кажа за вложените if-ове. Защо? Има го в учебната програма.",
        "p2p": "Както може би предполагаш, в блока код на един if можеш да сложиш още if-ове. Ще го демонстрираме със следната задача:",
        "p3rq": "Създай низ „Числото“. Ако дадено число е четно на 3, добави към низа „ е четно на 3“. Ако е четно и на 5, добави към низа „ и 5“. Накрая изведи низа към конзолата.",
        "p4p": "Опитай да решиш задачата сам преди да разгледаш кода. Лесно е. Не забравяй, че ако число се дели без остатък на друго число, то то е четно на него.",
        "p5ds1": "Java",
        "s6cj": "package tutorial;\n\npublic class Ifs {\n\t\n\tpublic static void main(String[] args) {\n\t\tString result = \"Числото\";\n\t\tint num = 15;\n\t\tif (num % 3 == 0) {\n\t\t\tresult += \" е четно на 3\";\n\t\t\t\n\t\t\tif (num % 5 == 0) {\n\t\t\t\tresult += \" и 5\";\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}",
        "s7ds2": "C#",
        "s8cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tstring result = \"Числото\";\n\t\tint num = 15;\n\t\tif (num % 3 == 0) {\n\t\t\tresult += \" е четно на 3\";\n\t\t}\n\t\tif (num % 5 == 0) {\n\t\t\tresult += \" и 5\";\n\t\t}\n\t\tConsole.WriteLine(result);\n\t}\n}",
        "p9p": "Опитай се да обясниш този код по начина, по който аз правя обикновено. Прочети го на глас и се опитай да го разбереш. Поиграй си с него, промени условието, ако искаш.",
        "p10p": "Сега ще решиш и друга задача. Тя е класика. Трябва да приемеш брой точки от конзолата. Ако са над или равни на 90, принтирай „отличен“ към конзолата. Ако са под 90 и над или равни на 80, принтирай „Много добър“. Под 80 и над или равни на 70 – „Добър“. Под 70 и над или равни на 60 – „Среден“. За всичко под 60, принтирай „Слаб“.",
        "p11rq": "Какво е уникалното на тази задача? Нима не се решава с много if else? Да, решава се. Но ти няма да я решиш така. Тази задача искам да решиш със „switch“. И аз няма да съм този, който ще ти го обясни. Потърси го в Интернет. Използвай преводач, ако се налага, за да гледаш източници на английски, разгледай сайтове. Задачата ти този урок е да търсиш, а не да решаваш. Тъй като аз не мога да ти обясня всичко – и ако искаш да програмираш, ще търсиш още много време. Съвет от мен – по-бързо е да прочетеш статия в уебсайт, отколкото да гледаш видео.",
        "p12p": "Късмет!"
    },
    "t3": {
        "title": "Тест 3",
        "text": "където ще провериш способността си да контролираш кода",
        "p1tqc": "Типът boolean има:",
        "p1a1": "1 възможна стойност",
        "p1a2": "2 възможни стойности",
        "p1a3": "3 възможни стойности",
        "p1a4": "4 възможни стойности",
        "p2tqc": "Твърдението 5 != 6 е:",
        "p2a1": "true",
        "p2a2": "false",
        "p3tqc": "Твърдението 7 <= 7 е:",
        "p3a1": "true",
        "p3a2": "false",
        "p4tqc": "Твърдението !(56 == 7 || 8 < 9) && 7 > 6 e:",
        "p4a1": "true",
        "p4a2": "false",
        "p5pc": "int result = (5 < 6)? 7: 8;",
        "p6tqc": "След изпълнение на по-горния код, променливата result ще е равна на:",
        "p6a1": "7",
        "p6a2": "8",
        "p6a3": "5",
        "p6a4": "6",
        "p7pc": "int num = 7;\nfloat num1 = 7.6f;\nstring result = “”;\nif (num == num1) {\n\tresult = “Равни”;\n}\nelse if (num < num1) {\nresult = “Първото е по-малко”;\n}\nelse {\n\tresult = “Второто е по-малко”;\n}",
        "p8tqc": "След изпълнение на по-горния код, променливата result ще е равна на:",
        "p8a1": "Равни",
        "p8a2": "Първото е по-малко",
        "p8a3": "Второто е по-малко",
        "p8a4": "Нито едно от посочените",
        "p9pc": "int num = 5;\nswitch (num) {\ncase 1:\n\tprint(num * 65 - 1);\n\tbreak;\ncase 2:\n\tprint(num * 78 - 3);\n\tbreak;\ncase 15:\n\tprint(num * 32 - 4);\n\tbreak;\ndefault:\n\tprint(num);\n\tbreak;\n}",
        "p10tqc": "След изпълнение на по-горния код, резултатът на конзолата ще бъде:",
        "p10a1": "324",
        "p10a2": "387",
        "p10a3": "156",
        "p10a4": "5",
        "p11h": "Задачи",
        "p12p": "Следващите 2 въпроса са задачи, които трябва да направиш сам.",
        "p13rq": "Създай конзолна програма, с която потребители да влизат в организация. Когато потребителят стартира програмата, трябва в конзолата да бъде попитан да напише името си, възрастта си и четно число. Когато потребителят въведе тази информация, провери три неща – дали името му е с дължина над 0 символа (разучи как се взима дължина на низ), дали възрастта му е над 0 години и дали числото, което е въвел е четно. Ако и трите условия са изпълнени, изведи на конзолата „Добре дошъл, <името, което е въвел потребителя>“. Иначе изведи „Грешна информация“. Късмет!",
        "p14rq": "Опитай се да направиш предната задача, но този път приеми две различни имена (първо и фамилно), пол вместо възраст, като полът се въвежда чрез String и случайно трицифрено число (трябва да провериш дали числото е трицифрено).",
        "p15fqc": "Опитай да си обобщиш какво научи в предния раздел в няколко изречения."
    },
    "l20": {
        "title": "Урок 20",
        "text": "където ще научиш з програмите не се затварят веднага",
        "p1p": "Време е да се върнем назад във времето. Към далечните времена на Assembly езика. Освен многото си други проблеми, той не е можел да повтори едно действие няколко пъти. Всичко, с което са разполагали програмистите е било проверки и goto. goto е една доста архаична команда, защото може да въздейства на стака по неочаквани начини. Когато се стигне го команда goto, изпълнението на кода отива на дадения ред. В този урок ще използвам нашия си псевдокод с командата goto, защото Assembly не е предназначен за обучителни програми. Ако се интересуваш допълнително, можеш да погледнеш как изглежда в интернет.",
        "p2pc": "int num = 5;\ngoto 1;",
        "p3p": "Това накратко е най-простия възможен пример за goto. Програмата започва от ред 1, създава променлива със стойност 5, стига до goto 1; и се връща на първия ред. Това е циклично действие – повтаря се много пъти. Такъв код са наричали цикли. Името „цикъл“ си е останало и до днес, въпреки че (по добри причини) goto е несъществуваща команда в повечето езици и в днешно време използваме по-цивилизовани методи. Въпреки това, ще останем в миналото за още един пример.",
        "p4p": "Цикълът горе е с един голям проблем – той никога няма да спре. Той ще продължи да работи до изключване на програмата. Това не е лошо – реално е начина, по който държим всяка програма жива – независимо дали е браузърът ти или любимата ти игра, някъде във въпросната програма има подобен цикъл, който държи всичко работещо.",
        "p5p": "Проблемът със спирането е бил решен по-много лесен начин:",
        "p6pc": "int num = 0;\nnum++;\nif (num < 10) {\n\tgoto 2;\n}",
        "p7p": "Горе, първо създаваме променливата num. След това добавяме едно към нея. Ако num е по-малка от 10, то се връщаме на ред 2 и добавяме още едно. Това ще продължи, докато числото е 10. Тогава условието num < 10 няма да се изпълни и програмата ще продължи, излизайки от цикъла.",
        "p8p": "Да се върнем в настоящето. За горния код бихме използвали while() {} („докато“). Ето го и него - точно преведен, със същия резултат:",
        "p9ds1": "Java",
        "s10cj": "int num = 0;\nwhile (num < 10) {\n\tnum++;\n}",
        "s11ds2": "C#",
        "s12cc": "int num = 0;\nwhile (num < 10) \n{\n\tnum++;\n}",
        "p13p": "Надявам се да си имал „Еврика“ момент, когато си видял кода отгоре. Ако не си, явно е мой ред да ти обясня. Както по-горе, създаваме променлива num. Тя е равна на 0. След това имаме while и условие. Докато това условие е изпълнено, кода в блока ще продължи да се изпълнява. Тоест, ако спираме кода, всеки път когато направи стъпка, ще имаме нещо от този род:",
        "p14p": "num, 0 е по-малко от 10. Продължи цикъла.",
        "p15p": "num++;",
        "p16p": "num, 1 е по-малко от 10. Продължи цикъла.",
        "p17p": "num++;",
        "p18p": "num, 2 е по-малко от 10. Продължи цикъла.",
        "p19p": "num++;",
        "p20p": "…",
        "p21p": "num, 10, не е по-малко от 10. Прекъсни цикъла.",
        "p22p": "И кодът си продължава.",
        "p23p": "Но може би забелязваш лек проблем – в goto кода, първо добавяме едно към num и след това започва цикълът. А тук, започваме добавянето едва след като проверим условието първия път. За този проблем има решение – do {} while();",
        "p24p": "Да видим кода:",
        "p25ds1": "Java",
        "s26cj": "int num = 0;\ndo {\n\tnum++;\n} while (num < 10);",
        "s27ds2": "C#",
        "s28cc": "int num = 0;\ndo \n{\n\tnum++;\n} while (num < 10);",
        "p29p": "Разликата е, че кодът в do блока ще се изпълни поне веднъж преди проверката на условието. Тоест, програмата е нещо такова:",
        "p30p": "num++;",
        "p31p": "num, 1 е по-малко от 10. Продължи цикъла.",
        "p32p": "num++;",
        "p33p": "num, 2 е по-малко от 10. Продължи цикъла.",
        "p34p": "num++;",
        "p35p": "num, 3 е по-малко от 10. Продължи цикъла.",
        "p36p": "num++;",
        "p37p": "…",
        "p38p": "num, 10 не е по-малко от 10. Прекъсни цикъла.",
        "p39p": "За горната задача има и различен подход – чрез безкраен цикъл и break;. break може да се използва в цикли, и ако кодът го достигне, той приключва цикъла. Сам обясни как е направен безкрайния цикъл:",
        "p40ds1": "Java",
        "s41cj": "int num = 0;\nwhile (true) {\n\tnum++;\n\tif (num < 10) {\n\t\tbreak;\n\t}\n}",
        "s42ds2": "C#",
        "s43cc": "int num = 0;\nwhile (true) \n{\n\tnum++;\n\tif (num < 10) \n\t{\n\t\tbreak;\n\t}\n}",
        "p44p": "Тук имаме безкраен цикъл – while (true). В него към променливата num добавяме 1. Ако е по-малка от 10, изпускаме блока код в if и продължаваме. Ако не е, достигаме break;, което прекъсва цикъла while. Продължаваме програмата.",
        "p45rq": "Създай програма, която приема число от конзолата. След това провери дали се дели на всяко число до 100 без остатък, използвайки цикъл. Ако се дели на дадено число без остатък, тоест му е кратно, изведи числото на конзолата."
    },
    "l21": {
        "title": "Урок 21",
        "text": "където ще научиш как се брои"
    },
    "t4": {
        "title": "Тест 4",
        "text": "където ще провериш способността си да повтаряш"
    },
    "l22": {
        "title": "Урок 22",
        "text": "където ще научиш как да работиш с много информация"
    },
    "l23": {
        "title": "Урок 23",
        "text": "където ще разбереш връзката между последните уроци"
    },
    "l24": {
        "title": "Урок 24",
        "text": "където ще научиш как да сортираш… и как да не го правиш"
    },
    "l25": {
        "title": "Урок 25",
        "text": "където ще научиш че измеренията са повече от едно"
    },
    "t5": {
        "title": "Тест 5",
        "text": "където ще провериш способността си да работиш с много информация"
    },
    "l26": {
        "title": "Урок 26",
        "text": "където ще научиш как да организираш програмата си"
    },
    "l27": {
        "title": "Урок 27",
        "text": "където ще научиш как да не се повтаряш"
    },
    "l28": {
        "title": "Урок 28",
        "text": "където ще научиш че методите са навсякъде"
    },
    "t6": {
        "title": "Тест 6",
        "text": "където ще провериш колко си организиран"
    },
    "l29": {
        "title": "Урок 29",
        "text": "където ще научиш защо името е софтуерно инженерство"
    },
    "l30": {
        "title": "Урок 30",
        "text": "където ще научиш кaк да контролираш достъпа"
    },
    "l31": {
        "title": "Урок 31",
        "text": "където ще научиш, че има и непроменливи"
    },
    "l32": {
        "title": "Урок 32",
        "text": "където ще научиш какво е наследството"
    },
    "l33": {
        "title": "Урок 33",
        "text": "където ще научиш, че интерфейсите не са само графични"
    },
    "l34": {
        "title": "Урок 34",
        "text": "където ще се научиш да запазваш, без да знаеш какво"
    },
    "l35": {
        "title": "Урок 35",
        "text": "където ще научиш как да не използваш магия"
    },
    "t7": {
        "title": "Тест 7",
        "text": "където ще провериш знанията си за софтуерната архитектура"
    },
    "l36": {
        "title": "Урок 36",
        "text": "където ще научиш как да си оправяш грешките"
    },
    "l37": {
        "title": "Урок 37",
        "text": "където ще научиш как да правиш няколко неща едновременно"
    },
    "l38": {
        "title": "Урок 38",
        "text": "където ще научиш как да направиш живота си по-лесен... или поне кода"
    },
    "l39": {
        "title": "Урок 39",
        "text": "където ще научиш как да пътуваш назад във времето"
    },
    "l40": {
        "title": "Урок 40",
        "text": "където ще научиш как да използваш Интернет"
    },
    "l41": {
        "title": "Урок 41",
        "text": "където ще научиш опциите си"
    },
    "t8": {
        "title": "Тест 8",
        "text": "където ще се тестваш сам"
    },
    "l42": {
        "title": "Урок 42",
        "text": "където ще те изпратя"
    }
}