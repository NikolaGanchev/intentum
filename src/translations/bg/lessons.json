{
    "l0": {
        "title": "Урок 0",
        "text": "където ще се запознаем",
        "p1p": "Здравей!",
        "p2p": "Аз съм автора на Интентум. И моята цел е до края на този „курс“ да имаш всички нужни знания в информатиката и програмирането, за да можеш да продължиш да учиш и без мен. И да правиш без мен. „Курсът“ е разделен на 42 урока (без урок 0) и 8 теста. Това би трябвало да обхваща всичко нужно за един старт в програмирането и да покрива целия материал по информатика от 8-ми до 12-ти клас, без да отнема 5 години. Всеки урок има тематично заглавие, което показва какво ще правиш в него.",
        "p3p": "Уроците не са сложни и са максимално опростени – вярвам че всеки може да се научи да програмира, ако обяснението е лесно. Това и причината да създам този източник – аз самия започнах от една книга за програмирането на английски, от която почти нищо не разбрах за програмирането. А на български източници почти няма. Един ден, някой ме попита „Ти как се научи?“, аз започнах да се оплаквам, че няма какво да му препоръчам, и изведнъж ми хрумна сам да се занимая с тази задача. И ето ме тук",
        "p4p": "Уроците до които не си стигнал са заключени. За да отключиш урок, трябва да минеш предния, или да натиснеш ключалката, която се намира на мястото на старт бутона. Аз обаче не препоръчвам да се пропускат уроци. Идеята на отключването е да можеш да си на едно ниво и на компютър, и на телефон, без да се налагат профили (и съответно, връзка с интернет) – не да пропускаш важен материал.",
        "p5p": "Уроците си имат и секции, като на края на всяка секция има въпрос и ключалка, криеща по-долния материал. Този въпрос е за самопроверка – независимо как отговориш, долния материал ще се разкрие. Твоя е задачата да прецениш дали не ти трябва още един прочит!",
        "p6p": "Казах че има и 8 теста. Не се плаши! Независимо какво направиш на тест, продължаваш на следващия урок. Тестовете са за самопроверка – до установиш собственото си ниво и да прецениш дали трябва да продължиш със следващия урок или да се върнеш назад.",
        "p7p": "Както забелязваш, особено важна ще е самопроверката. Колкото ти разчиташ на мен да има лесни и добре написани уроци, толкова и аз разчитам на теб сам да осъзнаваш кога трябва да наблегнеш на нещо. Желание се изисква и от двете страни.",
        "p8p": "В момента може да си представяш програмирането като някаква древна магия, използваема единствено от наследниците на Айнщайн и тези които решават кубични уравнения на салфетки, пишейки с кал, докато изкачват Мусала. Това не е така, и дори не се изисква да си особено добър математик. Предполагам обаче, че мога да ти докажа това само по един начин.",
        "p9p": "Засега това е от мен. Ще се срещнем отново в следващия урок – първия истински. Пожелавам ти късмет!"
    },
    "l1": {
        "title": "Урок 1",
        "text": "където ще научиш, че цифрите не са само 10",
        "p1p": "Вече сме в първия урок! Добре дошъл/дошла!",
        "p2p": "Предполагам, че заглавието на урока те е изненадало, и в момента се чудиш „Как така да не са 10 цифрите? Учителят от началното училище не спря да ми го повтаря“. Е, за да ти отговоря, първо трябва да те върна във въпросното начално училище.",
        "p3p": "Тогава си учил/а числата. И когато си ги учил, са те карали да пишеш нещо подобно:",
        "p4p": "56 = 5*10 + 6",
        "p5p": "Има логика. Да пробваме с трицифрено число:",
        "p6p": "156 = 1*100 + 5*10 + 6",
        "p7p": "Нека да запишем това в пълния му вариант – в крайна сметка, 6 всъщност се умножава по 1:",
        "p8p": "156 = 1*100 + 5*10 + 6*1",
        "p9p": "Първо да видим какво е общото между числата 100 и 10. От тук чувам как мислиш „И двете се делят на 10“. И си прав. Не само това, но и двете са степени на 10 –> 10 е 101 , а 100 е 102 . Да го запишем („^“ е знак за степен):",
        "p10p": "156 = 1 * 10^2 + 5 * 10^1 + 6*1",
        "p11p": "Аз обаче мога да ти кажа, че всъщност между всички три множителя има връзка – 100, 10 и 1. И трите всъщност са степени на 10. И в момента, може да се сетиш за нещо, което ти е било казано преди дълго време – което и да е число, повдигнато на степен 0, е 1. Тоест, 100 е 1. Сега получаваме:",
        "p12p": "156 = 1 * 10^2 + 5 * 10^1+ 6*10^0",
        "p13p": "Добре, значи да пробваме със шестцифрено число:",
        "p14p": "907 156 = 9 * 10^5+ 0 * 10^4 + 7 * 10^3 + 1 * 10^2 + 5 * 10^1 + 6*10^1",
        "p15p": "Можем да продължим още, но с всяко число ще получим нещо подобно. Изводът е, че всяко число в десетичната бройна система е равно на сбора от всичките му цифри, където всяка цифра се умножава по десет на степен позицията и. Тоест, каквото написахме горе, но в думи. Позицията на цифра се определя отдясно наляво – най-дясната цифра е 0,  всяка следваща е с 1 по-голяма. Например:",
        "p16p": "1 907 156 - Цифра",
        "p17p": "6 543 210 - Позиция",
        "p18p": "Поради факта че цифрите тук са 10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) и умножаваме по степен на 10, казваме че имаме десетична бройна система. А базата е 10.",
        "p19tq": "Каква би била базата на система с 2 цифри?",
        "p20fq": "Запиши на какво е равно числото 796 спрямо образеца 156 = 1 * 10^2 + 5 * 10^1 + 6*10^0, където „^“ значи степен.",
        "p21p": "След като изяснихме това, да напуснем началното училище и да се върнем в настоящето. И тук идва истинската цел на урока: да разбереш двоичната бройна система.",
        "p22p": "На всички им е известно, че компютрите разбират само 0 и 1. Съответно, те използват бройна система, където има само две цифри – 0 и 1. Една нула или единица е бит. И базата на тази система е 2.",
        "p23p": "Само с тази информация можем да дешифрираме нулите и единици. Например, имаме числото 010. Позициите са както следва:",
        "p24p": "210",
        "p25p": "Знаем, че ни трябва сбор от цифрите умножени по базата на степен позицията. Базата е 2, а позициите ги имаме:",
        "p26p": "010 = 0 * 2^2 + 1 * 2^1 + 0 * 2^0 = 0 * 4 + 1 * 2 + 0 * 1 = 2",
        "p27p": "Това е. Току що превърнахме числото 010 (база 2) в число в база 10 – 2. Да пробваме с нещо по-сложно – 1 байт – тоест 8 бита или с други думи, 8 цифри:",
        "p28p": "10110110 = 1 * 2^7 + 0 * 2^6 + 1 * 2^5 + 1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0 =  1 * 128 + 0 * 64 + 1 * 32 + 1 * 16 + 0 * 8 + 1 * 4 + 1 * 2 + 0 * 1 = 128 + 32 + 16 + 4 + 2 = 182",
        "p29p": "И ето че превърнахме в десетична бройна система и това дълго число.",
        "p30fq": "Превърни 11101110 в десетична бройна система",
        "p31tq": "110 в двоична бройна система е равно на колко в десетична?",
        "p32p": "Да направим обратното и да вземем отново числото 156. Този път, няма да умножаваме по 10, а ще делим на 10. С остатък. Получаваме: ",
        "p33p": "156 / 10 = 15  (15 * 10 = 150 -> остатък 6)",
        "p34p": "15 / 10 = 1 (1*10 = 10 -> остатък 5)",
        "p35p": "1 / 10 = 0 (0*10 = 0 -> остатък 1)",
        "p36p": "Забелязваме нещо. Ако вземем остатъците отдясно наляво, получаваме началното число: 156. За да направим това делим на базата 10, и получаваме число в десетична бройна система. Тогава да пробваме да делим на база 2, и може би ще получим число в двоична бройна система:",
        "p37p": "156 / 2 = 78 (остатък 0)",
        "p38p": "78  / 2 = 39 (остатък 0)",
        "p39p": "39 / 2 = 19 (ост. 1)",
        "p40p": "19 / 2 = 9 (ост. 1)",
        "p41p": "9 / 2 = 4 (ост. 1)",
        "p42p": "4 / 2 = 2 (ост. 0)",
        "p43p": "2 / 2 = 1 (ост. 0)",
        "p44p": "1 / 2 = 0 (ост. 1)",
        "p45p": "Значи, следвайки горната логика, получаваме числото 10011100, което изглежда в двоична бройна система (не забравяй, че четем отдясно наляво). Да направим проверка:",
        "p46p": "10011100 = 1 * 2^7 + 0 * 2^6 + 0 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0 = 1 * 128 + 0 * 64 + 0 * 32 + 1 * 16 + 1 * 8 + 1 * 4 + 0 * 1 = 128 + 16 + 8 + 4 = 156",
        "p47p": "Значи сме работили правилно!",
        "p48p": "И това е цялата двоичната бройна система. Нито е прекалено сложна, нито нещо неразбираемо. Надявам се да си хванал. Въпреки това, се тествай:",
        "p49fq": "На колко е равно 238 в двоична бройна система?",
        "p50p": "Свърших с материала за урока, но още не съм обяснил откъде идва заглавието. Всъщност е просто. По същия начин, по който можем да имаме бройни системи с бази по-малки от 10, можем да имаме и такива с по-големи от 10. Една широко използвана с по-голяма база е шестнадесетичната бройна система – с 16 цифри, тоест база 16. „Как така?“ питаш ти, и отговора е, че цифрите са тези  - 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A (10), B (11), C (12), D (13), E (14), F (15). Използват се букви за по-големите от 9. Главно се ползва за цветове. Например, числото EFEFEF е цвета на фона в по-голямата част на приложението. В десетична система това е 15 724 527, и виждаш че EFEFEF е сравнително по-лесно за изписване – има практическа полза.",
        "p51rq": "Избери си цвят и потърси числото му в база 16 в Интернет, като имаш предвид, че тези записи на цветове много често се наричат и hex, или хексове."
    },
    "l2": {
        "title": "Урок 2",
        "text": "където ще научиш как се събират и изваждат числа… отново",
        "p1p": "В този урок ще се научиш да събираш и изваждаш с други бройни системи. Подобно на цялата тема за други бройни системи, и това не е сложно.",
        "p2h": "Събиране",
        "p3p": "Нека първо да съберем две числа в десетичната бройна система. Нека да са 96 и 56.",
        "p4pre": "\n 96 \n + \n 56 \n152",
        "p5p": "Правил/а си това много пъти – слагаш двете числа едно под друго. Събираш първата колона отдясно наляво. Ако сборът е по-малък от 10, го записваш долу. Ако е по-голям или равен на 10, например 12, слагаш едно на ум на следващата колонка и записваш последната цифра – 2  (или записано по друг начин, разликата на 12 и 10). Това се повтаря с всички колонки.",
        "p6p": "Събирането на числа в двоичната бройна система всъщност е същото. Само че вместо да следим за 10, следим за 2 – базата на системата. Тоест, ако сборът на колонка е по-малък от 2, го записваме, иначе слагаме едно на ум на следващата колонка и записваме разликата на сбора и 2. Нека да пробваме:",
        "p7pre": "\n 101 \n + \n 011 \n1000",
        "p8p": "Първо събираме 1 и 1. Получава се 2, което е равно на две. Следователно пишем 1 на ум над следващата колонка и записваме 2-2 = 0. На следващата колонка събираме 0 и 1 и получаваме 1, но имаме 1 на ум, следователно сборът е 2. Слагаме 1 на ум, записваме 0 и продължаваме. На следващата колонка събираме 1 и 0, получаваме 1. Имаме 1 на ум, събираме и него, и получаваме 2. Пишем 1 на ум на следващата колонка. Записваме 0. Последната колонка е празна, затова пишем просто 1 (от предното 1 на ум). Получаваме 1000. Нека да направим проверка. 101 е 5. 011 е 3. 1000 е 8. Значи сме работили правилно.",
        "p10fq": "Колко е 10101101 + 01100110?",
        "p11h": "Изваждане",
        "p12pre": "\n101\n-\n011\n010",
        "p13p": "Тук, първо изваждаме 1 от 1. Получаваме 0, и я записваме долу. След това се опитваме да извадим 1 от 0.  Но не можем, защото 0 е по-малко от 1. Значи, взимаме 1 на ум от следващата колонка. Получаваме 2-1, което вече е 1. Записваме 1 долу. След това, трябва да извадим 1-0. Обаче сме взели 1 на ум, тоест ни остава 0-0. Записваме 0 долу. И имаме резултат. Да направим проверка: 101 е 5. 011 е 3. 010 е 2. Значи сме работили правилно.",
        "p14fq": "Запиши резултата на 10011 – 101",
        "p15h": "Умножение",
        "p16p": "Умножението на двоични числа е абсолютно същото като на десетични. Разлика няма. Важно е да не забравяш че събираш двоични числа, не десетични.",
        "p17pre": "\n  1101*11 \n  1101\n 1101\n100111",
        "p18fq": "Запиши резултата на 101 * 011",
        "p19h": "Деление",
        "p20p": "Делението на числа в други бройни системи е сравнително по-трудоемко. Най-лесния начин е да превърнеш числата в десетична бройна система, да ги разделиш, и резултата да превърнеш в двоично число. Например:",
        "p21pre": "\n110 / 011\n110 = 1 * 4 + 1*2 + 0*1 = 6\n011 = 0*4 + 1*2 + 0*1 = 3",
        "p22p": "Вече виждаме, че 6/3 = 2. Превръщаме 2 в двоична бройна система и получаваме 010. Следователно:",
        "p23pre": "110 / 011 = 010"
    },
    "l3": {
        "title": "Урок 3",
        "text": "където ще научиш как текст става нули и единици",
        "p1p": "Вече разбра, че компютъра действа само с нули и единици – от процесора, до паметта. Разбра и как представя нашите десетични числа само с две цифри, и как извършва аритметични действия с тях. Сега идва въпросът „Но как представя текст?“.",
        "p2p": "Първо, ще се върнем малко във времето. Далечната 1960, когато една група хора трябва да измислят начин, да превърнат символите в числа. Съответно, те мислят, и през 1963 година излиза ASCII (Американски стандартен код за обмен на информация, чете се „аски“). Той е сравнително просто решение – всеки нужен символ е свързан с число. Компютъра единствено запазва числото, а по-късно може да го разчете и да представи символа, на който съответства.",
        "p3p": "Общо има 128 символа, и всеки от тях се записва със 7 бита.",
        "p4p": "33 от тях не могат да се разпечатат – не се виждат по никакъв начин. Те обозначават команди, като край на заглавие, абзац, изтриване и т.н.",
        "p5p": "Потърси в Интернет ASCII таблицата – символите, които могат или не могат да се разпечатат, със съответстващите им букви. Преди малките букви са големите, а преди големите – цифрите и препинателните знаци.",
        "p6p": "Така всеки компютър знае, че например символ 32 е празно място, а символ 61 е малко латинско „a“.",
        "p7fq": "Колко са символите в ASCII?",
        "p8p": "Тук може би забелязваш лек проблем – има само латинските символи, препинателните знаци и цифрите. А какво става ако имаш съобщение на кирилица? Или на японски? Ами китайски? И къде се побират емотиконите в това цялото нещо. И отговора е, ами, никъде. Но този проблем не се появява за дълго време. В държавите, които използват непозволени символи се ползват различни кодирания на символите. Но се появява проблем – на компютър с ASCII, 61 е малко „a“. Но какво става ако не него се пусне файл, запазен с кодиране, в което 61 е “и”? Отговорът е \"пълен хаос\". Да не говорим и че се създават и много алтернативни кодирания, като например Windows-1251, където 0438 (в база 16, тоест 1080 в десетична бройна система) е „и“. Какво се случва, когато компютър, който опитва да чете ASCII, където символ 1080 няма, стигне до това? Символа обикновено се показва като въпросителни.",
        "p9p": "Тези проблеми се срещат и днес. Не си представяй, че са изчезнали. Но са много по-малко, благодарение на една причина – Unicode (от универсален код, чете се „юникоуд“, пише се уникод).",
        "p10p": "Уникод е създаден от няколко човека през 1991г. Той действа с няколко оптимизации – най-често използваните символи са първите, и те се запаметяват използвайки само 8 бита, а другите – с по 32. Това позволява невероятно количество символи – в последния стандарт през 2021 има 137 439 символа, обхващащи 146 писмености, мъртви и живи, множество символи и емоджита. Днес е в няколко различни версии, като UTF-8, UTF-16, UTF-32. В днешно време се използва почти навсякъде, заради това огромно разнообразие.",
        "p11tq": "Защо Unicode е толкова популярен?",
        "p11a1": "Плаща ти се, за да го използваш",
        "p11a2": "Корупционна схема",
        "p11a3": "Има най-много и разнообразни символи",
        "p11a4": "Заема най-много място",
        "p12p": "Това е какво ще ти е нужно относно това как компютрите се справят със символи.",
        "p13t": "Всяка буква и място, което напишеш, е символ, който се запазва като число."
    },
    "l4": {
        "title": "Урок 4",
        "text": "където ще научиш, че разширенията са лъжа",
        "p1p": "Информацията в компютър се разделя на файлове – парчета информация. Всеки файл си има име и големина – обикновено измервана в байтове (1 байт = 8 бита). Файловете се групират в папки, като във всяка папка може да има файлове и други папки. Така се оформя модел на организация, подобен на дърво – всяка папка е нов клон, в който има файлове и от който започват още клони – папки.",
        "p2tq": "Във всяка папка може да има:",
        "p2a1": "Само папки",
        "p2a2": "Само файлове",
        "p2a3": "Хард дискове",
        "p2a4": "Папки и файлове",
        "p3p": "В повечето операционни системи (Windows, Linux, MacOS), главната папка се нарича “C” (“це”), често наричана и корен („root“), защото се явява корен на файловото дърво. Пътят („path“) на файл или папка е последователността папки, през които потребител трябва да премине, за да стигне до файла или папката. Пътищата са 2 вида: абсолютни и относителни. Абсолютният път винаги започва от главната папка и завършва на файл или папка. Той е абсолютен. Относителният път може да започва от която и да е папка. Тоест, той се отнася към други папки и файлове.",
        "p4tq": "Откъде започва абсолютен път?",
        "p4a1": "От коренът на файловото дърво",
        "p4a2": "От която и да е папка",
        "p4a3": "От който и да е файл",
        "p4a4": "От файла, до който е",
        "p5p": "Когато пътищата се записват, между всяка папка или файл се записва разделител. В Linux и MacOS, това обикновено е „/“. В Windows, разделителят е „\\“. Това обаче не е практично в програмирането, заради множеството запазени символи с „\\“. Например, в повечето файлове „\\n“ означава нов ред и не се показва на потребителя, а \\t означава таб.",
        "p6tq": "Какво означава символът „\\n“?",
        "p6a1": "Нов ред",
        "p6a2": "Празно пространство",
        "p6a3": "Таб",
        "p6a4": "Главна буква",
        "p7p": "Нека да разгледаме пример. Ние сме в Windows. Влезли сме в потребител на име „Gosho“. Този потребител има файл на име „nominacii.docx“ в папката си „Документи“ („Documents“). Тази папка се намира в папката му потребители („Users“), която е в кореновата му папка („C“).",
        "p8p": "Така би изглеждал абсолютния път до този файл:",
        "p9pre": "C:\\Users\\Gosho\\Documents\\nominacii.docx",
        "p10p": "Първо да отбележим, че кореновата папка се записва с „:“ преди разделителя. Тоест имаме „C:\\“.",
        "p11p": "Забележи, че това е Windows. Тоест, разделител е „\\“. С разделител „/“ бихме имали съшия ефект: ",
        "p12pre": "C:/Users/Gosho/Documents/nominacii.docx",
        "p13p": "Този случай обаче е по-практически за целите на програмирането. Горе, „\\n“ в „\\nominacii.docx“, би било интерпретирано като нов ред от повечето езици, което ще доведе до грешки. За остатъка на този „курс“, ще използвам главно „/“ поради тази причина.",
        "p14p": "Освен това, можем да поставим и разделител след края на пътя, но не е препоръчително:",
        "p15pre": "C:/Users/Gosho/Documents/nominacii.docx/",
        "p16tq": "Защо не е препоръчително да използваме „\\” за разделител в програмирането?",
        "p16a1": "Грозно е",
        "p16a2": "Не работи в Windows",
        "p16a3": "Защото може да се интерпретира като различни контролни символи",
        "p17p": "Да си представим обаче, че нашия потребител иска да започне от папка на име „Проекти“ („Proekti“), която се намира в „Документи“ и да стигне до „nominacii.docx“. За това ще използваме относителен път.",
        "p18p": "Първо да видим абсолютният път на папката „Proekti“:",
        "p19pre": "C:/Users/Gosho/Documents/Proekti",
        "p20p": "След това, абсолютния път на файла nominacii.docx:",
        "p21pre": "C:/Users/Gosho/Documents/nominacii.docx",
        "p22p": "Забелязваме, че и двете са в папка „Documents“. Само че едното е папка, а другото - файл.",
        "p23p": "В относителните пътища имаме активна (или работна) папка. От нея започва пътят. Има няколко специални символи за навигация. „./“ означава работната папка. Тоест, ако работна папка е  „Proekti“, и в нея има файл „proekt1.txt“, можем да достигнем този файл чрез пътя:",
        "p24pre": "./proekt1.txt",
        "p25p": "Тоест, „./“ просто значи „папката, в която съм“.",
        "p26p": "Но ако искаме да достигнем елемент в предна папка от работната, използваме „../“. Това значи „предната папка от работната“. Спрямо „Proekti“, това е папката „Documents“. Така, ако искаме да достигнем „nominacii.docx“ от Proekti използваме пътя:",
        "p27pre": "../nominacii.docx",
        "p28p": "Така можем да се връщаме и повече папки назад. Например, ако в „Gosho“ има файл с име „hello.txt”, можем от работна папка „Proekti“ да го достигнем така: ",
        "p29pre": "../../hello.txt",
        "p30p": "Както си забелязал/а, не съм писал име на папка или потребител с кирилица. Това е така, защото някои системи поддържат единствено ASCII и кирилицата създава проблеми с тях.",
        "p31tq": "В относителен път „./“ е:",
        "p31a1": "работната папка",
        "p31a2": "предната папка",
        "p31a3": "следващата папка",
        "p31a4": "файл",
        "p32p": "Както си забелязал, заглавието на този урок казва, че разширенията са лъжа. Но не сме говорили за това. Като става на въпрос, от началото на урока не съм написал думата „разширение“ и веднъж. Разширенията на файл са последната част от него, отделена с „.“ от остатъка. Всички разширения до сега са написани като част от имената на файловете:",
        "p33p": "nominacii.docx – „.docx“ е разширението",
        "p34p": "proekt1.txt, „hello.txt“ – „.txt“ е разширението",
        "p35p": "Но реалността е, че разширенията са лъжа. Предложение, ако трябва да сме точни.",
        "p36p": "Първо, всеки файл е просто текст или двоичен формат (нули и единици, без текстово значение). Нищо друго. А разширенията са част от името.",
        "p37p": "Разширенията са само предложение. Когато операционната система види „.docx” файл, знае да го отвори с Word. Когато види „.mp3” файл, знае че е музика. Но това не ни пречи да го отворим с друго приложение. Можем да натиснем файла с десен бутон на мишката, да натиснем „Отвори с“. Да натиснем „Още приложения“. Да намерим Notepad, и да отворим файла с него. И виждаме само текст. Може файла да е двоичен – тоест вече е на нули и единици. Когато го отворим, виждаме странни символи – няма кодиране, което да може да бъде прочетено. ",
        "p38p": "Файлът може дори и да няма разширение. Популярната платформа Heroku използва някои файлове без разширения – например „Procfile“ – чете ги и ги отваря като текстови.",
        "p39p": "Един от най-честите проблеми на програмистите е да запазват информация, заедно с това за какво е предназначена тя. Например, искаш да запазиш езика на приложение и после да го прочетеш от файл. Можеш просто да направиш файл „ezik.txt“ и да го запишеш там. Но е непрактично. После можеш да имаш настройка като режим – тъмен или светъл. И за нея ли ще създадеш файл? За това съществуват ключ-стойност форматите. Да ги разгледаме:",
        "p40h": "XML",
        "p41p": "XML е един от най-старите формати. Той е на основата на тагове. Един таг може да е отваряш и затварящ. Отварящ таг изглежда така:",
        "p42pre": "<име на тага>",
        "p43p": "Затварящ таг изглежда така:",
        "p44pre": "</ име на тага>",
        "p45p": "Съответно, това позволява запазване на информация. Например (ще използвам английското съкращение „lang“ за език и английската дума „mode“ за режим – прието е да не се пишат тагове на друго освен латиница):",
        "p46pre": "<lang> Български </lang >\n<mode> Светъл </mode>",
        "p47p": "Друго уникално свойство на xml е, че между таговете може да има и други тагове („settings“ - настройки):",
        "p48pre": "<settings>\n\t<lang> Български </lang >\n\t<mode> Светъл </mode>\n</settings>",
        "p49p": "Забележи как с всяко следващо ниво на тагове слагаме повече място вляво.",
        "p50p": "Използвайки този формат, програмистът може после да поиска стойността на lang в settings и да получи „Български“.",
        "p51p": "XML се използва широко – „.docx“ са архиви, но когато се разархивират са главно .xml файлове. Също и целия интернет зависи от xml – неговия подезик html е основната структура на всеки сайт. Mоже да носи и информация в таговете – така се добавя картина в уебсайт:",
        "p52pre": "<img src=„път към картина“></img>",
        "p53p": "Тук „src” дава пътят към картината (относителен). След това браузърът иска стойността на „src“ в „img“ и получава пътят, с който да зареди картината",
        "p54fq": "Напиши отварящ и затварящ таг „version“, между които е записано 17.2",
        "p55h": "JSON",
        "p56p": "XML обаче не е удобен за пренос на голямо количество информация. Всяко име на таг се пише по два пъти (за отварящ и затварящ), което е много байтове информация. Затова се използва JSON (нотация на обекти на Javascript). Първо, този формат се чете много лесно от Javascript, динамичния език на всеки уебсайт, както подсказва и името. Да си представим, че ти си правиш профил в някоя мрежа. Слагаш си име име, e-mail, възраст и парола. След това натискаш „регистрация“. Към сървъра тръгва съобщение, което изглежда така: ",
        "p57pre": "{\n\t\"ime\": \"Gosho\",\n\t\"email\": \"gosho@email.email\",\n\t\"parola\": \"dobraparola\",\n\t\"vuzrast\": 18\n}",
        "p58p": "Toва е JSON. Започва с „{“ и завършва с „}“. Отляво винаги има ключ – например „ime“. След това има „:“, което значи край на ключа. Всеки ключ е обграден в кавички. След „:“ е стойността. Тя може да е няколко вида. Първият е текст, заобграден с кавички. Може да е просто число, като 18. Може да е списък: ",
        "p59pre": "{\n\t\"spisuk\": [\"яйца\", \"хляб\", \"масло\"]\n}",
        "p60p": "Или дори още един обект JSON:",
        "p61pre": "{\t\"ime\": \"Gosho\",\n\t\"email\": \"gosho@email.email\",\n\t\"parola\": \"dobraparola\",\n\t\"vuzrast\": 18,\n\t\"dopulnitelno\": {\n\t\t\"spisuk\": [\"яйца\", \"хляб\", \"масло\"]\n\t}\n}",
        "p62p": "След края на стойност има запетайка, следващ ключ и така нататък.",
        "p63w": "След последната стойност няма запетая.",
        "p63p": "JSON е най-честия формат за пренасяне на информация в Интернет",
        "p64tq": "Стойността на ключ в JSON не може да е:",
        "p64a1": "списък",
        "p64a2": "текст",
        "p64a3": "число",
        "p64a4": "файл",
        "p65rq": "Намери информация за файловите формати TOML и YAML"
    },
    "l5": {
        "title": "Урок 5",
        "text": "където ще научиш как са управлявали компютрите преди графиката",
        "p1p": "В този урок ще се върнем към древните времена, когато е нямало графични интерфейси. Когато всеки, който е работил с компютър е навигирал само чрез текст в един тъмен прозорец - ще разгледаме конзолата.",
        "p2p": "Конзолата е различна според операционната система. На Windows е CMD или PowerShell. На Linux най-вероятно е Bash. На MacOS е Terminal („терминал“). Последните две са базирани на Unix конзолата, тоест имат подобни команди. CMD и PowerShell се различават малко. Тук ще покрия главно CMD и Unix конзолите.",
        "p3p": "Когато отвориш конзола, тя ще стартира с активна папка в потребителя ти. Ще видиш нещо подобно:",
        "p4con": "<<prefix>>C:/Users/Потребител>",
        "p5p": "След „>“ ще имаш поле за писане. Можеш да напишеш команда и да натиснеш „Enter“ („нов ред“) за да я изпълниш. Първата команда, която ще разгледаме е „tree“ („дърво“). Тази команда показва всички папки и файлове като дърво. Понякога е полезна, особено ако работиш в среда без графичен интерфейс. Действа и много добре за показване на „умения“ и хвалене.",
        "p6tq": "tree командата показва:",
        "p6a1": "Картинка на дървото",
        "p6a2": "Структурата на файловете",
        "p6a3": "Структурата на папките",
        "p6a4": "Структурата на папките и файловете",
        "p7p": "Освен това, в случая „C:/Users/Потребител>“ е нашата работна папка. Можем да я сменим. Това става чрез командата „cd“ от „change directory“ („промени директория“ (директория е синоним на папка)). Конзолата действа с относителни адреси. Тоест, ако напишем:",
        "p8con": "<<prefix>>C:/Users/Потребител> cd ./",
        "p9p": "Ще останем в същата папка. Ако напишем:",
        "p10con": "<<prefix>>C:/Users/Потребител> cd ../",
        "p11p": "Ще получим:",
        "p12con": "<<prefix>>C:/Users>",
        "p13p": "Защото сме се върнали папка назад. За да се върнем в „Потребител“ можем да напишем:",
        "p14con": "<<prefix>>C:/Users> cd Потребител",
        "p15p": "Което ще има резултат:",
        "p16con": "<<prefix>>C:/Users/Потребител>",
        "p17p": "Ако искаме да навигираме до папка, в чието име има празно място, заграждаме името в кавички:",
        "p18con": "<<prefix>>C:/Users/Потребител> cd \"Папка с празно място\"",
        "p19p": "Ако отново имаме абсолютния път „C:/Users/Gosho/Documents/nominacii.docx“, и имаме конзола в „C:/Users/“, можем директно да стигнем до „Documents“ по следния начин:",
        "p20con": "<<prefix>>C:/Users/> cd ‘’Gosho/Documents/",
        "p21p": "Ще имаме резултат:",
        "p22con": "<<prefix>>C:/Users/Gosho/Documents/>",
        "p23tq": "При работна папка \"C:/Users/Gosho/Documents/\" и изпълнена команда \"cd ./\" ще отидем в папка:",
        "p23a1": "Ще останем в сегашната",
        "p23a2": "Ще отидем в \"Gosho\"",
        "p23a3": "Ще отидем в \"Users\"",
        "p23a4": "Ще отидем в \"C:/\"",
        "p24p": "От конзолата могат и да се пускат приложения. Ако имаш файл с име „program.exe“ (поне на Windows) в работната си папка и напишеш в конзолата „program.exe“, програмата ще стартира.",
        "p25con": "<<prefix>>C:/Users/Gosho/> program.exe",
        "p26p": "Много от програмите имат и аргументи. Те се пишат във формат „-ключ стойност“. Например: („light“ - светъл)",
        "p27con": "<<prefix>>C:/Users/Gosho/> program.exe -mode light",
        "p28p": "Програмата ще получи тази информация. В уроците напред ще се научиш да четеш и пишеш в конзолата чрез програми и да взимаш и ползваш аргументи.",
        "p28tq": "Кое е валиден ключ за аргумент?",
        "p28a1": "-mode",
        "p28a2": "*mode",
        "p28a3": "mode",
        "p28a4": "/mode",
        "p29rq": "Потърси как се създават, трият, копират и местят файлове в твоята конзола."
    },
    "l6": {
        "title": "Урок 6",
        "text": "където ще научиш какво е алгоритъм",
        "p1p": "Аххх – алгоритъм! Една от по-криворазбраните думи като цяло. И сега ще си говорим точно за нея.",
        "p2p": "Да изясним първо какво е алгоритъм. Алгоритъм е последователност от действия за постигане на резултат.",
        "p3p": "Това е всичко. Алгоритъм е например сутрешната рутина:",
        "p4p": "Ставам. Измивам си зъбите. Закусвам. Резултатът е, че съм готов за деня.",
        "p5p": "За постигане на един и същ резултат може да има няколко различни алгоритъма:",
        "p6p": "Ставам. Измивам си зъбите. Къпя се. Закусвам. Пак съм готов.",
        "p7p": "Ставам. Гледам часовника. Закъснявам с 30 минути. Мия си зъбите докато се обличам. Отново съм готов.",
        "p8p": "Резултатът също е общ. Например, ако сортирам една купчина предмети по един начин и друга по същия начин, купчините не са еднакви. Но резултата от алгоритъма за сортиране е еднакъв – елементите са сортирани. По същия начин, алгоритъма за тотото винаги има еднакъв резултат – винаги има изтеглени 6 числа, нищо че са различни всеки път.",
        "p9p": "Да се извърши един и същ алгоритъм два пъти и да се очаква различен резултат е лошо, а ако се получи, значи има грешка в алгоритъма – очаква се реултатът от алгоритъма за пране да е „чисти дрехи“, не „наводнена стая“.",
        "p10tq": "При две извършвания един алгоритъм се очаква да има:",
        "p10a1": "Различни действия",
        "p10a2": "Различен резултат",
        "p10a3": "Еднакъв резултат",
        "p10a4": "Различни алгоритми",
        "p11p": "Подобно е в програмирането. Всяка програма действа с множество алгоритми. Ти ще създадеш много. Някои ще прочетеш, защото са били измислени от хора по-умни от мен и теб. Да разгледаме един.",
        "p12p": "Представи си, че пред теб има 10 числа в редица. Всъщност, не си представяй. Ето ги:",
        "p13p": "1, 5, 78, 6, 9, 127, 6758, 89, 9680, 9679",
        "p14p": "Намери най-голямото число.",
        "p15p": "„9680!”, разбира се. Но как го намери? „Видях го“ не е валиден отговор. Компютрите не виждат. Нека да създадем алгоритъм за намиране на най-голямото число:",
        "p16p": "Ти най-вероятно първо си взел числото, което ти е изглеждало най-голямо. На компютъра обаче не му „изглежда“, така че за целта на този алгоритъм ще изберем първото число. „1“ в този случай. След това ще погледнем следващото число. То е 5, което е по-голямо от 1. Значи нашето число вече е 5. След това имаме 78. То е по-голямо от 5, значи нашето число вече е 78. След това има 6. 6 е по-малко от 78. Значи го пропускаме и 78 остава нашето число. Това продължава до края на редицата числа. Накрая, гарантирано нашето число ще бъде най-голямото – 9680.",
        "p17tq": "Как да модифицираме горния алгоритъм, за да намира най-малкото число от редицата?",
        "p17a1": "Слагаме минус пред крайния резултат",
        "p17a2": "Вместо за по-голямо, проверяваме за по-малко",
        "p17a3": "Обръщаме редицата преди това",
        "p17a4": "Изваждаме сбора на числата от редицата от резултата",
        "p18p": "Това е един от множеството алгоритми, които ще срещнеш, но със сигурност е един от най-простите и най-често използваните. ",
        "p19t": "Ако ще използваш алгоритъм достатъчно, ще го научиш от повторение. Ако не го използваш достатъчно, за да го научиш, значи че не ти се и налага. От теб се иска само да запомниш, че го има, в случай че ти потрябва, за да можеш да го потърсиш. Освен ако нямаш специалната задача да научиш алгоритъм наизуст. А аз няма да ти давам такива задачи."
    },
    "l7": {
        "title": "Урок 7",
        "text": "където ще научиш връзката между бисквитите и паметта",
        "p1p": "Това е един от по-сложните уроци, тоест внимавай. Ще се занимаем с паметта.",
        "p2p": "Първо да ти обясня, че компютърът има 2 типа памет – RAM и ROM. ROM паметта е в хард дискове, SSD-та и т.н. Това е постоянна памет – тя продължава да съществува дори и да няма ток към нея. На нея се съхраняват файловете и някои други неща. Представи си, ако всеки път когато рестартираше компютъра си, трябваше да преинсталираш операционната си система… и всичките ти файлове се губеха… и трябваше да преинсталираш всяко приложение... Хаос, нали? Това е проблема, който решава ROM паметта. Тя обикновено е и голяма – трябва да има място за всичко. Къде обикновено се проваля е в бързината -  ROM паметта исторически не е бърза. ",
        "p3p": "Вторият тип памет е RAM паметта. Тя обикновено е много по-бърза и много по-малко от ROM. Тя обаче зависи от източника на енергия – в момента, в който той вече отсъства, тя се изпразва напълно. На нея зареждат приложенията – например, когато отворите калкулатора и напишете число в него, то се запазва в RAM. Така го виждате докато пишете. Текстът, който пишете в Word е запазен в ROM, но го виждате защото е бил зареден в RAM. RAM  е паметта, до която приложенията имат директен достъп. Затова и всичко се затваря, когато рестартираш компютъра си. Запазването в ROM е малко по-сложно.",
        "p4tq": "RAM е памет, която:",
        "p4a1": "e енергийно зависима",
        "p4a2": "върви само на екологична енергия",
        "p4a3": "запазва в перманентна форма",
        "p4a4": "e вида на хард дисковете",
        "p5p": "Да преминем на двете части, на които се разделя RAM паметта при всяка програма.",
        "p6h": "Heap",
        "p7p": "Heap (чете се „хийп“, означава „купчина“) е единия вид памет, до който има достъп всяка програма. Както показва името, той е купчина от информация – буквално. Представи си купчина играчки, нахвърляни една върху друга. Друго важно нещо за хийпа е, че той има случайна подредба. Освен това е доста голям. Тоест, ако процесора получи команда от типа „запази ми 4 байта на хийпа“, той ще започне да минава през хийпа от началото му. В някакъв момент ще намери празно място. След това ще преброи битовете до края на празното място, и ако има достатъчно, ще отдели паметта като заета – 4 байта, както гласи съобщението. Веднъж заета, паметта седи така до един от два случая – или бива маркирана като свободна на по-късен етап, или при край на изпълнението на програмата. Това е хубаво, но след като заемем памет на хийпа, как стигаме до нея? Все пак тя е случайно разхвърляна. И всеки, който е търсил играчка в купчината знае колко е сложно това. Да не говорим, че целия процес на заемане на памет не е особено бърз – просто паметта е много.",
        "p8tq": "Хийпът е:",
        "p8a1": "голям",
        "p8a2": "малък",
        "p8a3": "подреден",
        "p8a4": "много бърз",
        "p9h": "Stack",
        "p10p": "За да реши предните проблеми, на помощ идва Stack паметта („стак / стек“). Тя не е голяма, но е подредена и бърза. Тя е и общото между пакетите обикновени бисквити и компютрите. Остави ме да обясня:",
        "p11p": "Стакът е много прост. Той е като кутия, при която е открита горната част:",
        "p12alt": "Правоъгълник с открита горна част",
        "p13p": "В тази кутия могат да се слагат единствено други кутии, които са една върху друга:",
        "p14alt": "Кутията от по-горе, този път с три други правоъгълника вътре, поставени един върху друг",
        "p15p": "Както забелязваш, към кутия може да се прибави само от горе. И може да се извади само последното добавено нещо. Като пакетите с обикновени бисквити. Това е стакът. Но как решава проблемите с хийпа? ",
        "p16p": "Всеки път когато програмата навлезе в нов блок код, към стака се добавя още една кутия. Можем да запазваме на кутийката на блока в стака. Ако обаче ни трябва хийпа заради големината му, изпращаме подобно на горното съобщение на процесора. Той заема паметта и ни отговаря с адрес. Ние можем да запазим този адрес в кутийката ни на стака. Ако имаме нужда, можем да използваме този адрес, за да се върнем на заетата памет, да я променим, или да кажем да бъде маркирана като свободна за заемане. ",
        "p17p": "Има един проблем обаче. Когато нашия блок код свърши, кутийката ни в стака изчезва. С нея изчезва и запаметения адрес. Тоест, ние вече нямаме достъп до заетата памет от хийпа – тя ще продължи да съществува до затваряне на програмата. Това се нарича memory leak – теч на памет. Течовете на памет водят до огромни проблеми със сигурността и ресурсната тежест на програмите. В следващия урок ще разберем как различните езици за програмиране се справят с това.",
        "p18tq": "Течовете на памет се получават от:",
        "p18a1": "Разливане на вода върху RAM",
        "p18a2": "Разливане на вода върху ROM",
        "p18a3": "провал да се маркира като свободна памет от стака",
        "p18a4": "провал да се маркира като свободна памет от хийпа",
        "p19p": "Може би си забелязал/a, че след този урок има тест. Късмет!"
    },
    "t1": {
        "title": "Тест 1",
        "text": "където ще провериш уменията си с компютри",
        "p1fqc": "Превърни двоичното 1111 0101 в десетично число:",
        "p1a": "245",
        "p2fqc": "Превърни десетичното 136 в двоично число:",
        "p2a": "1000 1000",
        "p3fqc": "Пресметни 1011 1010 – 0010 0100, като знаеш че и двете числа са двоични. Резултата запиши като число в база 16:",
        "p3a": "91",
        "p4fqc": "Пресметни 1011 умножено по 10, като знаеш че и двете числа са двоични. Резултата запиши като десетично число:",
        "p4a": "22",
        "p5tqc": "Къде най-често се използват така наречените „хексове“?",
        "p5a1": "Координати",
        "p5a2": "Цветове",
        "p5a3": "Мерни единици",
        "p5a4": "Аритметични действия",
        "p6tqc": "ASCII поддържал ли е кирилица?",
        "p6a1": "Да",
        "p6a2": "Не",
        "p7tqc": "Каква оптимизация използва UTF-8, за да съхранява ефективно всички символи?",
        "p7a1": "Съхранява най-често използваните с 4 бита",
        "p7a2": "Съхранява най-често използваните с 8 бита",
        "p7a3": "Съхранява рядко използваните с 2 байта",
        "p7a4": "Съхранява най-често използваните с 8 байта",
        "p8tqc": "Пътят „../“ като относителен означава:",
        "p8a1": "Предишна папка",
        "p8a2": "Сегашна папка",
        "p8a3": "Сегашен файл",
        "p8a4": "Работна папка",
        "p9tqc": "Разширението на файла НЕ:",
        "p9a1": "помага за организацията на файловете",
        "p9a2": "е част от името на файл",
        "p9a3": "показва за коя програма е предназначен файла",
        "p9a4": "лимитира с каква програма може да бъде отворен файла",
        "p10tqc": "XML НЕ се използва за:",
        "p10a1": ".docx файлове",
        "p10a2": "HTML",
        "p10a3": "YAML",
        "p11tqc": "JSON следва модела:",
        "p11a1": "ключ-стойност",
        "p11a2": "информация – размер",
        "p11a3": "стойност – обяснение",
        "p11a4": "файл-стойност",
        "p12tqc": "Командата „cd“:",
        "p12a1": "променя директорията",
        "p12a2": "създава файл",
        "p12a3": "изтрива директорията",
        "p12a4": "изтрива файл",
        "p13tqc": "За алгоритмите е вярно, че:",
        "p13a1": "се очаква да имат повече от един резултат",
        "p13a2": "са последователност от действия",
        "p13a3": "при всяко изпълнение действията се променят",
        "p13a4": "при всяко изпълнение не действат",
        "p14tqc": "ROM паметта зависи от енергия:",
        "p14a1": "Да",
        "p14a2": "Не",
        "p15tqc": "RAM паметта зависи от енергия:",
        "p15a1": "Да",
        "p15a2": "Не",
        "p16tqc": "Приложенията зареждат на RAM паметта:",
        "p16a1": "Да",
        "p16a2": "Не",
        "p17tqc": "Хийпът е:",
        "p17a1": "хаотичен",
        "p17a2": "подреден",
        "p18tqc": "Можем да извадим елемент от стака, дори ако върху него има друг елемент:",
        "p18a1": "Да",
        "p18a2": "Не",
        "p19fqc": "Какво се случва, когато загубим адреса на парче памет в хийпа, без да сме го маркирали като свободно?",
        "p19a1": "memory leak",
        "p19a2": "теч на памет",
        "p20fqc": "Опитай да си обобщиш какво научи в предния раздел в няколко изречения."
    },
    "l8": {
        "title": "Урок 8",
        "text": "където ще научиш какво ще учиш",
        "p1p": "Какво е програмен език? Програмен език е език, с който се програмира, очевидно. Програмните езици са синтетични, изкуствени, конструирани и създадени от хора – те си приличат. Приличат си много. Почти всеки език има концепциите на почти всеки друг език. В повечето случаи даже и думите са еднакви – като нашите говорими езици от латинското семейство, или от германското семейство, или от славянското семейство. Стига да знаеш един език от семейството, другите са много по-малка пречка. А един бонус на програмните езици, е че те имат по около 100 думи, а не по 1000 страници думи като нормалните езици. Какво искам да ти кажа е, че програмния език няма особено значение. Важни са концепциите. И за остатъка от този „курс“ ще научиш повечето от тях. След това ще си свободен да ползваш всеки програмен език.",
        "p2p": "Програмните езици водят началото си преди много време. Първоначално, на процесорите е трябвало да се дават команди, написани чрез дупки на картончета – дупка означавала 0, а място – 1. След това, някой е измислил Assembly. Първия „истински“ програмен език. Той не е бил много над нулите и единиците обаче – просто командите са се пишели с текст, не с числа, което е било огромно подобрение. А и е бил специфичен за всяка архитектура процесори – представяш ли си да напишеш една програма 3 пъти за 3 различни архитектури!?",
        "p3p": "След това се е случило чудо. Появил се е „C“ (“си”). Първия модерен програмен език! Той има повечето от функциите, които и всеки друг модерен програмен език има. Но преди толкова много време – през 1972г! Това е било революция – най-после кодът е приличал повече на нещо, написано в днешно време. А и е можело да напишеш код веднъж и да създадеш от него програми за множество архитектури.",
        "p4p": "Обаче „C“ не е само рози. Езикът оставя програмистът сам да контролира паметта си. Което е много хубаво, ако разбираш какво правиш, и много лошо, ако не, защото създаваш код пълен с течове на памет и проблеми.",
        "p5p": "Днес много голяма част от света продължава да върви на C. И на неговия следващ език – C++. Даже и операционната система, която ползваш, най-вероятно е написана на тях.",
        "p6p": "Езиците, споменати до сега са ниско ниво – те са близко до компютъра – дават на програмиста контрол над паметта и накрая стигат директно до компютърни команди. Това се случва, благодарение на компилатор. Компилатор е програма, която взима и чете файл, на да кажем C, и създава машинен код от него. Машинния код вече може да се разпространява и да върви на компютъра.",
        "p7p": "От създаването на C до днес много езици да били направени, станали са популярни, и даже са изчезнали – BASIC, Visual Basic, COBOL, Fortran (този продължава да се ползва в математиката). Много и продължават да съществуват – Java, C#, Python, Perl, Ruby, Javascript. А нови езици се появяват постоянно – Kotlin, Go, Rust, Typescript.",
        "p8p": "Езици като Java и C# са високо ниво – те са по-прости, по-контролирани и не позволяват контрол над паметта – обикновено всяко парче памет се запазва на хийпа с адрес в стака. От време на време, през хийпа минава програма на езика, наречена „Garbage collector“ (събирач на боклук), която проверява дали парчетата памет имат запазен адрес някъде в стака. Ако нямат – биват изтрити. Автоматично. Директно на стака се запазват обикновено примитивните типове (int, short, long, float, double, char, boolean, които ще разгледаме в следващите уроци), когато са локални (не са част от или общи за клас – ще разбереш по-късно).",
        "p9p": "Има и езици като Python („пайтън“, питон) – старата шега е, че да си направиш къща с Assembly е като да си отрежеш сам дървата и да си я построиш, със C имаш дървата, само трябва да строиш, а при Python ти доставят къщата готова. Python е интерпретиран език. Това значи, че за да пуснеш програма с него, трябва да инсталираш езика на компютъра си. Когато стартираш програмата, интерпретатора започва да чете файла в движение – това прави езика по-бавен, но му позволява да върви навсякъде – ако на устройството може да се инсталира Python, то всяка програма написана на него върви там.",
        "p10p": "Стигаме и до езиците, които ще се използват тук – Java („джава“) и C# („си шарп“). Те са два от най-ползваните езици в световен мащаб, и два от най-подобните. И двата езика са някъде между C и Python като ниво.",
        "p11p": "Уникалното при Java е, че тя е компилирана и интерпретирана. Всяка Java програма първо се компилира в нещо, наречено byte-code („байт код“). Този код се разпространява като програма. За да бъде стартиран, компютърът, на който е, трябва да има инсталирана Java. При стартиране JVM (Java virtual machine – Java виртуална машина) взима байт кода и започва да го интерпретира. Това позволява на Java бързина подобна на тази на компилираните езици и способността да върви на всеки компютър с Java.",
        "p12p": "C# е подобен. Той първо се компилира до код наречен IL. Когато се стартира на друг компютър, .NET Common Language Runtime („точка нет общ езиков изпълнител“) го компилира втори път, този път до машинен код и го пуска. Това му позволява да е бърз като компилиран език, но и да върви на всеки компютър с .NET Common Language Runtime.",
        "p13p": "Езиците за програмиране обаче не са прости. И не можем просто да ги пишем в Notepad – би било твърде трудоемко. Затова съществуват IDE-та („Integrated development environment“ – интегрирана среда за разработка). Те са редактори на текст, които позволяват бърза смяна на отворени файлове, опитват да предскажат какъв код ще напишеш, опитват да поправят грешките ти, помагат да ги откриваш сам, и обикновено имат бутон за пускане на програмата, за да не трябва да запомняш дългите команди на конзолата, които се искат, за да компилираш и пуснеш програма. Те обаче са само това – те не могат да променят езика, не могат да причиняват грешки сами и т. н.",
        "p14p": "От следващия урок започва програмирането. Истинското. И трябва да се подготвиш. Избери си кой език ще следваш – C# или Java. Няма особено значение.",
        "p15p": "Избра ли?",
        "p16p": "Ако си избрал Java, имаш два избора за IDE – Eclipse и IDEA, които аз ползвам. За начинаещи, препоръчвам Eclipse, но ако искаш, можеш да започнете и веднага от IDEA.",
        "p17p": "Ако си избрал C#, имаш един избор – Visual Studio.",
        "p18p": "Надолу ще обясня процеса на инсталация на всичко нужно и започването на проект:",
        "p19ds1": "Eclipse",
        "s19p": "Трябва да инсталираш Eclipse. Отиди на следния сайт: https://www.eclipse.org/downloads/",
        "s20p": "и натисни Download бутона. Ще бъдеш заведен на друга страница. Натисни бутона за теглене там. Операционната ти система автоматично ще бъде разпозната. След изтегляне на файла, отвори го. Ще ти излезе списък с опции. Искаш „Eclipse IDE for Java Developers”. Ще ти излезе меню, където можеш да редактираш папката за инсталация. Освен това, Eclipse инсталира Java автоматично за теб, така че избери версия от същото меню. След това следвай инструкциите за инсталация. След инсталацията стартирай програмата.",
        "s21p": "Когато програмата стартира, в горния ляв ъгъл ще видиш бутон File. Натисни го и избери опцията New. После избери Java Project. Ще ти излезе прозорец, където да именуваш проекта си – избери име на латиница. Пробвай да няма празни пространства в името. Натисни Finish. В левия панел ще се появи проекта ти. Той ще има две неща под себе си – JRE System Library и src. Интересуваш се само то src. Натисни с десния бутон на мишката на src и избери New от появилото се меню. След това избери Package. Това е пакет и ще разбереш неговата функция по-късно. Дай му име, с малки букви, на латиница и натисни Finish. Ще се появи новосъздадения пакет. Избери го и го натисни с десния бутон на мишката. Отново ще се появи менюто. Отново избери New. Този път на New избери Class. Избери име, което да започва с голяма буква и да е на латиница. Без празни пространства. Отдолу ще видиш опция за тикче „public static void main(String[] args)“. Натисни я, така че да се появи тикчето. Натисни Finish. Току-що създаде първия си Java файл! Пред теб трябва да стои нещо такова:",
        "s22cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}",
        "s23p": "Редактирай го, така че да стане:",
        "s24cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Здравей свят!\");\n\t}\n\n}",
        "s25p": "Горе намери зелена, кръгла иконка с триъгълник вътре. Натисни я. Натисни OK, ако те пита нещо. Ще се отвори конзола долу. На нея трябва да пише „Здравей свят!“. Пусна първия си код. Браво!",
        "s19ds2": "IDEA",
        "s26p": "Трябва да инсталираш IDEA. Отиди на следния сайт - https://www.jetbrains.com/idea/download/.",
        "s27p": "и натисни Download бутона под Community текста. Ще започне изтеглянето на файла. След това го стартирай и изпълни инструкциите за инсталация.",
        "s28p": "Стартирай програмата. Възможно е да те пита няколко въпроса за режима (светъл или тъмен).",
        "s29p": "Ще ти излезе меню. Избери New Project. В ляво се увери, че е избранa Java. От менюто в дясно избери Project SDK. Ще ти излезе списък. Натисни Download JDK. Натисни Download на новото меню. Това ще изтегли Java вместо теб, автоматично. Натисни Next долу вдясно. Натискай Next докато се появи менюто с Project name. Напиши име на проекта си, на латиница, без празни места. Натисни Finish. Проектът ще се отвори. Вляво ще видиш няколко неща. Интересуваш се от папката src. Натисни с десния бутон на мишката на src и избери New от появилото се меню. След това избери Package. Това е пакет и ще разбереш неговата функция по-късно. Дай му име, с малки букви, на латиница и натисни Enter. Ще се появи новосъздадения пакет. Избери го и го натисни с десния бутон на мишката. Отново ще се появи менюто. Отново избери New. Този път на New избери Java Class. Избери име, което да започва с голяма буква и да е на латиница. Без празни пространства. Натисни Enter, за да го завършиш. Току-що създаде първия си Java файл! Пред теб трябва да стои нещо такова:",
        "s30cj": "package hello;\n\npublic class Hello {\n}",
        "s31p": "Редактирай го, така че да стане:",
        "s32cj": "package hello;\n\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Здравей свят!\");\n    }\n}",
        "s33p": "Натисни с десния бутон на мишката върху текста. Ще се отвори меню. От него избери Run.",
        "s34p": "Ще се отвори конзола долу. На нея трябва да пише „Здравей свят!“. Пусна първия си код. Браво!",
        "s35t": "Интересно: Забележи текста над „Здравей свят!“. Това е командата нужна за пускане на кода. Започва с пътя към Java. След това има други настройки и пътя към файла, който си пуснал. IDE ти спестява да пишеш нещо такова, за да стартираш файл.",
        "s19ds3": "Visual Studio",
        "s36w": "Visual Studio към момента на писане на това е наличен само за Windows",
        "s37p": "Трябва да инсталираш Visual Studio. Отиди на следния сайт -https://visualstudio.microsoft.com/downloads/",
        "s38p": "и натисни Free Download бутона под Community текста. Ще се изтегли файла. Пусни го. Натискай Continue, докато се появи меню със заглавие Workloads. Избери .Net desktop development. По-късно можеш да инсталираш и други пакети. Натисни Install. Чакай да приключи инсталацията. Възможно е да се поиска рестартиране на компютъра. Извърши го. След това стартирай Visual Studio. Ще ти бъдат зададени въпроси за режима (светъл или тъмен). Избери както искаш. След това ще се появи меню. Вдясно избери опцията Create a new project. Менюто ще се промени на такова със заглавие Create a new project. При менюто на езиците (първи правоъгълник горе вдясно) избери C#. Долу избери Console App (.NET Core). Натисни Next. Избери име на проекта при Project Name. То да е на латиница и да започва с главна буква, без празни пространства. Натисни Create. Ще се отвори нов проект. В него ще е отворен файл Program.cs. Намери файла вляво. Натисни с десен бутон на мишката. Ще се появи меню. Натисни Delete и след това OK. Натисни името на проекта вляво и го натисни с десния бутон на мишката. Натисни Add от менюто и после натисни New item. Ще се появи меню. Избери Class. Долу напиши име, на латиница, започващо с главна буква, без празни пространства. Трябва да завършва на .cs, тоест не редактирай разширението. Натисни Add. Ще се появи нещо подобно:",
        "s39cc": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n    }\n}",
        "s40p": "Редактирай го, така че да стане:",
        "s41cc": "using System;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Здравей свят!\");\n        }\n    }\n}",
        "s42p": "Горе трябва да има правоъгълник с името на проекта и зелен триъгълник. Натисни го и избери името на проекта. Ще се отвори конзолата в черен прозорец. На нея трябва да пише „Здравей свят!“. Пусна първия си код. Браво!"
    },
    "l9": {
        "title": "Урок 9",
        "text": "където ще видиш код за първи път",
        "p1p": "В миналия урок принтирахме към конзолата. Всяка програма има main метод („главен“). Какво е метод, ще разбереш по-късно. Програмата винаги стартира от него. Тоест, ние ще пишем кода си вътре.",
        "p2ds1": "Java",
        "s3cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\t// Пишем кода си тук\n\t}\n\n}",
        "s2ds2": "C#",
        "s4cc": "using System;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n        static void Main(string[] args)\n        {\n            // Пишем кода си тук\n        }\n    }\n}",
        "p5p": "„//“ означава коментар. Когато го напишем на ред в програмата, остатъка от този ред вече не е код; той е коментар, който програмата не чете. През компилацията той се изтрива. Идеята е да можеш да обясниш какво прави дадено парче код до самия код. Запомни, с коментар не описвай какво си направил – това е очевидно, независимо дали четеш файл или махаш последния символ на файл. В коментар описвай защо си направил нещото – четеш файл, за да заредиш настройки, или махаш последния символ, за да не причиниш грешка. Това са неочевидни неща.",
        "p6pc": "/* Това пък е коментар на няколко реда. Той не приключва до поява на */",
        "p7w": "В края на всеки ред код се записва точка и запетая - „;“",
        "p8p": "Освен това си забелязал {} – тези скоби означават нов блок код. Забележи, че всеки блок код отива по-навътре в полето – или с един tab, или с три празни пространства. В Java, когато започва нов блок, пишем отварящата скоба { на предния ред. При C# е на следващия. Забележи, че и на двете места има main (string[] args). Важно е да се отбележи, че в Java main е с малка буква, а String – с голяма, а в C# е обратното. Това нещо „args“ съдържа аргументите дадени на програмата от конзолата. Помниш ли? Онези неща, които се пишеха така „-аргумент стойност“. Останалата част от кода също е нужна за функциониране на програмата. Да видим как се принтира на конзолата в двата езика:",
        "p9ds1": "Java",
        "s9cj": "System.out.println() // Това принтира и след това оставя един ред – идва от print line – принтирай ред\nSystem.out.print() // Това принтира, но не оставя един ред. System.out.println() използва това, \n//само че добавя един символ „\\n“, накрая, за да покаже нов ред. Спомняш ли си, че това беше символа за нов ред?",
        "s10p": "Ето го нагледно:",
        "s11cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(„Как си?“);\n\t\tSystem.out.print(„Добре. “);\n\t\tSystem.out.println(„А ти как си от 1 до 10?“);\n\t\tSystem.out.print(5);\n\t\tSystem.out.print(„И по-добри дни съм имал“);\n\n\t}\n\n}",
        "s9ds2": "C#",
        "s12cc": "Console.WriteLine() // Това принтира и след това оставя един ред – идва от write line – напиши ред\nConsole.Write() // Това принтира, но не оставя един ред. Console.WriteLine() използва това, \n//само че добавя един символ „\\n“, накрая, за да покаже нов ред. Спомняш ли си, че това беше символа за нов ред?",
        "s13p": "Ето ги нагледно:",
        "s14cc": "using System;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n        static void Main(string[] args)\n        {\n\t\tConsole.WriteLine(„Как си?“);\n\t\tConsole.Write(„Добре. “);\n\t\tConsole.WriteLine(„А ти как си от 1 до 10?“);\n\t\tConsole.Write(5);\n\t\tConsole.Write(„И по-добри дни съм имал“);\n\n        }\n    }\n}",
        "p15p": "Резултат в конзолата:",
        "p16con": "<<output>>Как си?\n<<output>>Добре. Ти как си от 1 до 10?\n<<output>>5И по-добри дни съм имал",
        "p17p": "Забелязваш сливането на последния ред. Можеш ли да го обясниш?",
        "p18p": "Това е принтирането на конзолата. Сега трябва да говорим за променливите. Променливите имат свойството да се променят. Във всеки несатиричен програмен език има променливи. Те са как се използва паметта. Винаги следват следната формула:",
        "p19pc": "num = 5; //num идва от number / число",
        "p20p": "След това, напред в кода, num може да се използва. Например:",
        "p21pc": "print(num); // В този език, приеми, че принтирането става с print  – това би принтирало 5\n//самата практика се нарича псевдокод – код, който не е на никой език, а вместо това обединява няколко за по-лесно писане и обяснение",
        "p22p": "Тук num е името, а 5 е стойността",
        "p23p": "Променливите се именуват по различен начин от език на език, но почти винаги следват определени правила:",
        "p24p": "Имената винаги са една дума",
        "p25p": "Имената не могат да съдържат друго освен букви, цифри и „_“ или „-“",
        "p26p": "Думи, които езикът използва (например class), не може да са променливи",
        "p27p": "Името на променлива не може да започва с число – обяснението за това е просто - ако може да започва с цифра, името може да е число. Това може да породи ситуация от рода на:",
        "p28pc": "6 = 5",
        "p29p": "И после, ако имаме print(6);, езика ще се чуди дали да принтира 6 или 5. Тоест, това просто не се позволява.",
        "p30p": "Освен това има и някои стандарти за именуване.",
        "p31p": "В Java и C#, повечето променливи се именуват с camelCase (камилов тип). При него първата буква от първата дума е малка, а първата буква на всяка следваща дума е главна и всички думи са слети. Например:",
        "p32pc": "имеНаПроменливаВКамиловТип = 5;",
        "p33p": "За някои други неща (като класовете) се ползва PascalCase (Паскалов тип). При него първата буква от всяка дума е главна и всички думи са слети. Например:",
        "p34pc": "ИмеНаПроменливаВПаскаловТип = 5;",
        "p35p": "Има и snake_case (змийски тип). При него всички букви са малки и всяка дума е отделена от долна черта - „_“. Например:",
        "p36pc": "име_на_променлива_в_змийски_тип = 5;",
        "p37e": "Тук пиша имената на кирилица, за да са по-лесни за четене, но когато програмираш, винаги използвай само латиница!",
        "p38p": "Освен това, винаги давай значими имена на променливите. След компилацията така или иначе ще са по няколко случайни букви, така че в оригинал ги пиши обяснителни:",
        "p39p": "Най-вероятно не е добра идея да именуваш така:",
        "p40pc": "r = 5; // това се предполага, че е радиус на кръг",
        "p41p": "Ще е по-четимо така:",
        "p42pc": "radiusCircle = 5;",
        "p43p": "Така следващ човек, или ти самият, веднага ще знае, че това е радиус на кръг, а не на пирамидите в Гиза",
        "p44p": "Трябва да ти кажа и за типовете на променливите. Това, което гледа досега е „общ“ език. В него променливите сами знаят какво съдържат. Но в Java и C# това не е така. Всяка променлива има тип. Типът определя какъв вид информация ще съдържа променливата. Това осигурява, че няма да опитаме да съхраним в една променлива и текст, и по-късно число. Първия тип, който ще учим е Integer (целочислен тип) – или съкратено, както е и в езиците – int. Целочисления тип съдържа цели числа – 56 е цяло число, тоест може да бъде такава променлива, но 56.78 не е.",
        "p45p": "int е с големина 4 байта в почти всеки език. 4 байта е 32 бита, тоест най-големия възможен int би трябвало да е 4,294,967,295. Първия от тези битове обаче се запазва за знака – „+“ или „-“. Тоест int може да съдържа числа от -2,147,483,648 до 2,147,483,647.",
        "p46p": "Освен int има и два други целочислени типа – short и long – от „къс“ и „дълъг“ на английски. short има два байта – 16 бита. Първия е знак, тоест short може да съдържа числата между -32,768 и 32,767. long на своя страна е дълъг – има цели 8 байта – 64 бита. Дори и с първия си бит използван за знак, той може да съдържа числата между -9,223,372,036,854,775,808 и 9,223,372,036,854,775,807.",
        "p47p": "Прието е да се използва int, освен ако не си сигурен, че имаш малки числа – тогава се ползва short. Ако пък имаш неадекватно големи числа се използва long.",
        "p48p": "В някои езици има и така наречените „беззнакови“ типове („unsigned“). Те обикновено се записват като uint, ushort, ulong. При тях първия бит не се ползва за знак, тоест uint може да съдържа числата от 0 до 4,294,967,295. Тях няма да ги обсъждаме повече, но е хубаво да знаеш, че ги има.",
        "p49tq": "int е голям:",
        "p49a1": "1 байт",
        "p49a2": "4 бита",
        "p49a3": "4 байта",
        "p49a4": "8 байта",
        "p50p": "Сега да преминем към кода:",
        "p51pc": "int num = 5; // Така се създава променлива с целочислен тип. Типът е преди името на променливата\nint num = 5.56 // Това би ни дало грешка, защото 5.56 не е целочислено число.\n// Ако сме създали int num = 5;, по-късно можем да го променяме. Като го променяме не записваме типа.",
        "p52ds1": "Java",
        "s53cj": "int num = 5; // Създаваме / инициализираме променливата\nint secondNum = num; // Променливите може да са равни и на други променливи и взимат моментната им стойност\nSystem.out.println(num);\nnum = 6; // Променяме стойността на променливата. Не се записва типът.\nSystem.out.println(num);\nSystem.out.println(secondNum);",
        "s52ds2": "C#",
        "s54cc": "int num = 5; // Създаваме / инициализираме променливата\nint secondNum = num; // Променливите може да са равни и на други променливи и взимат моментната им стойност\nConsole.WriteLine(num);\nnum = 6; // Променяме стойността на променливата. Не се записва типът.\nConsole.WriteLine(num);\nConsole.WriteLine(secondNum);",
        "p55p": "Резултат в конзолата:",
        "p56con": "<<output>>5\n<<output>>6\n<<output>>5",
        "p57p": "Ако запишем типа докато променяме стойността, програмният език ще реши, че създаваме нова променлива. След това ще види, че вече има променлива с такова име и ще ни даде грешка.",
        "p58e": "Всяка променлива в един блок код трябва да има уникално име спрямо всяка променлива над нея.",
        "p59p": "Например:",
        "p60pc": "int num = 5; // Създаваме / инициализираме променливата\nint num = 6; // Грешката е тук – ще получим грешка, че вече има такава променлива – програмата ще спре, или „крашне“.",
        "p61p": "По същия начин се създават и другите типове:",
        "p62pc": "short shortNum = 1;\nlong  longNum = 900000000000; //Обикновено не се позволяват и разделители на групи в число; 9,000,000 би причинило грешка.",
        "p63p": "Освен това, можем да създаваме няколко променливи с еднакъв тип на един ред по следния начин:",
        "p64pc": "int x = 5, y = 6;",
        "p65p": "Даденият код създава две променливи цели числа x и y, като x има стойност 5, а y има стойност 6."
    },
    "l10": {
        "title": "Урок 10",
        "text": "където ще научиш какво е реално число",
        "p1p": "Време е за следващите два типа. Те ти позволяват да съхраняваш и нецели числа – например 9.76, 6.78. Това са float и double.",
        "p2p": "Името float идва floating point – „плаваща точка“. Тоест, точката която е в дробните числа. Голям е 4 байта. double („двоен“) го запомнете като това, че е двойно по-голям от float – 8 байта.",
        "p3p": "Когато в код запишеш дробно число, то се възприема като double. Трябва да добавиш „f“ в края му, за да стане float.",
        "p4p": "Примери в код:",
        "p5pc": "float num = 5.67; // Получаваш грешка, че не може да дадеш на тип float стойност от тип double\nfloat num = 5.67f; // Това не дава грешка.",
        "p6pc": "double num = 5.67; // Не получаваш грешка",
        "p7p": "Подобно на int и тези типове могат да се принтират в конзолата:",
        "p8ds1": "Java",
        "s9cj": "float num = 5.68f;\ndouble otherNum = 5.67;\nSystem.out.println(num);\nSystem.out.println(otherNum);",
        "s8ds2": "C#",
        "s10cc": "float num = 5.68f;\ndouble otherNum = 5.67;\nConsole.WriteLine(num);\nConsole.WriteLine(otherNum);",
        "p11p": "Резултат:",
        "p12con": "<<output>>5.68\n<<output>>5.67",
        "p13tq": "double или float може да съдържа повече битове информация?",
        "p13a1": "double",
        "p13a2": "float",
        "p14rq": "Потърси как да присвоиш double на float в твоя език. Пробвай с Интернет или напиши грешния код в твоето IDE и виж какви стъпки за поправка ти се предлагат, когато поставиш мишката си на червената линия, показваща грешка."
    },
    "l11": {
        "title": "Урок 11",
        "text": "където ще научиш как се събират и изваждат числа… още веднъж",
        "p1p": "В програмните езици има така наречените „експресии“ или изрази. Изразите винаги достигат до даден тип променлива, независимо дали са аритметични операции или логически сравнения. Където може да се постави променлива от даден тип, може да се постави и израз, който стига до нея. Днес ще разгледаме един от типовете изрази – аритметичните операции.",
        "p2h": "Събиране",
        "p3p": "Можем да събираме две целочислени числа (int). Получаваме друг int.",
        "p4pc": "int intSbor = 5 + 4;\nprint(intSbor);",
        "p5p": "Резултат:",
        "p6con": "<<prefix>>>>9",
        "p7p": "Можем да събираме две числа от тип float или double:",
        "p8pc": "float floatSbor = 5.67f + 2.33f;\ndouble doubleSbor = 5.67 + 2.33;",
        "p9p": "Можем също и да събираме две променливи от един тип:",
        "p10pc": "int edno = 5;\nint dve = 6;\nint tri = edno + dve;\nprint(tri);",
        "p11p": "Резултат:",
        "p12con": "<<prefix>>>>11",
        "p13p": "Ако извършим каквото и да е аритметично действие върху две числа, съответно float и double, резултатът е с тип double (floatSbor и doubleSbor са създадени / декларирани по-горе):",
        "p14pc": "float floatDoubleSbor = floatSbor + doubleSbor; // Това ще даде грешка\ndouble floatDoubleSbor = floatSbor + doubleSbor; // Всичко е наред тук",
        "p15p": "Същата логика се следва и при операции между int и float или int и double – крайният резултат винаги е float или double:",
        "p16pc": "int intFloatSbot = intSbor + floatSbor; // Това ще даде грешка\nfloat floatDoubleSbor = intSbor + floatSbor; // Всичко е наред тук",
        "p17p": "Можем да поставяме колкото си искаме аритметични действия едно след друго:",
        "p18pc": "int sbor = 5 + 6 + 7 + 8 + 9 + 10 + 11;\nprint(sbor);",
        "p19p": "Резултат:",
        "p20con": "<<prefix>>>>56",
        "p21tq": "Резултатът от „5 + 6.5f + 5.12“ би бил от тип:",
        "p21a1": "int",
        "p21a2": "short",
        "p21a3": "float",
        "p21a4": "double",
        "p21p": "Аритметичните действия могат да се извършват на много различни места. Например:",
        "p23pc": "print(5+6+7);",
        "p24p": "Резултат:",
        "p25con": "<<prefix>>>>18",
        "p26h": "Изваждане",
        "p27pc": "int razlika = 6 – 5;\nprint(razlika);",
        "p28p": "Резултат:",
        "p29con": "<<prefix>>>>1",
        "p30p": "Може разликата в изваждане да е и отрицателно число:",
        "p31pc": "int otricatelnaRazlika = 5 - 6;\nprint(razlika);",
        "p32p": "Резултат:",
        "p33con": "<<prefix>>>>-1",
        "p34p": "Същите правила за действия между типове се прилагат.",
        "p35h": "Умножение",
        "p36p": "Умножението в програмирането се извършва със звездичката („*“):",
        "p37pc": "int proizvedenie = 5 * 6;\nprint(proizvedenie);",
        "p38p": "Резултат:",
        "p39con": "<<prefix>>>>30",
        "p40p": "Трябва да се отбележи, че програмните езици обикновено следват подредбата на действията (скоби -> умножение и деление -> събиране и изваждане):",
        "p41pc": "int izraz = (10 – 5*2)*6;\nprint(izraz);",
        "p42p": "Резултат:",
        "p43con": "<<prefix>>>>0",
        "p44p": "Тук първо се пресмята израза в скобите: 10 – 5*2. В него, първо се извършва умножението (5*2) и след това извждането (10 - 10). Изразът става 0 * 6, което е 0.",
        "p45pc": "int izrazSusSkobi = ((10 – 5)*2)*6;\nprint(izrazSusSkobi);",
        "p46p": "Резултат:",
        "p47con": "<<prefix>>>>60",
        "p48p": "Тук първо се пресмята израза в скобите: (10-5)*2, което е 5*2 = 10. След това 10 * 6 е равно на 60.",
        "p49p": "Същите правила за действия между типове се прилагат.",
        "p50tq": "Резултатът от „10*(6-5)“ е:",
        "p50a1": "10",
        "p50a2": "0",
        "p50a3": "55",
        "p50a4": "-44",
        "p50h": "Деление",
        "p52p": "Делението в програмирането е специфично според типа:",
        "p53pc": "int chastno = 6 / 2;\nprint(chastno);",
        "p54p": "Резултат:",
        "p55con": "<<prefix>>>>3",
        "p56p": "Това е очакваното: 6/2 е 3",
        "p57p": "Проблемът е, когато имаме деление, при което има остатък. Например 8/3. Тък като резултатът от това е грубо 2.66, а знаем, че в int може да има само цели числа, резултатът се запазва като 2:",
        "p58pc": "int chastnoSOstatuk = 8 / 3;\nprint(chastnoSOstatuk);",
        "p59p": "Резултат:",
        "p60con": "<<prefix>>>>2",
        "p61pc": "int drugoChastno = chastno / chastnoSOstatukl; // 3 / 2\nprint(drugoChastno);",
        "p62p": "Резултат:",
        "p63con": "<<prefix>>>>1",
        "p64p": "Ако имаме обаче float или double, получаваме очаквания резултат:",
        "p65pc": "float chastnoFloat =  8f / 3f;\nprint(chastnoFloat);",
        "p66p": "Резултат:",
        "p67con": "<<prefix>>>>2.6666667",
        "p68p": "Чакай… Какво?",
        "p69p": "Резултатът трябва да е 2.66. Ама не е. Оказва се, че компютрите и двоичната система не са много добри в точното представяне на дробни числа. Затова понякога има подобни грешки. Не се притеснявай – случват се често и няма специфичен начин да ги оправиш.",
        "p70p": "Същите правила за действия между типове се прилагат.",
        "p71tq": "Резултатът от 28 / 9, ако и двете числа са от тип int, е:",
        "p71a1": "3",
        "p71a2": "4",
        "p71a3": "1",
        "p71a4": "2",
        "p71h": "Деление с остатък",
        "p73p": "Делението с остатък, или модуло, е една операция която не се среща особено често в нормалната математика, но е полезна в програмирането. Тя се отбелязва с „%“ и връща само остатъкът на делението:",
        "p74pc": "int chastno = 9 / 2;\nprint(chastno);",
        "p75p": "Резултат:",
        "p76con": "<<prefix>>>>1",
        "p77p": "Можем да видим, че остатъкът от това деление е 1 – 8 се дели на 2, 9 не се. Следователно 9/2 би било 4, а 9%2 е 1. Това действа по-същия начин и при float и double.",
        "p78p": "Същите правила за действия между типове се прилагат.",
        "p79tq": "Резултатът от 28 % 9, ако и двете числа са от тип int, е:",
        "p79a1": "3",
        "p79a2": "4",
        "p79a3": "1",
        "p79a4": "2",
        "p79h": "Манипулации с 1",
        "p81p": "Много често в програмирането се налага да добавиш или извадиш 1 от число. Но понякога това е малко дълго. Например:",
        "p82pc": "int num = 2;\nnum = num + 1;\nprint(num);",
        "p83p": "Резултат:",
        "p84con": "<<prefix>>>>3",
        "p85p": "или",
        "p86pc": "int num = 3;\nnum = num - 1;\nprint(num);",
        "p87p": "Резултат:",
        "p88con": "<<prefix>>>>2",
        "p89p": "А пък програмистите са мързеливи хора. Затова са измислени операторите за манипулация с едно – „++“ и „--“. Нека да ги тестваме:",
        "p90pc": "int num = 2;\nnum++;\nprint(num);",
        "p91p": "Резултат:",
        "p92con": "<<prefix>>>>3",
        "p93p": "или",
        "p94pc": "int num = 3;\nnum--;;\nprint(num);",
        "p95p": "Резултат:",
        "p96con": "<<prefix>>>>2",
        "p97p": "Това е лесно. Проблема идва от това къде се поставят – може и преди и след променливата. Разликата, е че преди променливата първо се извършва оператора за манипулация с 1, а после другите действия. Ако е след това, първо се извършват другите действия, а след това - оператора за манипулация с 1. Дай направо да ти покажа:",
        "p98pc": "int num = 5;\nint num1 = 6;\nint num2 = num++ + num1; // Тук първо ще се извърши num + num1, тоест 5+6, което ще е 11\n// Съответно num2 ще стане 11. След това ще се извърши num++, където num ще стане 6\nprint(num);\nprint(num2);",
        "p99p": "Резултат:",
        "p100con": "<<prefix>>>>6",
        "p101con": "<<prefix>>>>11",
        "p102pc": "int num = 5;\nint num1 = 6;\nint num2 = num + ++num1; // Тук първо ще се извърши ++num1, тоест то ще стане 7\n// След това ще се извърши с num + num1 или 5+7 с резултат 12 \nprint(num1);\nprint(num2);",
        "p103p": "Резултат:",
        "p104con": "<<prefix>>>>7",
        "p105con": "<<prefix>>>>12",
        "p106p": "Дали ще ти се наложи да ползваш това като информация някога? Може би. Обикновено е добре просто да ползваш num++ на следващия ред или на предния, за да няма обърквания. Защо го включвам тук тогава? Защото е адски лесно да се направи въпрос за това на всеки изпит, следователно го има на всеки изпит.",
        "p107pc": "int num = 5;\nint num1 = 6;\nint num2 = 7;\nint num3 = num + num1++ + --num2;",
        "p108tq": "След извършената по-горна операция, num3 е равно на:",
        "p108a1": "17",
        "p108a2": "16",
        "p108a3": "19",
        "p108a4": "18",
        "p108exp": "Обяснение: първо се извършва –-num2, където num2 става 6. След това се случва събирането num + num1 + num2, което е равно на 5 + 6 + 6, тоест 17. Накрая се случва num1++, където num1 става 7.",
        "p110h": "Bitwise оператори",
        "p111p": "Bitwise („битуайз“) операторите са едно от най-големите възможни обърквания. Много е възможно да ги срещнеш някъде, но се моли това да не се случва (върху числа, има други ползи в някои езици, които са далеч по-практични).",
        "p112p": "Bitwise операторите са „<<“, „>>“, „|“, „&“, „^“, „~“. Те манипулират числата като битове.",
        "p113p": "<< и >> са така наречените шифтове. Те местят дадено число битовете към една страна. Например:",
        "p114pre": "10011100 << 1 е равно на 00111000",
        "p115pre": "10011100 >> 1 е равно на 01001110",
        "p116p": "Това може да има огромни ефектни – в първия пример 10011100 е 156, а след „<< 1“ 00111000 е равно на 56. Ефектите са почти непредвидими, а ползите малки.",
        "p117h": "|",
        "p118p": "„Логическото или“ е операция между две двоични числа, която действа така:",
        "p119pre": "\n0101 -> първо число\n0111 -> второ число\n0111 -> резултат",
        "p120p": "Тоест, ако на позиция има 1 и 0 се записва 1. Ако има два пъти 2 се записва 1. Ако има два пъти 0 се записва 0.",
        "p121h": "&",
        "p122p": "„Логическото и“ е операция между две двоични числа, която действа така:",
        "p123pre": "\n0101 -> първо число\n0111 -> второ число\n0101 -> резултат",
        "p124p": "Подобно на логическото или, само че 0 и 1 е 0. Тоест единствената ситуация, при която записваме 1 при 2 единици.",
        "p125h": "^",
        "p126p": "„Логическото ксор“ е операция между две двоични числа, която действа така:",
        "p127pre": "\n0101 -> първо число\n0111 -> второ число\n0010 -> резултат",
        "p128p": "Тук единствената ситуация, в която записваме 1 е когато двете числа са различни – 0 и 1.",
        "p129h": "~",
        "p130p": "Това е „комплимента“. При него резултатът от ~0101 е 1010 – тоест просто обръща битовете – при 1 има 0 и при 0 има 1."
    },
    "l12": {
        "title": "Урок 12",
        "text": "където ще разбереш защо учи кодирания на символи",
        "p1p": "Скоро идва времето, в което ще се научиш да запазваш текст. Преди това обаче, трябва да можеш да запазваш единични символи. В този урок ще се занимаваме с типа char.",
        "p2p": "char идва от character – „символ“ и запазва един единствен символ. Ето така:",
        "p3pc": "char a = ‘a’;",
        "p4w": "Символът се записва в единични кавички – ' '. Текстът се записва в нормални, а char може да има само един символ.",
        "p5p": "Това само по себе си не е много интересно – char запазва един символ. Но, спомни си какво казахме в урока за кодиране – всеки един символ се приема като число от компютъра. Това води до някои интересни неща – ‘a’ е по-малко от ‘b’. И ни позволява да извършваме аритметични действия върху символи:",
        "p6pc": "char a = 'a';\nchar b = 'b';\nint c = 'a' - 'b';\nprint(c);",
        "p7p": "Резултат:",
        "p8con": "<<prefix>>>>-1",
        "p9p": "Тук знаем, че според подреждането на символите, b е с едно по-голямо от a. Тоест ако извадим b от а, получаваме -1.",
        "p10p": "Можем също да присвояваме цели числа на char и да получим съответния им символ. Според повечето кодирания, ‚a‘ е числото 97. Тоест, можем да направим това:",
        "p11pc": "char aChar = 97;\nprint(aChar);",
        "p12p": "Резултат:",
        "p13con": "<<prefix>>>>a",
        "p14p": "Още повече – можем да използваме и операторите за манипулация с 1:",
        "p15pc": "char aChar = 97;\naChar++;\nprint(aChar);",
        "p16p": "Резултат:",
        "p17con": "<<prefix>>>>b",
        "p18tq": "Върху char можем да използваме:",
        "p18a1": "оператори за манипулация с 1",
        "p18a2": "събиране",
        "p18a3": "изваждане",
        "p18a4": "всички от гореизброените",
        "p19p": "Това беше char. Отвори твоето IDE, ако още не си го, и си поиграй с новите неща. Възможностите за тестване на неща са големи. Късмет!"
    },
    "l13": {
        "title": "Урок 13",
        "text": "където ще научиш как се запазва текст"
    },
    "l14": {
        "title": "Урок 14",
        "text": "където ще научиш общото между библиотеките и компютрите"
    },
    "l15": {
        "title": "Урок 15",
        "text": "където ще научиш как се ползва конзолата… от другата страна"
    },
    "t2": {
        "title": "Тест 2",
        "text": "където ще провериш способността си да запазваш информация"
    },
    "l16": {
        "title": "Урок 16",
        "text": "където ще научиш как се сравнява"
    },
    "l17": {
        "title": "Урок 17",
        "text": "където ще научиш как се сравнява…  няколко пъти на веднъж"
    },
    "l18": {
        "title": "Урок 18",
        "text": "където ще научиш как се контролира програма"
    },
    "l19": {
        "title": "Урок 19",
        "text": "където ще научиш как да пишеш проверки"
    },
    "t3": {
        "title": "Тест 3",
        "text": "където ще провериш способността си да контролираш кода"
    },
    "l20": {
        "title": "Урок 20",
        "text": "където ще научиш как програмите не се затварят веднага"
    },
    "l21": {
        "title": "Урок 21",
        "text": "където ще научиш как се брои"
    },
    "t4": {
        "title": "Тест 4",
        "text": "където ще провериш способността си да повтаряш"
    },
    "l22": {
        "title": "Урок 22",
        "text": "където ще научиш как да работиш с много информация"
    },
    "l23": {
        "title": "Урок 23",
        "text": "където ще разбереш връзката между последните уроци"
    },
    "l24": {
        "title": "Урок 24",
        "text": "където ще научиш как да сортираш… и как да не го правиш"
    },
    "l25": {
        "title": "Урок 25",
        "text": "където ще научиш че измеренията са повече от едно"
    },
    "t5": {
        "title": "Тест 5",
        "text": "където ще провериш способността си да работиш с много информация"
    },
    "l26": {
        "title": "Урок 26",
        "text": "където ще научиш как да организираш програмата си"
    },
    "l27": {
        "title": "Урок 27",
        "text": "където ще научиш как да не се повтаряш"
    },
    "l28": {
        "title": "Урок 28",
        "text": "където ще научиш че методите са навсякъде"
    },
    "t6": {
        "title": "Тест 6",
        "text": "където ще провериш колко си организиран"
    },
    "l29": {
        "title": "Урок 29",
        "text": "където ще научиш защо името е софтуерно инженерство"
    },
    "l30": {
        "title": "Урок 30",
        "text": "където ще научиш кaк да контролираш достъпа"
    },
    "l31": {
        "title": "Урок 31",
        "text": "където ще научиш, че има и непроменливи"
    },
    "l32": {
        "title": "Урок 32",
        "text": "където ще научиш какво е наследството"
    },
    "l33": {
        "title": "Урок 33",
        "text": "където ще научиш, че интерфейсите не са само графични"
    },
    "l34": {
        "title": "Урок 34",
        "text": "където ще се научиш да запазваш, без да знаеш какво"
    },
    "l35": {
        "title": "Урок 35",
        "text": "където ще научиш как да не използваш магия"
    },
    "t7": {
        "title": "Тест 7",
        "text": "където ще провериш знанията си за софтуерната архитектура"
    },
    "l36": {
        "title": "Урок 36",
        "text": "където ще научиш как да си оправяш грешките"
    },
    "l37": {
        "title": "Урок 37",
        "text": "където ще научиш как да правиш няколко неща едновременно"
    },
    "l38": {
        "title": "Урок 38",
        "text": "където ще научиш как да направиш живота си по-лесен... или поне кода"
    },
    "l39": {
        "title": "Урок 39",
        "text": "където ще научиш как да пътуваш назад във времето"
    },
    "l40": {
        "title": "Урок 40",
        "text": "където ще научиш как да използваш Интернет"
    },
    "l41": {
        "title": "Урок 41",
        "text": "където ще научиш опциите си"
    },
    "t8": {
        "title": "Тест 8",
        "text": "където ще се тестваш сам"
    },
    "l42": {
        "title": "Урок 42",
        "text": "където ще те изпратя"
    }
}