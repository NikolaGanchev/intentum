{
  "l0": {
    "p1p": "Здравей!",
    "p2p": "Аз съм автора на Интентум. Моята цел е до края на този \"курс\" да имаш всички нужни знания в информатиката и програмирането, за да можеш да продължиш да учиш сам. \"Курсът\" е разделен на 42 урока (без урок 0) и 8 теста. Това би трябвало да обхваща всичко нужно за един старт в програмирането и да покрива целия материал по информатика от 8-ми до 12-ти клас, без да отнема 5 години. Всеки урок има тематично заглавие, което показва какво ще правиш в него.",
    "p3p": "Уроците не са сложни и са максимално опростени - вярвам, че всеки може да се научи да програмира, ако обяснението е лесно. Аз самият започнах от една книга за програмирането на английски, от която почти нищо не разбрах. А на български почти няма източници. Един ден, някой ме попита \"Ти как се научи?\". Аз започнах да се оплаквам, че няма какво да му препоръчам, и изведнъж ми хрумна идеята сам да направя нещо, което да мога да препоръчам. И ето ме тук сега.",
    "p4p": "За да отключиш урок, трябва да прeминеш предния, или да натиснеш ключалката, която се намира на мястото на старт бутона. Аз обаче не препоръчвам да се пропускат уроци. Идеята на отключването е да можеш да си на едно ниво, и на компютър, и на телефон, без да се налагат профили (и съответно, връзка с Интернет) - не да пропускаш важен материал.",
    "p5p": "Уроците си имат и секции, като на края на всяка секция има въпрос и ключалка, криеща по-долния материал. Въпросите са за самопроверка - независимо как отговориш, следващата секция ще се разкрие. Твоя е задачата да прецениш дали не ти трябва още един прочит!",
    "p6p": "Казах, че има и 8 теста. Не се плаши! Независимо какво направиш на тест, продължаваш към следващия урок. Тестовете също са за самопроверка - да установиш собственото си ниво и да прецениш дали трябва да продължиш или да се върнеш назад.",
    "p7p": "Както забелязваш, особено важна е самопроверката. Колкото ти разчиташ на мен, че има лесни и добре написани уроци, толкова и аз разчитам на теб сам да осъзнаваш кога трябва да наблегнеш на нещо. Желание се изисква и от двете страни.",
    "p8p": "В момента може да си представяш програмирането като някаква древна магия, използваема единствено от наследниците на Айнщайн или тези, които решават кубични уравнения на салфетки, пишейки с кал, докато изкачват Мусала. Това не е така и дори не се изисква да си особено добър математик. Предполагам обаче, че мога да ти докажа това само по един начин.",
    "p9p": "Засега това е от мен. Ще се срещнем отново в следващия урок. Пожелавам ти късмет!",
    "text": "Където ще се запознаем",
    "title": "Урок 0"
  },
  "l1": {
    "p10p": "156 = 1 * 10^2 + 5 * 10^1 + 6*1",
    "p11p": "Аз обаче мога да ти кажа, че между всички три множителя има връзка - 100, 10 и 1. И трите всъщност са степени на 10. И в момента, може да се сетиш за нещо, което ти е било казано преди дълго време - което и да е число, повдигнато на степен 0, е 1. Тоест, 10^0 е 1. Сега получаваме:",
    "p12p": "156 = 1 * 10^2 + 5 * 10^1+ 6*10^0",
    "p13p": "Добре, значи да пробваме със шестцифрено число:",
    "p14p": "907 156 = 9 * 10^5+ 0 * 10^4 + 7 * 10^3 + 1 * 10^2 + 5 * 10^1 + 6*10^0",
    "p15p": "Можем да продължим още, но с всяко число ще получим нещо подобно. Изводът е, че всяко число в десетичната бройна система е равно на сбора от всичките му цифри, където всяка цифра се умножава по десет на степен позицията си. Тоест, каквото написахме горе, но в думи. Позицията на цифра се определя отдясно наляво - най-дясната цифра е 0,  всяка следваща е с 1 по-голяма. Например:",
    "p16p": "1 907 156 - Цифра",
    "p17p": "6 543 210 - Позиция",
    "p18p": "Поради факта, че цифрите тук са 10 (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) и умножаваме по степен на 10, казваме, че имаме десетична бройна система. А базата е 10.",
    "p19tq": "Каква би била базата на система с 2 цифри?",
    "p1p": "Добре дошъл/дошла в първия урок!",
    "p20fq": "Запиши на какво е равно числото 796 спрямо образеца 156 = 1 * 10^2 + 5 * 10^1 + 6*10^0, където \"^\" значи степен.",
    "p21p": "След като изяснихме това, да напуснем началното училище и да се върнем в настоящето. И тук идва истинската цел на урока: да разбереш двоичната бройна система.",
    "p22p": "На всички им е известно, че компютрите разбират само 0 и 1. Съответно, те използват бройна система, където има само две цифри - 0 и 1. Една нула или единица е бит. И базата на тази система е 2.",
    "p23p": "Само с тази информация можем да дешифрираме нулите и единиците. Например, имаме числото 010. Позициите са както следва:",
    "p24p": "210",
    "p25p": "Знаем, че ни трябва сбор от цифрите умножени по базата на степен позицията. Базата е 2, а позициите ги имаме:",
    "p26p": "010 = 0 * 2^2 + 1 * 2^1 + 0 * 2^0 = 0 * 4 + 1 * 2 + 0 * 1 = 2",
    "p27p": "Това е. Току що превърнахме числото 010 (база 2) в число в база 10 - 2. Да пробваме с нещо по-сложно - 1 байт - тоест 8 бита или с други думи, 8 цифри:",
    "p28p": "10110110 = 1 * 2^7 + 0 * 2^6 + 1 * 2^5 + 1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 1 * 2^1 + 0 * 2^0 =  1 * 128 + 0 * 64 + 1 * 32 + 1 * 16 + 0 * 8 + 1 * 4 + 1 * 2 + 0 * 1 = 128 + 32 + 16 + 4 + 2 = 182",
    "p29p": "И ето, че превърнахме в десетична бройна система и това дълго число.",
    "p2p": "Предполагам, че заглавието на урока те е изненадало и в момента се чудиш \"Как така да не са 10 цифрите? Учителят от началното училище не спря да ми го повтаря\". Е, за да ти отговоря, първо трябва да те върна във въпросното начално училище.",
    "p30fq": "Превърни 11101110 в десетична бройна система",
    "p31tq": "110 в двоична бройна система е равно на колко в десетична?",
    "p32p": "Да направим обратното и да вземем отново числото 156. Този път, няма да умножаваме по 10, а ще делим на 10 с остатък. Получаваме:",
    "p33p": "156 / 10 = 15  (15 * 10 = 150 -> остатък 6)",
    "p34p": "15 / 10 = 1 (1*10 = 10 -> остатък 5)",
    "p35p": "1 / 10 = 0 (0*10 = 0 -> остатък 1)",
    "p36p": "Забелязваме нещо. Ако вземем остатъците отдясно наляво, получаваме началното число: 156. За да направим това делим на базата (10), и получаваме число в десетична бройна система. Тогава да пробваме да делим на база 2, и може би ще получим число в двоична бройна система:",
    "p37p": "156 / 2 = 78 (остатък 0)",
    "p38p": "78  / 2 = 39 (остатък 0)",
    "p39p": "39 / 2 = 19 (ост. 1)",
    "p3p": "Тогава си учил/а числата. И когато си ги учил, са те карали да пишеш нещо подобно:",
    "p40p": "19 / 2 = 9 (ост. 1)",
    "p41p": "9 / 2 = 4 (ост. 1)",
    "p42p": "4 / 2 = 2 (ост. 0)",
    "p43p": "2 / 2 = 1 (ост. 0)",
    "p44p": "1 / 2 = 0 (ост. 1)",
    "p45p": "Значи, следвайки горната логика, получаваме числото 10011100, което изглежда в двоична бройна система (не забравяй, че четем отдясно наляво). Да направим проверка:",
    "p46p": "10011100 = 1 * 2^7 + 0 * 2^6 + 0 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0 = 1 * 128 + 0 * 64 + 0 * 32 + 1 * 16 + 1 * 8 + 1 * 4 + 0 * 1 = 128 + 16 + 8 + 4 = 156",
    "p47p": "Значи сме работили правилно!",
    "p48p": "И това е цялата двоична бройна система. Нито е прекалено сложна, нито нещо неразбираемо. Надявам се да си схванал. Въпреки това, се тествай:",
    "p49fq": "На колко е равно 238 в двоична бройна система?",
    "p4p": "56 = 5*10 + 6",
    "p50p": "Свърших с материала за урока, но още не съм обяснил откъде идва заглавието. Всъщност е просто. По същия начин, по който можем да имаме бройни системи с бази по-малки от 10, можем да имаме и такива с по-големи от 10. Една широко използвана система с по-голяма база е шестнадесетичната бройна система - с 16 цифри, тоест база 16. \"Как така?\" питаш ти и отговорът е, че цифрите са 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A (10), B (11), C (12), D (13), E (14), F (15). Използват се букви за по-големите от 9. Главно се ползва за цветове и за представяне на паметта на програми, защото не е лесно да четеш нули и единици. Например, числото EFEFEF е цвета на фона в по-голямата част на приложението. В десетична система това е 15 724 527, и виждаш че EFEFEF е сравнително по-лесно за изписване - има практическа полза.",
    "p51rq": "Избери си цвят и потърси числото му в база 16 в Интернет, като имаш предвид, че тези записи на цветове много често се наричат и hex, или хексове.",
    "p5p": "Има логика. Да пробваме с трицифрено число:",
    "p6p": "156 = 1*100 + 5*10 + 6",
    "p7p": "Нека да запишем това в пълния му вариант - в крайна сметка, 6 всъщност се умножава по 1:",
    "p8p": "156 = 1*100 + 5*10 + 6*1",
    "p9p": "Първо да видим какво е общото между числата 100 и 10. От тук чувам как мислиш \"И двете се делят на 10\". И си прав. Не само това, но и двете са степени на 10 -> 10 е 10^1 , а 100 е 10^2 . Да го запишем (\"^\" е знак за степен):",
    "text": "Където ще научиш, че цифрите не са само 10",
    "title": "Урок 1"
  },
  "l10": {
    "p11p": "Резултат:",
    "p12con": "<<output>>5.68\n<<output>>5.67",
    "p13a1": "double",
    "p13a2": "float",
    "p13tq": "double или float може да съдържа повече битове информация?",
    "p14rq": "Потърси как да присвоиш променлива от тип double на променлива от тип float в твоя език. Потърси в Интернет или напиши грешния код в своето IDE и виж какви стъпки за поправка ти се предлагат. Постави мишката си на червената линия, показваща грешка.",
    "p1p": "Време е за следващите два типа. Те ти позволяват да съхраняваш и нецели числа - например 9.76, 6.78. Това са float и double.",
    "p2p": "Името float идва floating point - \"плаваща точка\" - точката, която е в дробните числа. float е голям 4 байта. double (\"двоен\") го запомни с това, че е двойно по-голям от float - 8 байта.",
    "p3p": "Когато запишеш дробно число в код, то се възприема като double. Трябва да добавиш \"f\" в края му, за да стане float.",
    "p4p": "Примери:",
    "p5pc": "float num = 5.67; // Получаваш грешка, че не може да дадеш на тип float стойност от тип double\nfloat num = 5.67f; // Това не дава грешка.",
    "p6pc": "double num = 5.67; // Не получаваш грешка",
    "p7p": "Подобно на int, тези типове също могат да се принтират в конзолата:",
    "p8ds1": "Java",
    "s10cc": "float num = 5.68f;\ndouble otherNum = 5.67;\nConsole.WriteLine(num);\nConsole.WriteLine(otherNum);",
    "s8ds2": "C#",
    "s9cj": "float num = 5.68f;\ndouble otherNum = 5.67;\nSystem.out.println(num);\nSystem.out.println(otherNum);",
    "text": "Където ще научиш какво е реално число",
    "title": "Урок 10"
  },
  "l11": {
    "p100con": "6",
    "p101con": "11",
    "p102pc": "int num = 5;\nint num1 = 6;\nint num2 = num + ++num1; // Тук първо ще се извърши ++num1, тоест то ще стане 7\n// След това ще се извърши с num + num1 или 5+7 с резултат 12 \nprint(num1);\nprint(num2);",
    "p103p": "Резултат:",
    "p104con": "7",
    "p105con": "12",
    "p106p": "Дали ще ти се наложи да ползваш това като информация някога? Може би. Обикновено е добре просто да ползваш num++ на следващия ред или на предния, за да няма обърквания. Защо го включвам тук тогава? Защото е адски лесно да се направи въпрос за това на всеки изпит, следователно го има на всеки изпит.",
    "p107pc": "int num = 5;\nint num1 = 6;\nint num2 = 7;\nint num3 = num + num1++ + --num2;",
    "p108a1": "17",
    "p108a2": "16",
    "p108a3": "19",
    "p108a4": "18",
    "p108exp": "Обяснение: първо се извършва --num2, където num2 става 6. След това се случва събирането num + num1 + num2, което е равно на 5 + 6 + 6, тоест 17. Накрая се изпълнява num1++, където num1 става 7.",
    "p108tq": "След извършената по-горна операция, num3 е равно на:",
    "p10pc": "int edno = 5;\nint dve = 6;\nint tri = edno + dve;\nprint(tri);",
    "p110h": "Bitwise оператори",
    "p111p": "Bitwise (\"битуайз\") операторите са едно от най-големите възможни обърквания. Много е възможно да ги срещнеш някъде, но се моли това да не се случва (поне върху числа, има други ползи в някои езици, които са далеч по-практични).",
    "p112p": "Bitwise операторите са \"<<\", \">>\", \"|\", \"&\", \"^\", \"~\". Те манипулират числата като битове.",
    "p113p": "<< и >> са така наречените шифтове. Те местят битовете на дадено число към определена страна. Например:",
    "p114pre": "10011100 << 1 е равно на 00111000",
    "p115pre": "10011100 >> 1 е равно на 01001110",
    "p116p": "Това може да има огромни ефектни - в първия пример 10011100 е 156, а след \"<< 1\", 00111000 е равно на 56. Ефектите са почти непредвидими, а ползите - малки.",
    "p117h": "|",
    "p118p": "\"Логическото или\" е операция между две двоични числа, която действа така:",
    "p119pre": "\n0101 -> първо число\n0111 -> второ число\n0111 -> резултат",
    "p11p": "Резултат:",
    "p120p": "Тоест, ако на позиция има 1 и 0 се записва 1. Ако има два пъти 1 се записва 1. Ако има два пъти 0 се записва 0.",
    "p121h": "&",
    "p122p": "\"Логическото и\" е операция между две двоични числа, която действа така:",
    "p123pre": "\n0101 -> първо число\n0111 -> второ число\n0101 -> резултат",
    "p124p": "Подобно на логическото или, само че 0 и 1 е 0. Тоест единствената ситуация, при която записваме 1 е при 2 единици.",
    "p125h": "^",
    "p126p": "\"Логическото ксор\" е операция между две двоични числа, която действа така:",
    "p127pre": "\n0101 -> първо число\n0111 -> второ число\n0010 -> резултат",
    "p128p": "Тук единствената ситуация, в която записваме 1, е когато двете числа са различни - 0 и 1.",
    "p129h": "~",
    "p12con": "11",
    "p130p": "Това е \"комплимента\". При него резултатът от ~0101 е 1010 - тоест просто обръща битовете - при 1 има 0 и при 0 има 1.",
    "p13p": "Ако извършим каквото и да е аритметично действие върху две числа, съответно float и double, резултатът е с тип double (floatSbor и doubleSbor са създадени / декларирани по-горе):",
    "p14pc": "float floatDoubleSbor = floatSbor + doubleSbor; // Това ще даде грешка\ndouble floatDoubleSbor = floatSbor + doubleSbor; // Всичко е наред тук",
    "p15p": "Същата логика се следва и при операции между int и float или int и double - крайният резултат винаги е float или double:",
    "p16pc": "int intFloatSbot = intSbor + floatSbor; // Това ще даде грешка\nfloat floatDoubleSbor = intSbor + floatSbor; // Всичко е наред тук",
    "p17p": "Можем да поставяме колкото си искаме аритметични действия едно след друго:",
    "p18pc": "int sbor = 5 + 6 + 7 + 8 + 9 + 10 + 11;\nprint(sbor);",
    "p19p": "Резултат:",
    "p1p": "В програмните езици има така наречените \"експресии\" или изрази. Изразите винаги достигат до даден тип променлива, независимо дали са аритметични операции или логически сравнения. Там, където може да се постави променлива от даден тип, може да се постави и израз, който има резултат от дадения тип. Днес ще разгледаме един от типовете изрази - аритметичните операции.",
    "p20con": "56",
    "p21a1": "int",
    "p21a2": "short",
    "p21a3": "float",
    "p21a4": "double",
    "p21p": "Аритметичните действия могат да се извършват на много различни места. Например:",
    "p21tq": "Резултатът от \"5 + 6.5f + 5.12\" би бил от тип:",
    "p23pc": "print(5+6+7);",
    "p24p": "Резултат:",
    "p25con": "18",
    "p26h": "Изваждане",
    "p27pc": "int razlika = 6 - 5;\nprint(razlika);",
    "p28p": "Резултат:",
    "p29con": "1",
    "p2h": "Събиране",
    "p30p": "Може разликата в изваждане да е и отрицателно число:",
    "p31pc": "int otricatelnaRazlika = 5 - 6;\nprint(razlika);",
    "p32p": "Резултат:",
    "p33con": "-1",
    "p34p": "Същите правила за действия между типове се прилагат.",
    "p35h": "Умножение",
    "p36p": "Умножението в програмирането се извършва със звездичката (\"*\"):",
    "p37pc": "int proizvedenie = 5 * 6;\nprint(proizvedenie);",
    "p38p": "Резултат:",
    "p39con": "30",
    "p3p": "Можем да събираме две целочислени числа (int). Получаваме друг int.",
    "p40p": "Трябва да се отбележи, че програмните езици обикновено следват подредбата на действията (скоби -> умножение и деление -> събиране и изваждане):",
    "p41pc": "int izraz = (10 - 5*2)*6;\nprint(izraz);",
    "p42p": "Резултат:",
    "p43con": "0",
    "p44p": "Тук първо се пресмята израза в скобите: 10 - 5*2. Извършва се умножението (5*2) и след това изваждането (10 - 10). Изразът става 0 * 6, което е 0.",
    "p45pc": "int izrazSusSkobi = ((10 - 5)*2)*6;\nprint(izrazSusSkobi);",
    "p46p": "Резултат:",
    "p47con": "60",
    "p48p": "Тук първо се пресмята израза в скобите: (10-5)*2, което е 5*2 = 10. След това 10 * 6 е равно на 60.",
    "p49p": "Същите правила за действия между типове се прилагат.",
    "p4pc": "int intSbor = 5 + 4;\nprint(intSbor);",
    "p50a1": "10",
    "p50a2": "0",
    "p50a3": "55",
    "p50a4": "-44",
    "p50h": "Деление",
    "p50tq": "Резултатът на \"10*(6-5)\" е:",
    "p52p": "Делението в програмирането е специфично според типа:",
    "p53pc": "int chastno = 6 / 2;\nprint(chastno);",
    "p54p": "Резултат:",
    "p55con": "3",
    "p56p": "Това е очакваното: 6/2 е 3",
    "p57p": "Проблемът се появява, когато имаме деление, при което има остатък. Например 8/3. Тъй като при изчислението се получава приблизително 2.66, а знаем, че в int може да има само цели числа, резултатът се запазва като 2:",
    "p58pc": "int chastnoSOstatuk = 8 / 3;\nprint(chastnoSOstatuk);",
    "p59p": "Резултат:",
    "p5p": "Резултат:",
    "p60con": "2",
    "p61pc": "int drugoChastno = chastno / chastnoSOstatuk; // 3 / 2\nprint(drugoChastno);",
    "p62p": "Резултат:",
    "p63con": "1",
    "p64p": "Ако имаме обаче float или double, получаваме очаквания резултат:",
    "p65pc": "float chastnoFloat =  8f / 3f;\nprint(chastnoFloat);",
    "p66p": "Резултат:",
    "p67con": "2.6666667",
    "p68p": "Чакай… Какво?",
    "p69p": "Резултатът трябва да е 2.66. Ама не е. Оказва се, че компютрите и двоичната система не са много добри в точното представяне на дробни числа. Затова понякога има подобни грешки. Не се притеснявай - случват се често и няма специфичен начин да ги оправиш.",
    "p6con": "9",
    "p70p": "Същите правила за действия между типове се прилагат.",
    "p71a1": "3",
    "p71a2": "4",
    "p71a3": "1",
    "p71a4": "2",
    "p71h": "Деление с остатък",
    "p71tq": "Резултатът от 28 / 9, ако и двете числа са от тип int, е:",
    "p73p": "Делението с остатък, или \"модуло\", е една операция, която не се среща особено често в нормалната математика, но е полезна в програмирането. Тя се отбелязва с \"%\" и връща само остатъка на делението:",
    "p74pc": "int chastno = 9 / 2;\nprint(chastno);",
    "p75p": "Резултат:",
    "p76con": "1",
    "p77p": "Можем да видим, че остатъкът от това деление е 1 - 8 се дели на 2, а 9 не се. Следователно 9/2 би било 4, а 9%2 е 1. Това действа по същия начин и при float и double.",
    "p78p": "Същите правила за действия между типове се прилагат.",
    "p79a1": "3",
    "p79a2": "4",
    "p79a3": "1",
    "p79a4": "2",
    "p79h": "Манипулации с 1",
    "p79tq": "Резултатът от 28 % 9, ако и двете числа са от тип int, е:",
    "p7p": "Можем да събираме две числа от тип float или double:",
    "p81p": "Много често в програмирането се налага да добавиш или извадиш 1 от число. Но понякога това е малко дълго. Например:",
    "p82pc": "int num = 2;\nnum = num + 1;\nprint(num);",
    "p83p": "Резултат:",
    "p84con": "3",
    "p85p": "или",
    "p86pc": "int num = 3;\nnum = num - 1;\nprint(num);",
    "p87p": "Резултат:",
    "p88con": "2",
    "p89p": "А пък програмистите са мързеливи хора. Затова са измислени операторите за манипулация с едно - \"++\" и \"--\". Нека да ги тестваме:",
    "p8pc": "float floatSbor = 5.67f + 2.33f;\ndouble doubleSbor = 5.67 + 2.33;",
    "p90pc": "int num = 2;\nnum++;\nprint(num);",
    "p91p": "Резултат:",
    "p92con": "3",
    "p93p": "или",
    "p94pc": "int num = 3;\nnum--;\nprint(num);",
    "p95p": "Резултат:",
    "p96con": "2",
    "p97p": "Това е лесно. Проблемът идва от това къде се поставят - може и преди, и след променливата. Разликата е, че преди променливата първо се извършва оператора за манипулация с 1, а после другите действия. Ако е след това, първо се извършват другите действия, а след това - оператора за манипулация с 1. Дай направо да ти покажа:",
    "p98pc": "int num = 5;\nint num1 = 6;\nint num2 = num++ + num1; // Тук първо ще се извърши num + num1, тоест 5+6, което ще е 11\n// Съответно num2 ще стане 11. След това ще се извърши num++, където num ще стане 6\nprint(num);\nprint(num2);",
    "p99p": "Резултат:",
    "p9p": "Можем също и да събираме две променливи от един тип:",
    "text": "Където ще научиш как се събират и изваждат числа… още веднъж",
    "title": "Урок 11"
  },
  "l12": {
    "p10p": "Можем също да присвояваме цели числа на char и да получим съответния им символ. Според повечето кодирания 'a' е числото 97, следователно можем да направим това:",
    "p11pc": "char aChar = 97;\nprint(aChar);",
    "p12p": "Резултат:",
    "p13con": "a",
    "p14p": "Още повече - можем да използваме и операторите за манипулация с 1:",
    "p15pc": "char aChar = 97;\naChar++;\nprint(aChar);",
    "p16p": "Резултат:",
    "p17con": "b",
    "p18a1": "оператори за манипулация с 1",
    "p18a2": "събиране",
    "p18a3": "изваждане",
    "p18a4": "всички от гореизброените",
    "p18tq": "Върху char можем да използваме:",
    "p19p": "Това беше char. Отвори твоето IDE, ако още не си и си поиграй с новите неща. Възможностите за тестване са големи. Късмет!",
    "p1p": "Скоро идва времето, в което ще се научиш да запазваш текст. Преди това обаче, трябва да можеш да запазваш единични символи. В този урок ще се занимаваме с типа char.",
    "p2p": "char идва от character - \"символ\" и запазва един единствен символ. Ето така:",
    "p3pc": "char a = 'a';",
    "p4w": "Символът се записва в единични кавички - ' '. Текстът се записва в нормални, а char може да има само един символ.",
    "p5p": "Това само по себе си не е много интересно - char запазва един символ. Но, спомни си какво казахме в урока за кодиране - всеки един символ се приема като число от компютъра. Това води до някои интересни неща - 'a' е по-малко от 'b' и ни позволява да извършваме аритметични действия върху символи:",
    "p6pc": "char a = 'a';\nchar b = 'b';\nint c = 'a' - 'b';\nprint(c);",
    "p7p": "Резултат:",
    "p8con": "-1",
    "p9p": "Тук знаем, че според подреждането на символите 'b' е с едно по-голямо от 'a', тоест, ако извадим 'b' от 'а', получаваме -1.",
    "text": "Където ще разбереш защо учи кодирания на символи",
    "title": "Урок 12"
  },
  "l13": {
    "p10exp": "Символ 0 е 'и'. Символ 1 е 'м'. Символ 2 е 'е'. Символ 3 е 'н'. Символ 4 е 'а'. Символ 5 е празно пространство. Символ 6 е 'н'.",
    "p11p": "Сега да видим кодови примери:",
    "p12ds1": "Java",
    "p1p": "Дойде време. В този урок ще се научиш да запазваш текст чрез типа string.",
    "p2p": "String, или низ на български, е последователност от символи. В ранните програмните езици този тип не съществува както днес. Представян е чрез последователност от char (символи) в паметта. Оттам идва и името - низ от символи. Повечето модерни езици запазват всички низове с кодиране Уникод.",
    "p3p": "Низовете могат да извършват една главна операция и тя е \"конкатенация\" - слепяне на два низа. Прието е, че когато се създаде един низ, неговите символи вече не могат да бъдат променяни - трябва да се създаде нов променен низ. Тази философия следват Java и C#. От друга страна, индивидуални символи могат да се четат. Всеки символ в низ си има индекс. Първият символ отляво надясно има индекс 0. Вторият има индекс 1 и така нататък. Например:",
    "p4p": "Чаши",
    "p5p": "Ч има индекс 0",
    "p6p": "А има индекс 1",
    "p7p": "Ш има индекс 2",
    "p8p": "И има индекс 3",
    "p90p": "Независимо кой език използваш, най-вероятно ще ти се наложи да запишеш кавички в низ:",
    "p91pre": "\"думата \"здраве\" е съществително\"",
    "p92p": "Следният низ би дал грешка, защото се гледат първите кавички и директно следващите - програмен език би възприел това като низ \"думата \", \"здраве\" извън който и да е низ и \" е съществително\" като още един низ.",
    "p93p": "За разрешаване на следния проблем се използва escape character (\"символ за бягство\") - \"\\\". Пред кавичките, които са част от низа се записва \"\\\", което сигнализира на езика, че те не трябва да се приемат като начало или край на нов низ:",
    "p94pre": "\"думата \\\"здраве\\\" е съществително\"",
    "p9a1": "н",
    "p9a2": "празно пространство",
    "p9a3": "а",
    "p9a4": "к",
    "p9tq": "В низа \"имена на крале\", на индекс 6 е символът:",
    "s13p": "String променлива се създава чрез следния код:",
    "s14cj": "String hello = \"здравей\";",
    "s15p": "Забележи, че String се пише с главна буква, за разлика от другите типове, които си изучавал/а досега. След това следва името на променливата, както обикновено. Самият низ винаги се записва между двойни кавички - противоположно на единичните на char. Така езикът различава единия от другия тип.",
    "s16p": "String променлива може и да се принтира към конзолата:",
    "s17cj": "String hello = \"здравей\";\nSystem.out.println(hello);",
    "s18p": "Резултат:",
    "s19con": "здравей",
    "s20p": "Към низовете може да се добавя - конкатенация. Това става със знака плюс. Може да се добавят низове, цели числа, дробни числа:",
    "s21cj": "String hello = \"здравей\";\nString helloIvan = hello + \"Иван\" + 5;\nSystem.out.println(helloIvan);",
    "s22p": "Резултат:",
    "s23con": "здравейИван5",
    "s24p": "Конкатенацията не прибавя празни пространства сама - това трябва да го свършим ние:",
    "s25cj": "String hello = \"здравей'\";\nString helloIvan = hello + \" Иван\"; // Забележи мястото преди думата Иван в низа\nSystem.out.println(helloIvan);",
    "s26p": "Резултат:",
    "s27con": "здравей Иван",
    "s28p": "Можем да съберем два низа и на място (конкатенацията е вид експресия):",
    "s29cj": "System.out.println(\"Здравей\" + \" Георги\");",
    "s30p": "Резултат:",
    "s31con": "Здравей Георги",
    "s32p": "Можем да използваме и съкратен оператор, който не сме ползвали досега. Вместо да пишем:",
    "s33cj": "String hello = \"здравей\";\nhello = hello + \" Иван\"; // hello ще има нова стойност - \"Здравей Иван\"",
    "s34p": "Можем да напишем:",
    "s35cj": "String hello = \"здравей\";\nhello += \" Иван\"; // Забележи, че пишем \"+=\". Това означава да добавим стойността, която даваме и пак ще има резултат \"здравей Иван\". Действа и с другите оператори за аритметични операции, като -, *, /.",
    "s36p": "Можем да вземем символ от низ по следния начин:",
    "s37cj": "String hello = \"здравей\";\nchar firstCharOfhello = hello.charAt(0);\nSystem.out.println(firstCharOfhello);",
    "s38p": "Резултат:",
    "s39con": "з",
    "s40p": "Тук създаваме променлива от тип char с име firstCharOfhello (първи символ от hello). Тя е равна на hello (името на променливата ни), след това точка и charAt(). В скобите на charAt се записва индекса. Тук индексът е 0, което е \"з\" от \"здравей\" - първи символ. .charAt() се нарича метод, а в случая нулата е аргумент. System.out.println() се записва по подобен начин - тук .println() също е метод, а между скобите е аргумента. Поне в Java, другите типове, които сме учили досега нямат методи. В по-късен урок ще разгледаме всички методи на низовете и ще се научиш как да създаваш свои методи.",
    "s41p": "Вече можем да разберем и как действа System.out.println():",
    "s42cj": "String helloIvan = \"Здравей Иван\";\nString otgovor = \"Здравей и ти\";\nSystem.out.println(helloIvan);\nSystem.out.println(otgovor);",
    "s43p": "Резултат:",
    "s44con": "Здравей Иван",
    "s45con": "Здравей и ти",
    "s46p": "Това горе е равносилно на конкатенация със символа за нов ред - \"\n\":",
    "s47cj": "String helloIvan = \"Здравей Иван\";\nString otgovor = \"Здравей и ти\";\nSystem.out.print(helloIvan + \"\n\"); // Забележи, че тук записваме само .print(), тоест очакваме \"Здравей ИванЗдравей и ти\" на един ред. Но заради добавянето на \"\n\", получаваме нов ред.\nSystem.out.println(otgovor);",
    "s48p": "Резултат:",
    "s49con": "Здравей Иван",
    "s50con": "Здравей и ти",
    "s51ds2": "C#",
    "s52p": "string променлива се създава чрез следния код:",
    "s53cc": "string hello = \"здравей\";",
    "s54p": "Забележи, че string се пише с малка буква. След това следва името на променливата, както обикновено. Самият низ винаги се записва между двойни кавички - противоположно на единичните на char. Така езикът различава единия от другия тип.",
    "s55p": "string променлива  може и да се принтира към конзолата:",
    "s56cc": "string hello = \"здравей\";\nConsole.WriteLine(hello);",
    "s57p": "Резултат:",
    "s58con": "здравей",
    "s59p": "Към низовете може да се добавя - конкатенация. Това става със знакът плюс. Може да се добавят низове, цели числа, дробни числа:",
    "s60cc": "string hello = \"здравей\";\nstring helloIvan = hello + \"Иван\" + 5;\nConsole.WriteLine(helloIvan);",
    "s61p": "Резултат:",
    "s62con": "здравейИван5",
    "s63p": "Конкатенацията не прибавя празни пространства сама - това трябва да го свършим ние:",
    "s64cc": "string hello = \"здравей\";\nstring helloIvan = hello + \" Иван\"; // Отбележи мястото преди думата Иван в низа\nConsole.WriteLine(helloIvan);",
    "s65p": "Резултат:",
    "s66con": "здравей Иван",
    "s67p": "Можем да съберем два низа и на място (конкатенацията е вид експресия):",
    "s68cc": "Console.WriteLine(\"Здравей\" + \"Георги\");",
    "s69p": "Резултат:",
    "s70con": "Здравей Георги",
    "s71p": "Можем да използваме и съкратен оператор, който не сме ползвали досега. Вместо да пишем:",
    "s72cc": "string hello = \"здравей\";\nhello = hello + \" Иван\"; //hello ще има нова стойност \"Здравей Иван\"",
    "s73p": "Можем да напишем:",
    "s74cc": "string hello = \"здравей\";\nhello += \" Иван\"; // Забележи, че пишем \"+=\". Това означава да добавим стойността, която даваме и пак ще има резултат \"здравей Иван\". Действа и с другите оператори за аритметични операции, като -, *, /.",
    "s75p": "Можем да вземем символ от низ по следния начин:",
    "s76cc": "string hello = \"здравей\";\nchar firstCharOfhello = hello[0];\nConsole.WriteLine(firstCharOfhello);",
    "s77p": "Резултат:",
    "s78con": "з",
    "s79p": "Тук създаваме променлива от тип char с име firstCharOfhello (първи символ от hello). Това е равно на hello (името на променливата ни), след това [] - оператора за достъп до индекс. В него се записва индекса. В по-късен момент той ще се завърне в нашите уроци.",
    "s80p": "Вече можем и да разберем как действа Console.WriteLine():",
    "s81cc": "string helloIvan = \"Здравей Иван\";\nstring otgovor = \"Здравей и ти\";\nConsole.WriteLine(helloIvan);\nConsole.WriteLine(otgovor);",
    "s82p": "Резултат:",
    "s83con": "Здравей Иван",
    "s84con": "Здравей и ти",
    "s85p": "Е равносилно на конкатенация със символа за нов ред - \"\n\":",
    "s86cc": "string helloIvan = \"Здравей Иван\";\nstring otgovor = \"Здравей и ти\";\nConsole.Write(helloIvan + \"\n\"); // Забележи, че тук записваме само .Write(), тоест очакваме \"Здравей ИванЗдравей и ти\" на един ред. Но заради добавянето на \"\n\", получаваме нов ред.\nConsole.WriteLine(otgovor);",
    "s87p": "Резултат:",
    "s88con": "Здравей Иван",
    "s89con": "Здравей и ти",
    "text": "Където ще научиш как се запазва текст",
    "title": "Урок 13"
  },
  "l14": {
    "p1p": "В днешния урок ще обсъждаме библиотеки. Не, не тези в които ходиш да вземеш книги. Ще обсъждаме библиотеки в програмирането.",
    "p29rq": "Разучи Math библиотеката в твоя език - как се използва числото \"пи\"? Как се вдига на степен? Как се намира корен квадратен на число? Също погледни Maven и Gradle (Java) или NuGet (C#).",
    "p2p": "Преди много, много години, всеки път, когато трябва да се създаде нещо, някой е сядал и го е пишел. Искаш случайно число? Напиши кода. Искаш да покажеш нещо на екрана? Напиши кода. Това е изморително. По тази причина са се родили библиотеките. Библиотека в програмирането е съвкупност от код за извършване на някаква (обикновено) обща цел. Библиотеката може да бъде написана от един човек и да се разпространи между стотици и милиони програмисти. Всеки може да я ползва, без дори да знае сам как действа кода вътре. В днешно време има библиотеки за всички грозни и трудоемки неща, които програмистите не искат да правят сами - автентикация, криптиране, хаширане, графични интерфейси, четене на файлове. Схващаш? В днешно време, почти всички езици имат и стандартна библиотека, която включва много неща, които е хубаво да има, но не е добра идея да се включват в езика - генератори на случайни числа, математически константи, четци на файлове. Например, в Java \"System.out.println()\" всъщност е част от стандартната библиотека. В C# това е \"Console.WriteLine()\". Библиотеките се импортират в кода.",
    "p3a1": "не се импортират",
    "p3a2": "са съвкупности от код",
    "p3a3": "обикновено имат обща цел",
    "p3a4": "съдържат книги",
    "p3tq": "Библотеките в програмирането:",
    "p4p": "Да разгледаме примери:",
    "p5ds1": "Java",
    "s10p": "Записваме типа Random. След това името на променливата - rand и я създаваме чрез new Random() - \"нов случаен\". Вече имаме променливата rand. Как създаваме случайно число? Чрез rand.nextInt():",
    "s11cj": "int randomInt = rand.nextInt();",
    "s12p": "Това обаче ще създаде случаен int в цялата граница на стойностите на int - може да е 2, може да е 1 656 789. Ако искаме да лимитираме rand.nextInt(), пишем число в скобите. То е максимума, който може да бъде създаден този път.",
    "s13p": "Например:",
    "s14cj": "int randomInt = rand.nextInt(23); // тук числото винаги е по-малко от 23\nint randomInt2 = rand.nextInt(34); // тук винаги е по-малко от 34",
    "s15p": "Има подобни методи и за другите типове - сам разгледай .nextDouble(), .nextFloat() и .nextLong().",
    "s16ds2": "C#",
    "s17p": "В C# импортите на части от библиотеки се пишат най-горе. Ползва се думата \"using\". Може би вече си забелязал, че ти имаш един импорт горе - \"using System\". Това ти позволява да използваш стандартната библиотека на C# - неща като Console.WriteLine(). След това се пише пътя до частта от библиотеката, която искаме да импортираме:",
    "s18cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\t\n\t}\n}",
    "s19p": "Виждаш, че тук пишем \"using System;\" Щом сме импортирали стандартната библиотека, можем да използваме Random. Random всъщност е тип, подобно на string. Можем да създадем променлива от него. Това става по следния начин:",
    "s20cc": "Random rand = new Random();",
    "s21p": "Тук записваме типа Random. След това името на променливата - rand и я създаваме чрез new Random() - \"нов случаен\". Вече имаме променливата rand. Как създаваме случайно число? Чрез rand.Next():",
    "s22cc": "int randomInt = rand.Next();",
    "s23p": "Това обаче ще създаде случаен int в цялата граница на стойностите на int - може да е 2, може да е 1 656 789. Ако искаме да лимитираме rand.Next(), пишем число в скобите. То е максимума, който може да бъде създаден този път.",
    "s24p": "Например:",
    "s25cc": "int randomInt = rand.Next(23); // тук числото винаги е по-малко от 23\nint randomInt2 = rand.Next(34); // А тук винаги е по-малко от 34",
    "s26p": "Можем да лимитираме и долната стойност. Тогава пишем две различни числа в скобите, разделени от запетаи. Първото е минималната стойност, а второто - максималната:",
    "s27cc": "int randomInt = rand.Next(23, 46); // тук числото винаги е между 23 и 46",
    "s28p": "Има подобни методи и за другите типове - сам разгледай .NextDouble() и .NextBytes()",
    "s6p": "В Java импортите на части от библиотеки се пишат в горната част на файла - след package и преди class. Ползва се думата import. След това се пише пакетния път до частта от библиотеката, която искаме да импортираме. Така:",
    "s7cj": "package hello;\n\nimport java.util.Random;\n\npublic class Hello {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t}\n\n}",
    "s8p": "Виждаш, че тук пишем \"import java.util.Random\" Спомняш ли си какво е пакет? Създаде един по-рано в тези уроци. Тук минаваме първо през пакета java, после пакета util. Накрая е класа Random - подобен на този, който създаде ти по-рано, за да пишеш кода си в него. Щом сме го импортирали, можем да използваме Random. Random всъщност е тип, подобно на String. Можем да създадем променлива от него. Това става по следния начин:",
    "s9cj": "Random rand = new Random();",
    "text": "Където ще научиш общото между библиотеките и компютрите",
    "title": "Урок 14"
  },
  "l15": {
    "p10p": "Да видим как става това в Java и C#:",
    "p11ds1": "Java",
    "p1p": "Досега само сме извеждали към конзолата. Днес ще се научиш да въвеждаш от конзолата към програмите си.",
    "p2p": "Накратко, въвеждането би действало така в нашия общ код:",
    "p3pc": "string in = input();\nprint(in);",
    "p4p": "Вход:",
    "p52p": "Задача:",
    "p53rq": "Състави програма, която пита потребителя на колко години е от конзолата и взема неговия вход като цяло число. След това поискай името на потребителя като низ. Накрая принтирай информацията във формата \"Име, възраст\".",
    "p5con": "Здравей!",
    "p6p": "Резултат:",
    "p7con": "Здравей!",
    "p8p": "Тук програмата стига до реда \"string in = input();\", при което започва да чака вход от конзолата. Ти можеш да напишеш каквото си искаш в конзолата и след това при натискане на Enter (нов ред) се въвежда символа за нов ред \n и това, което си написал, бива прочетено. Когато това се случи, стойността, която си написал в конзолата се пренася в програмата и променливата \"in\" става равна на нея. Кодът продължава хода си, принтирайки \"in\" в конзолата.",
    "p9a1": "изключва се",
    "p9a2": "спира да отговаря",
    "p9a3": "паузира, докато чака вход",
    "p9a4": "продължава работата си",
    "p9tq": "Какво става с програмата, когато стигне до input() в горния пример?",
    "s12p": "В Java четенето на файлове става с типа Scanner, част от стандартната библиотека. Всъщност Scanner (скенер) чете всички файлове - в миналото (и в момента в много случаи) конзолата е просто файл, в който пишеш, така че е останало така.",
    "s13p": "Тъй като Scanner е част от стандартната библиотека, а не от самия език, първо трябва да го импортираме във файла. Това става с:",
    "s14cj": "import java.util.Scanner;",
    "s15p": "Не забравяй къде се поставят импортите - между package и class.",
    "s16p": "Споменах, че Scanner е тип. Подобно на Random. Спомняш ли си как създаде нов Random? Създай по същия начин променлива с тип Scanner и име \"sc\" или \"input\" (вход).",
    "s17p": "Кода ти трябва да изглежда така:",
    "s18cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner();\n\t}\n}",
    "s19p": "Ако пуснеш този код обаче, ще получиш грешка. Проблемът е, че Scanner трябва да получи аргумент. Има логика - трябва да знае кой файл да чете. Очаква аргумента между скобите. Тук бихме въвели низ с пътя до файл - абсолютен или относителен. Например:",
    "s20cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(\"C:mnogovajenfile.txt\");\n\t}\n}",
    "s21p": "Това би дало грешка - спомняш ли си защо?",
    "s22p": "Да, заради . Тоест би било правилно така:",
    "s23cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(\"C:/mnogovajenfile.txt\");\n\t}\n}",
    "s24p": "Но на нас ни трябва конзолата. А път до нея не знаем. За наша радост, някой е измислил нщо за този случай. Като аргумент няма да дадем път, а ще дадем \"System.in\". Забележи, че принтираме на конзолата със System.out.println() (система.навън), а въвеждаме от нея със System.in (система.навътре). Това е конзолата. Крайният код изглежда така:",
    "s25cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t}\n}",
    "s26p": "Съответно вече имаме променливата \"input\".  Тя е обект и е с типа Scanner. Да въведем първия си низ чрез .nextLine()  - \"следващ ред\":",
    "s27cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tString greeting = input.nextLine();\n\t\tSystem.out.println(greeting);\n\t}\n}",
    "s28p": "Вход:",
    "s29con": "Здравей",
    "s30p": "Резултат:",
    "s31con": "Здравей",
    "s32p": "Тук създаваме променлива greeting (поздрав) от тип низ, която е равна на input.nextLine(). Програмата чака да въведеш нещо в конзолата и да натиснеш Enter, след което продължава и принтира на конзолата поздрава, който си въвел.",
    "s33p": "Scanner също има и други методи. Например .nextInt(), .nextLong(), .nextByte() и така нататък. Разгледай ги сам. Аз само трябва да те предупредя за нещо.",
    "s34e": "При Scanner в Java има грешка / бъг. Ако първо поискаш цяло число (int) и след това String, ще получиш празен String.",
    "s35cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint inputInt = input.nextInt();\n\t\tString scannerBug = input.nextLine();\n\t}\n}",
    "s36p": "Вход:",
    "s37con": "5",
    "s38con": "<<output>> //Програмата вече е спряла работата си тук",
    "s39p": "Това, което се случва е, че input.nextInt() не взима символа \"\\n\", когато натиснеш Enter. Тоест, input.nextLine() взима този оставащ \"\\n\" и тъй като чака този символ, веднага спира да чете и ти връща празен низ. Това се поправя по следния начин:",
    "s40cj": "package tutorial;\n\nimport java.util.Scanner;\n\npublic class Input {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint inputInt = input.nextInt();\n\t\tinput.nextLine();\n\t\tString fixedScannerBug = input.nextLine();\n\t}\n}",
    "s41p": "Вход:",
    "s42con": "5",
    "s43con": "Здравей",
    "s44p": "Тук се взима цялото число. След това input.nextLine(); на следващия ред взима самотния \"\\n\" и тъй като празния низ не се дава на никоя променлива, изчезва в небитието. След това следващия input.nextLine() може спокойно да вземе каквото напишеш на следващия ред.",
    "s45ds2": "C#",
    "s46p": "В C# четенето от конзолата става подобно на принтирането на конзолата. Само че, вместо Console.WriteLine(), ползваме Console.ReadLine():",
    "s47cc": "using System; // Не забравяй, че ни трябва System, за да използваме Console\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tstring greeting = Console.ReadLine();\n\t\tConsole.WriteLine(greeting);\n\t}\n}",
    "s48p": "Тук създаваме променлива greeting (поздрав) от тип низ, която е равна на Console.ReadLine(). Програмата чака да въведеш нещо в конзолата и да натиснеш Enter, след което продължава и принтира на конзолата поздрава, който си въвел.",
    "s49p": "Ако искаш да получиш нещо различно от низ, трябва да използваш по-различен метод - Convert. Той действа така:",
    "s50cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tint num = Convert.ToInt32(Console.ReadLine());\n\t\tConsole.WriteLine(num);\n\t}\n}",
    "s51p": "Convert.ToInt32() получава Console.ReadLine() като аргумент, следователно конвертира резултата към int32, или с други думи, int с 32 бита - 4 байта - или нашия нормален int. Има също и Conver.ToInt64(), което е long и Convert.ToInt16(), което е 16 бита - 2 байта, или short. Има също и .ToDouble() и .ToChar().",
    "text": "Където ще научиш как се използва конзолата… от другата страна",
    "title": "Урок 15"
  },
  "l16": {
    "p10p": "Ние не се интересуваме от тези езици. Интересуваме се от Java и C#.",
    "p11p": "Подобно на всичко друго, \"true\" и \"false\" имат специален тип променлива за себе си. Нарича се boolean (\"буулиан\") или на български - булев. Типът е кръстен на един английски математик на име Джордж Бул.",
    "p12p": "Булевите типове се побират в един байт - нямат и нужда от повече. В крайна сметка, имат точно две възможни стойности. Най-вероятно ще попиташ защо не е 1 бит, а отговорът е че повечето процесори не могат да използват нещо по-малко от 1 байт.",
    "p13p": "Да видим как се декларират в различните езици:",
    "p14ds1": "Java",
    "p19p": "Това е създаването на boolean променлива. Но в момента, тя не ни е много полезна. Защо ни е да знаем дали нещо е вярно или грешно, ако така или иначе го преценяваме ние?!",
    "p1p": "В програмирането идва един момент, в който трябва да сравниш нещо. Независимо дали е две числа или два символа. В този урок ще се научиш да правиш именно това.",
    "p20p": "Затова сега ще те науча на сравняваш. Ще използвам нашия общ код.",
    "p21h": ">, <",
    "p22p": "Първите оператори за сравняване са по-голямо и по-малко. Знаеш ги, надявам се. Така действат те:",
    "p23pc": "bool sravnenie = 5 < 7;\nprint(sravnenie);",
    "p24p": "Резултат:",
    "p25con": "true",
    "p26p": "Това е. Създаваме променливата и я присвояваме на твърдение. Компютърът преценява дали твърдението е правилно и дава стойност true или false. Можем да сравняваме и на място:",
    "p27pc": "print(5 > 7);",
    "p28p": "Резултат:",
    "p29con": "false",
    "p2p": "Първо виж следното твърдение:",
    "p30p": "5 очевидно не е по-голямо от 7.",
    "p31p": "Можем да сравняваме и променливи:",
    "p32pc": "int num = 1;\nint num2 = 2;\nprint(num < num2);",
    "p33p": "Резултат:",
    "p34con": "true",
    "p35p": "… и понякога даже ако не са от един тип:",
    "p36pc": "print(5f < 6.7);",
    "p37p": "Резултат:",
    "p38con": "true",
    "p39h": "==, !=",
    "p3p": "\"Аз не излъгах.\"",
    "p40p": "Хората много често сравняват две числа, за да видят дали са равни. И обикновено, това се прави с \"=\". Но има лек проблем - ние вече използваме \"=\" за присвояване. Как се очаква компилатора да знае дали сравняваме променливата num с 5 или се опитваме да присвоим 5 на num?",
    "p41pc": "int num = 6;\nbool b = num = 5; // Можеш да видиш как това е объркващо и колко грешки може да причини",
    "p42p": "Вместо това, използваме \"==\". Така, и програмистът, и компилаторът знаят какво имаме предвид:",
    "p43pc": "int num = 6;\nbool b = num == 5;\nprint(b);",
    "p44p": "Резултат:",
    "p45con": "false",
    "p46p": "6 не е равно на 5.",
    "p47p": "Идва и друг проблем. Понякога искаме да проверим дали две числа не са равни, а не дали са равни. В математиката, това се представя със символ \"равно с черта преминаваща през него\" - \"зачеркваща равенството\", един вид. Но тук нито можем да ползваме равно, нито можем да го зачеркваме. Затова някой е измислил \"!=\" и всички са приели, че изглежда достатъчно близко до истинското нещо. Ползваме го до днес.",
    "p48pc": "int num = 6;\nbool b = num != 5;\nprint(b);",
    "p49p": "Резултат:",
    "p4p": "Какво може да е това твърдение? Какви могат да бъдат твърденията?",
    "p50con": "true",
    "p51p": "num не е равно на 5, значи твърдението е вярно. b е true.",
    "p52p": "В някакъв момент, всички са приели, че \"!\" ще обръща значението на променлива от тип boolean.",
    "p53p": "Тоест, можем да правим такива неща:",
    "p54pc": "bool b = !(5<6); // 5 е по-малко от 6, значи в скобите става true. \"!\" обръща стойността, и b става false.\nprint(b);",
    "p55p": "Резултат:",
    "p56con": "false",
    "p57h": ">=, <=",
    "p58p": "Друго нещо, на което трябва да наблегна, е че 6 не e по-малко от 6. Тоест, 6 < 6 не е true. Не е true и 6 > 6. Когато искаме и двете условия, използваме >= и <=. Това е съответно по-голямо или равно и по-малко или равно. 6 >= 6 е вярно. Също е вярно и 6 >= 3. Оставям на теб да тестваш това. И запомни, равното винаги е отдясно спрямо началния оператор.",
    "p59w": "В Java, String променливите не трябва да се сравняват с \"==\". В този случай, това проверява дали адресите на двете променливи в хийпа са еднакви. Това не е гарантирано вярно във всички версии на Java, дори низовете да са еднакви като съдържание. Вместо това, използвай .equals(вториНиз) (равен на). Това важи и за други обекти от специални типове като Random и Scanner (въпреки че най-вероятно никога няма да ти се наложи да сравняваш тези):",
    "p5p": "Ако си отговорил \"верни и грешни\", ти си прав. Това са двете състояния на всяко едно твърдение.",
    "p60cj": "String test = \"hello\";\nString test1 = \"hello\";\nSystem.out.println(test == test1);",
    "p61p": "Резултат:",
    "p62con": "false или true",
    "p63p": "Въпреки, че тук низовете са очевидно равни, има висок шанс на много версии на Java резултатът да е false. Вместо това, използвай това:",
    "p64cj": "String test = \"hello\";\nString test1 = \"hello\";\nSystem.out.println(test.equals(test1));",
    "p65p": "Резултат:",
    "p66con": "true",
    "p67p": "Тук използваме .equals() и знаем, че резултатът винаги е реален.",
    "p68p": "Може би си забелязал, че в този урок не съм задал нито един въпрос. Това е, защото сега ще получиш първата си истинска задача!",
    "p69rq": "Състави програма, в която въвеждаш две числа от конзолата. Ако първото е по-голямо, изведи true към конзолата, иначе изведи false.",
    "p6p": "Когато пишем код, действаме по същия начин. Ние представяме твърдение, а компютъра ни казва дали е вярно или грешно. Пишем твърдението 5 < 6 и компютъра ни казва \"Това е вярно\". Пишем 7 > 8 и компютъра ни казва \"Това е грешно\". Това е най-важното, което трябва да разбереш в този урок.",
    "p7p": "В началото, вярно и грешно се е представяло от числата 1 и 0 - 1 значи вярно, а 0 значи грешно. Има логика. В някакъв момент, някой е решил да измисли нещо малко по-четимо и сме стигнали до днешните \"true\" (правилно - англ.) и \"false\" (грешно - англ.), налични в почти всеки език, който съм срещал и който ти най-вероятно ще срещнеш. Забавно е всъщност, че в някои езици границата между 1 и \"true\" и 0 и \"false\" е толкова малка, че нещо от този род работи:",
    "p8pc": "int num = (false + true + true)  * true;",
    "p9p": "Което приключва с num равно на 2.",
    "s15cj": "package tutorial;\n\npublic class Booleans {\n\t\n\tpublic static void main(String[] args) {\n\t\tboolean b = true;\n\t\tboolean b1 = false;\n\t}\n}",
    "s16p": "Забележи, че името в Java се изписва напълно - boolean. В нашия общ код ще използвам bool, съкращението използвано и в C#, защото е по-кратко. То обаче не съществува в Java.",
    "s17ds2": "C#",
    "s18cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tbool b = true;\n\t\tbool b1 = false;\n\t}\n}",
    "text": "Където ще научиш как се сравнява",
    "title": "Урок 16"
  },
  "l17": {
    "p10con": "true",
    "p11p": "Това е вярно, защото и 5<7 и 6<7 е вярно. Ако обаче направим:",
    "p12pc": "print(5 < 7 && 7 < 7);",
    "p13p": "Резултат:",
    "p14con": "false",
    "p15p": "Резултатът е false, защото 5 е по-малко от 7, но 7 не е по-малко от 7. Тоест имаме 1 грешно, тоест целият резултат става грешен.",
    "p16p": "\"Логическо или\" е този оператор - \"||\". Той се поставя между две твърдения и изкарва резултат true, ако има поне едно вярно твърдение. Иначе резултата е false. Това са случаите:",
    "p17pre": "true || true = true",
    "p18pre": "true || false = true",
    "p19pre": "false || true = true",
    "p1p": "Първото, което ще разгледаме днес са логическите оператори. По-точно \"логическото и\" и \"логическото или\". Може да си спомняш, че веднъж сме споменавали тези имена - в урока за аритметични действия. Тогава обаче беше относно числа, а тук е относно булеви променливи.",
    "p20pre": "false || false = false",
    "p21p": "В код се използва, където може да се прави и всяко друго сравнение:",
    "p22pc": "bool b = 5 < 7 || 7 < 7;\nprint(b);",
    "p23p": "Резултат:",
    "p24con": "true",
    "p25p": "Това е вярно, защото и 5<7 е вярно, тоест за \"логическото или\" няма значение, че 7 не е по-малко от 7. Има 1 вярно, тоест целият резултат е верен. Ако обаче направим:",
    "p26pc": "print(7 < 7 || 8 < 7);",
    "p27p": "Резултат:",
    "p28con": "false",
    "p29p": "Резултатът е false, защото 7 не е по-малко от 7 и 8 не е по-малко от 7. Тоест всички твърдения са грешни, тоест целият резултат става грешен.",
    "p2p": "\"Логическо и\" е оператора \"&&\". Той се поставя между две твърдения и стига до резултат true, ако и двете са верни. Иначе резултатът е false. Това са случаите, подредени в truth table (таблица за истинност), която представя всички възможни варианти при логическа експресия и техните резултати:",
    "p30a1": "true",
    "p30a2": "false",
    "p30exp": "Първо гледаме скобите. 6 е по-малко от 8, тоест вярно. 9 обаче не е по-малко от 0. Въпреки това, между двете твърдения има логическо или, тоест целият резултат в скобите е true. След това имаме твърдението, че 6 + 1 не е равно на 7, което е грешно. Операторът е логическо и. От едната страна имаме true от скобите, от другата имаме false, тоест резултатът е false.",
    "p30tq": "true или false е твърдението \"(6 < 8 || 9 < 0) && 6 + 1 != 7\"?",
    "p32h": "Ternary",
    "p33p": "Този тип изрази очевидно няма превод на български - попаднах на най-различни от най-различни източници. Затова просто ще го наричам с английското произношение - тернари.",
    "p34p": "За да разбереш как действа тернари, ще направим заедно една задача. Тя е следната:",
    "p35rq": "Въведи 2 числа от конзолата. Изведи по-голямото на конзолата.",
    "p36p": "Аз ще напиша задачата в общ код. Напиши я в избрания си език, като един вид предизвикателство. Няма разлика между тернари в общия код, Java и C#.",
    "p37p": "Първо взимаме две числа от конзолата:",
    "p38pc": "int num = input();\nint num1 = input();",
    "p39p": "Въпросът е: Как да намерим и запаметим по-голямото число? Тук идва на помощ тернари:",
    "p3pre": "true && true = true",
    "p40pc": "int bigger = (num > num1)? num : num1;",
    "p41p": "Опитай се да разбереш какво прави тернари без да ти го обяснявам.",
    "p42p": "Опита ли?",
    "p43p": "Първо имаме променлива. Тя се казва bigger, от по-голям. Тя е с тип int. Тя е равна на тернарито.",
    "p44p": "В тернарито първо имаме твърдение в скоби - това е условието.",
    "p45pc": "(num > num1)",
    "p46p": "След това имаме \"?\". Това значи, че условието е приключило.",
    "p47p": "След това идва важната част - стойността на тернарито, ако условието е вярно - num. След това има отделение чрез \":\". След него е стойността, ако условието е грешно - num1. Стойността на тернарито ще стане и стойност на bigger. Да изразим това в думи:",
    "p48p": "Ако първото число е по-голямо от второто число, bigger ще стане равно на първото число. Иначе, ако първото число е по-малко от или равно на второто число, bigger ще стане равно на второто число.",
    "p49p": "Разбра ли вече?",
    "p4pre": "true && false = false",
    "p50p": "Значи, във всеки случай bigger ще е по-голямото число. Само трябва да го изведем:",
    "p51pc": "print(bigger);",
    "p52p": "Цялата задача става:",
    "p53pc": "int num = input();\nint num1 = input();\nint bigger = (num > num1)? num: num1;\nprint(bigger);",
    "p54p": "Написа ли тази програма в твоя език?",
    "p55rq": "За край на този урок ще ти дам една друга задача. Представи си, че ти си професор в университет. Дал си изпит на студентите с максимални 100 точки. Искаш да направиш програма, в която въвеждаш точките на ученик. След това програмата извежда оценката на ученика - тя се смята по формулата (точки*6)/100 (знам, може би доста щадяща за университет). Накрая, ако ученикът има оценка над или равна на 3, да се извежда на конзолата \"Ученикът минава\". Иначе да се извежда \"Ученикът не минава\".",
    "p56p": "Късмет!",
    "p5pre": "false && true = false",
    "p6pre": "false && false = false",
    "p7p": "В код се използва, където може да се прави и всяко друго сравнение:",
    "p8pc": "bool b = 5 < 7 && 6 < 7;\nprint(b);",
    "p9p": "Резултат:",
    "text": "Където ще научиш как се сравнява… няколко пъти наведнъж",
    "title": "Урок 17"
  },
  "l18": {
    "p10w": "Tук ще пиша в общ код. Ще започвам нов блок код с \"{\" на същия ред. Ако използваш C#, не забравяй, че ти трябва да поставяш \"{\" и \"}\" на следващия ред.",
    "p11pc": "int inp = input();\nif (inp >= 0) {\n\tprint(\"Валидни точки\").\n\tint result = inp * 50;\n}\n// Както е показано тук, може да има if и без else - това няма значение.\nprint(result);",
    "p12p": "Тук има грешка - възможно е числото in да е било по-малко от 0. Тогава if блока е бил пропуснат и променливата result никога не е била създадена, така че не може да се принтира. Всеки език би показал грешка за това.",
    "p13p": "Блоковете от код след if и else, стига да са един ред, могат да се записват и без {}. Само трябва да са на правилно разстояние от началото на реда (идентацията е важна). Това е удобно в някои случай, но лично аз не го използвам често:",
    "p14pc": "int num = 5;\nbool isEven = num % 2 == 0;\nif (isEven)\n\tprint(\"Четно\");\nelse print(\"Нечетно\"); // Може даже и на същия ред",
    "p15p": "Тук създаваме променливата num. След това имаме булевата променлива isEven - \"е четно\". Тя е равна на \"num % 2 == 0\". Това е проверката за четно число - % е деление с остатък, както знаеш. Ако числото е четно и го разделиш на 2, остатъкът винаги ще е нула - \"46 % 2 = 0\". Ако искаш да направиш проверка за нечетно, можеш да използваш \"num % 2 == 1\" или \"if (!isEven)\" (да обърнеш стойността на isEven чрез \"!\"). После идва и причината за подобното кръщаване на булевите променливи - получава се почти валидно английско изречение - \"if (isEven)… else…\" - Ако е четно… иначе…. Това го прави по-лесно за четене. След това имаме първия ред, който няма нужда от блок код и само е на нов ред. След него е \"else\", разстояние и кода.",
    "p16p": "Последното нещо, което трябва да ти обясня през този урок, е else if - но изглежда вече съм си свършил половината работа. Да се върнем на първия пример. Там имаме един общ случай, ако числото е негативно и равно на нула. Може да поправим това чрез else if. else if е просто долепен if до else на друг if, но записан на същия ред - като в примера горе:",
    "p17pc": "int num = 0;\nif (num > 0) {\n\tprint(\"Числото е позитивно\");\n}\nelse if (num < 0) {\n\tprint(\"Числото е негативно\");\n}\n// Това е същото като да напиша:\n// else {\n// \tif() {}\n// }\nelse {\n\tprint(\"Числото е 0\");\n}",
    "p18p": "Резултат:",
    "p19con": "Числото е 0",
    "p1p": "В предния урок научи за булевия тип и сравненията. В този урок ще учиш за по-големия (и по-полезен) брат на тернарито.",
    "p20p": "Първата проверка е дали числото е по-голямо от 0. То не е, значи пропускаме този блок. Отиваме на втората проверка - else if. Числото не е и по-малко от 0, значи пропускаме и този блок. Стигаме до else, в който се принтира \"Числото е 0\" към конзолата.",
    "p21p": "Както забеляза, и в този урок нямаше въпроси, и може би вече предполагаш, че ще ти дам задача. Прав си:",
    "p22rq": "Приеми цяло число \"x\" от конзолата. Ако е по-голямо от 60, изведи ново число по-формулата x*60 - 10. Ако е равно на 60 или по-голямо от 20, изведи ново число по формулата x*20  - 5. Ако не влиза в нито едно от тези условия, изведи ново число по формулата x*(-1) + 10.",
    "p2p": "Първо, подобно и на други неща, булевите типове имат конвенция за кръщаване. Прието е името да се изписва във формата: \"isClicked\". Буквален български превод - \"е натиснато\". Не го споменах досега нарочно, и в остатъка на този урок ще разбереш защо.",
    "p3p": "if. else. Това са двете най-важни думи за този урок - \"ако\" и \"иначе\". Така се проверява нещо в блок код. Например, ако бутонът е натиснат, изпълни един блок код. Ако дадено твърдение е вярно, изпълни блок код. Иначе изпълни друг блок код. Да видим примера:",
    "p4ds1": "Java",
    "p8p": "Числото е -2. Когато се стигне до if, имаме скоби. Там е твърдението - в този случай, то е условие. Ако то е правилно, изпълняваме първия блок код и продължаваме напред, пропускайки втория. Резултатът в конзолата е \"Числото е позитивно\". Ако пък не е вярно, както в нашия случай, пропускайки първия блок код, отиваме директно във втория, който е след else. Резултатът към конзолата е \"Числото е негативно или нула\".",
    "p9p": "Блоковете код могат да използват променливи, които вече са декларирани над тях; ако създадеш променлива в if или else блока, няма да можеш да я използваш надолу, тъй като е възможно тя никога да не се създаде. Например така:",
    "s5cj": "package tutorial;\n\npublic class Ifs {\n\t\n\tpublic static void main(String[] args) {\n\t\tint num = -2;\n\t\tif (num > 0) {\n\t\t\tSystem.out.println(\"Числото е позитивно\");\n\t\t}\n\t\telse {\n\t\t\tSystem.out.println(\"Числото е негативно или нула\");\n\t\t}\n\t}\n}",
    "s6ds2": "C#",
    "s7cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tint num = -2;\n\t\tif (num > 0) \n\t\t{\n\t\t\tConsole.WriteLine(\"Числото е позитивно\");\n\t\t}\n\t\telse \n\t\t{\n\t\t\tConsole.WriteLine(\"Числото е негативно или нула\");\n\t\t}\n\t}\n}",
    "text": "Където ще научиш как се контролира програма",
    "title": "Урок 18"
  },
  "l19": {
    "p10p": "Сега ще решиш и друга задача. Тя е класика. Трябва да приемеш брой точки от конзолата. Ако са равни на или над 90, принтирай \"Oтличен\" към конзолата. Ако са под 90 и равни на или над 80, принтирай \"Много добър\". Под 80 и равни на или над 70 - \"Добър\". Под 70 и равни на или над 60 - \"Среден\". За всичко под 60, принтирай \"Слаб\".",
    "p11rq": "Какво е уникалното на тази задача? Нима не се решава с много if else? Да, решава се, но ти няма да я решиш така. Искам да решиш тази задача със \"switch\". И аз няма да съм този, който ще ти го обясни - потърси го в Интернет, използвай преводач, ако се налага, за да гледаш източници на английски, разгледай сайтове. Задачата ти за този урок е да търсиш, а не да решаваш, тъй като аз не мога да ти обясня всичко - и ако искаш да програмираш, ще търсиш още много време. Съвет от мен - по-бързо е да прочетеш статия в уебсайт, отколкото да гледаш видео.",
    "p12p": "Късмет!",
    "p1p": "В този урок главно трябва да ти кажа за вложените if-ове. Защо? Има го в учебната програма.",
    "p2p": "Както може би предполагаш, в блока код на един if можеш да сложиш още if-ове. Ще го демонстрираме със следната задача:",
    "p3rq": "Създай низ със стойност \"Числото\". Ако дадено число е четно на 3, добави към низа \" е четно на 3\". Ако е четно и на 5, добави към низа \" и 5\". Накрая изведи низа към конзолата.",
    "p4p": "Опитай да решиш задачата сам преди да разгледаш кода. Лесно е. Не забравяй, че ако число се дели без остатък на друго число, то то е четно на него.",
    "p5ds1": "Java",
    "p9p": "Опитай се да обясниш този код по начина, по който аз правя обикновено. Прочети го на глас и си поиграй си с него. Даже промени условието, ако искаш.",
    "s6cj": "package tutorial;\n\npublic class Ifs {\n\t\n\tpublic static void main(String[] args) {\n\t\tString result = \"Числото\";\n\t\tint num = 15;\n\t\tif (num % 3 == 0) {\n\t\t\tresult += \" е четно на 3\";\n\t\t\t\n\t\t\tif (num % 5 == 0) {\n\t\t\t\t\t\tresult += \" и 5\";\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}",
    "s7ds2": "C#",
    "s8cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tstring result = \"Числото\";\n\t\tint num = 15;\n\t\tif (num % 3 == 0) {\n\t\t\tresult += \" е четно на 3\";\n\t\t}\n\t\tif (num % 5 == 0) {\n\t\t\tresult += \" и 5\";\n\t\t}\n\t\tConsole.WriteLine(result);\n\t}\n}",
    "text": "Където ще научиш как да пишеш проверки",
    "title": "Урок 19"
  },
  "l2": {
    "p10fq": "Колко е 10101101 + 01100110?",
    "p11h": "Изваждане",
    "p12pre": "\n 101\n-\n 011\n 010",
    "p13p": "Тук, първо изваждаме 1 от 1. Получаваме 0, и я записваме долу. След това се опитваме да извадим 1 от 0.  Но не можем, защото 0 е по-малко от 1. Значи, взимаме 1 на ум от следващата колонка. Получаваме 2-1, което вече е 1. Записваме 1 долу. След това, трябва да извадим 1-0. Обаче сме взели 1 на ум, тоест ни остава 0-0. Записваме 0 долу. И имаме резултат. Да направим проверка: 101 е 5. 011 е 3. 010 е 2. Значи сме работили правилно.",
    "p14fq": "Запиши резултата на 10011 - 101",
    "p15h": "Умножение",
    "p16p": "Умножението на двоични числа е абсолютно същото като на десетични. Разлика няма. Важно е да не забравяш, че събираш двоични числа, не десетични.",
    "p17pre": "\n1101*11 \n   1101\n  1101\n 100111",
    "p18fq": "Запиши резултата на 101 * 011",
    "p19h": "Деление",
    "p1p": "В този урок ще се научиш да събираш, умножаваш, изваждаш и делиш с други бройни системи. Подобно на цялата тема за други бройни системи и това не е сложно.",
    "p20p": "Делението на числа в други бройни системи е сравнително по-трудоемко. Най-лесният начин е да превърнеш числата в десетична бройна система, да ги разделиш и резултата да превърнеш в двоично число. Например:",
    "p21pre": "\n110 / 011\n110 = 1 * 4 + 1*2 + 0*1 = 6\n011 = 0*4 + 1*2 + 0*1 = 3",
    "p22p": "Вече виждаме, че 6/3 = 2. Превръщаме 2 в двоична бройна система и получаваме 010. Следователно:",
    "p23pre": "\n110 / 011 = 010",
    "p2h": "Събиране",
    "p3p": "Нека първо да съберем две числа в десетичната бройна система - 96 и 56.",
    "p4pre": "\n 96 \n + \n 56 \n152",
    "p5p": "Правил/а си това много пъти - слагаш двете числа едно под друго. Събираш първата колона отдясно наляво. Ако сборът е по-малък от 10, го записваш долу. Ако е по-голям или равен на 10, например 12, слагаш едно на ум на следващата колонка и записваш последната цифра - 2  (или записано по друг начин, разликата на 12 и 10). Това се повтаря с всички колонки.",
    "p6p": "Събирането на числа в двоичната бройна система всъщност е същото. Само че вместо да следим за 10, следим за 2 - базата на системата. Тоест, ако сборът на колонка е по-малък от 2, го записваме, иначе слагаме едно на ум на следващата колонка и записваме разликата на сбора и 2. Нека да пробваме:",
    "p7pre": "\n 101 \n + \n 011 \n1000",
    "p8p": "Първо събираме 1 и 1. Получава се 2, което е равно на две. Следователно пишем 1 на ум над следващата колонка и записваме 2-2 = 0. На следващата колонка събираме 0 и 1 и получаваме 1, но имаме 1 на ум, следователно сборът е 2. Слагаме 1 на ум, записваме 0 и продължаваме. На следващата колонка събираме 1 и 0, получаваме 1. Имаме 1 на ум, събираме и него, и получаваме 2. Пишем 1 на ум на следващата колонка. Записваме 0. Последната колонка е празна, затова пишем просто 1 (от предното 1 на ум). Получаваме 1000. Нека да направим проверка. 101 е 5. 011 е 3. 1000 е 8. Значи сме работили правилно.",
    "text": "Където ще научиш как се събират и изваждат числа… отново",
    "title": "Урок 2"
  },
  "l20": {
    "p13p": "Надявам се да си имал/а \"Еврика\" момент, когато си видял/а кода отгоре. Ако не си, явно е мой ред да ти обясня. Както по-горе, създаваме променлива num. Тя е равна на 0. След това имаме while и условие. Докато това условие е изпълнено, кода в блока ще продължи да се изпълнява. Тоест, ако спираме кода, всеки път когато направи стъпка, ще имаме подобно:",
    "p14p": "num е 0, по-малко от 10. Продължи цикъла.",
    "p15p": "num++;",
    "p16p": "num е 1, по-малко от 10. Продължи цикъла.",
    "p17p": "num++;",
    "p18p": "num е 2, по-малко от 10. Продължи цикъла.",
    "p19p": "num++;",
    "p1p": "Време е да се върнем назад във времето. Към далечните времена на Assembly езика. Освен многото си други проблеми, той не може да повтори едно действие няколко пъти. Всичко, с което са разполагали програмистите, е проверки и goto. goto е една доста опасна команда, защото може да въздейства на стака по неочаквани начини. Когато се стигне до команда goto <ред>, изпълнението на кода отива на дадения ред. В този урок ще използвам нашия си общ код с командата goto, защото Assembly не е предназначен за обучителни програми. Ако се интересуваш допълнително, можеш да погледнеш как изглежда в Интернет.",
    "p20p": "…",
    "p21p": "num е 10, 10 не е по-малко от 10. Прекъсни цикъла.",
    "p22p": "И кодът продължава изпълнението си.",
    "p23p": "Но може би забелязваш лек проблем - в goto кода, първо добавяме едно към num и след това започва цикълът. А тук, започваме добавянето едва след като проверим условието първия път. За този проблем има решение - do {} while();",
    "p24p": "Да видим кода:",
    "p25ds1": "Java",
    "p29p": "Разликата е, че кодът в do блока ще се изпълни поне веднъж преди проверката на условието. Тоест, програмата е нещо такова:",
    "p2pc": "int num = 5;\ngoto 1;",
    "p30p": "num++;",
    "p31p": "num е 1, по-малко от 10. Продължи цикъла.",
    "p32p": "num++;",
    "p33p": "num e 2, по-малко от 10. Продължи цикъла.",
    "p34p": "num++;",
    "p35p": "num е 3, по-малко от 10. Продължи цикъла.",
    "p36p": "num++;",
    "p37p": "…",
    "p38p": "num е 10, 10 не е по-малко от 10. Прекъсни цикъла.",
    "p39p": "За горната задача има и различен подход - чрез безкраен цикъл и break;. break може да се използва в цикли, и ако кодът го достигне, той приключва цикъла. Как е направен безкрайния цикъл?",
    "p3p": "Това е най-простия възможен пример за goto. Програмата започва от ред 1, създава променлива със стойност 5, стига до goto 1; и се връща на първия ред. Това е циклично действие - повтаря се много пъти. Такъв код е наричан цикъл. Името \"цикъл\" си е останало и до днес, въпреки че (по добри причини) goto е несъществуваща команда в повечето езици и в днешно време използваме \"по-цивилизовани\" методи. Въпреки това, ще останем в миналото за още един пример.",
    "p40ds1": "Java",
    "p44p": "В безкрайния цикъл (while (true)), на всяка стъпка добавяме 1 към променливата num. Ако стойността на num е по-малка от 10, изпускаме блока код на if и продължаваме. Ако не е, достигаме break;, което прекъсва цикъла while. Продължаваме програмата.",
    "p45rq": "Създай програма, която приема цяло число x от конзолата. След това използвай цикъл, за да преминеш през всяко число от 1 до 100. Ако x се дели на дадено число в цикъла без остатък, тоест му е кратно, изведи това число на конзолата.",
    "p4p": "Цикълът горе има един голям проблем - той никога няма да спре. Той ще продължи да работи до изключване на програмата. Това не е лошо - реално е начина, по който държим всяка програма жива - независимо дали е браузърa ти или любимата ти игра, някъде във въпросната програма има подобен цикъл, който държи всичко работещо.",
    "p5p": "Проблемът със спирането се решава по-много лесен начин:",
    "p6pc": "int num = 0;\nnum++;\nif (num < 10) {\n\tgoto 2;\n}",
    "p7p": "Първо създаваме променливата num. След това добавяме едно към нея. Ако num е по-малка от 10, то се връщаме на ред 2 и добавяме едно отново. Това ще продължи, докато числото е 10. Тогава условието num < 10 няма да е правилно и програмата ще продължи, излизайки от цикъла.",
    "p8p": "Да се върнем в настоящето. За горния код бихме използвали while() {} (\"докато\"). Ето го и него - точно преведен, със същия резултат:",
    "p9ds1": "Java",
    "s10cj": "int num = 0;\nwhile (num < 10) {\n\tnum++;\n}",
    "s11ds2": "C#",
    "s12cc": "int num = 0;\nwhile (num < 10) \n{\n\tnum++;\n}",
    "s26cj": "int num = 0;\ndo {\n\tnum++;\n} while (num < 10);",
    "s27ds2": "C#",
    "s28cc": "int num = 0;\ndo \n{\n\tnum++;\n} while (num < 10);",
    "s41cj": "int num = 0;\nwhile (true) {\n\tnum++;\n\tif (num < 10) {\n\t\tbreak;\n\t}\n}",
    "s42ds2": "C#",
    "s43cc": "int num = 0;\nwhile (true) \n{\n\tnum++;\n\tif (num < 10) \n\t{\n\t\tbreak;\n\t}\n}",
    "text": "Където ще научиш защо програмите не се затварят веднага",
    "title": "Урок 20"
  },
  "l21": {
    "p13p": "Това е какво се очаква от теб - създаваш променлива с начална стойност 1000. Докато тя е по-голяма от 0, принтирай сегашната и стойност и извади 1. В някакъв момент ще се стигне до нула, цикълът ще спре и програмата ще завърши.",
    "p14p": "Това обаче е доста писане. Да разделим този цикъл на няколко части.",
    "p15p": "Първо създаваш променлива, с която да действа цикъла.",
    "p16p": "След това имаш условието за работа на цикъла.",
    "p17p": "Накрая имаш изваждане на 1 от променливата - осигуровка, че цикълът ще спре.",
    "p18p": "Между всичко това има един единствен ред код, който е част от логиката на програмата. Всичко друго е просто за да действа цикъла - 3-4 реда. Представи си, ако в цикъла имаше 10 реда логика - щеше да стане объркващо какво правиш с контролиращата променлива.",
    "p19p": "Можем да се справим по-добре от това!",
    "p1p": "В този урок ще научиш последния вид цикъл - for.",
    "p20p": "За тази цел ще използваме for цикъла. Той взима всяка една от тези 3 части, и ги обединяване в една - създаване на променлива, условие и манипулация на променлива.",
    "p21p": "Променливата, която задвижва for цикъла, е прието да се нарича само \"i\" (\"ай\"). Идва от iterator (\"итератор\"), защото циклите \"итерират\" чрез нея (преминават през нея). Ако в цикъла има друг цикъл, или по някаква друга причина \"i\" вече е заето име на променлива, се продължава по азбучен ред - \"j\". Ако и \"j\" не е свободна, се продължава към \"k\", \"l\", \"m\", \"n\", \"o\"… (ако стигнеш до \"o\" ти препоръчвам да станеш, да изключиш компютъра, да се поразходиш из природата и да се зачудиш какво правиш).",
    "p22p": "Време е да видим кода на for цикъла чрез горната задача:",
    "p23ds1": "Java",
    "p27p": "В скобите на for цикъла се приемат 3 неща - първото е създаване на променливи. Няма никакво значение какво създадеш там - ако искаш, можеш да създадеш и String, или просто да го оставиш празно. След това има точка и запетая и следва второто нещо - твърдение. Няма значение какво е твърдението, стига да може да стане true или false. Ако искаш, можеш да напишеш само true вътре и ще създадеш безкраен цикъл (не забравяй, че има и break; команда). След това отново точка и запетая. Накрая е манипулацията - тя също може да е празна, или може да е i++, i--. Може да използваш i = i * 5. Стига стойността на променливата да се промени (или да не се, ако цялото поле е празно), то цикъла ще се изпълни.",
    "p28rq": "Вземи низ от конзолата. След това, използвайки for цикъл, го принтирай на конзолата обърнат. Припомни си как се взимам символ на специфичен индекс в низ и как се взима дължина на низ. Не забравяй, че можеш да принтираш и без нов ред, или да долепяш до празен низ.",
    "p2p": "Представи си следната ситуация - трябва да направиш програма, която принтира числата от 5 до 1 на конзолата. \"Лесно!\", казваш ти, и създаваш нещо от този род:",
    "p3pc": "print(5);\nprint(4);\nprint(3);\nprint(2);\nprint(1);",
    "p4p": "Резултат:",
    "p5con": "5\n4\n3\n2\n1",
    "p6p": "\"Страхотно!\", казваш си, решил задачата. Изведнъж идва твоя учител и ти казва: \"А сега го направи да принтира числата от 1000 до 1!\".",
    "p7p": "Лошо. Ти се сещаш за циклите и създаваш това:",
    "p8rq": "Преди да погледнеш кода, опитай се сам да решиш задачата.",
    "p9ds1": "Java",
    "s10cj": "int countdownNumber = 1000; // Превод - число на брояча\nwhile (countdownNumber > 0) {\n\tSystem.out.println(countdownNumber);\n\tcountdownNumber--;\n}",
    "s11ds2": "C#",
    "s12cc": "int countdownNumber = 1000; // Превод - число на брояча\nwhile (countdownNumber > 0) \n{\n\tConsole.WriteLine(countdownNumber);\n\tcountdownNumber--;\n}",
    "s24cj": "for (int i = 1000; i > 0; i--) {\n\tSystem.out.println(i);\n}",
    "s25ds2": "C#",
    "s26cc": "for (int i = 1000; i > 0; i--) \n{\n\tConsole.WriteLine(i);\n}",
    "text": "Където ще научиш как се брои",
    "title": "Урок 21"
  },
  "l22": {
    "p10p": "Това е текстовата част. Следва кода:",
    "p11ds1": "Java",
    "p15p": "Резултат:",
    "p16con": "Георги",
    "p17con": "Петър",
    "p18p": "Това е хубаво, но нима ще трябва да направим масив с 10 или повече елемента и да ги инициализираме един по един, ред по ред? Това беше половината от проблема в оригиналната задача!",
    "p19p": "За това също има измислено решение. Има и друг начин за инициализация на масиви:",
    "p1p": "Представи си, че имаш списък с 10 имена. Трябва да ги добавиш в програма, така че по-късно да имаш достъп до тях. Как би го направил?",
    "p20ds1": "Java",
    "p24p": "Резултат:",
    "p25con": "Георги",
    "p26con": "Петър",
    "p27p": "В този код използваме директна инициализация чрез {}. В тези скоби се записват елементите на масива, разделени от запетаи. Автоматично се избира големината на масива - в този случай 3. Всеки елемент си попада на индекса, според реда в който са написани - тук \"Виктор\" е 0. По този начин се избягват множеството редове.",
    "p28rq": "Избери 10 първи и 10 последни имена. Напълни 2 масива с тях. Всеки път, когато се стартира програмата, на конзолата да се изписва съобщения от типа \"Здравей, <случайно избрано от масив първо име> <случайно избрано от масив последно име>\". Поиграй си с комбинациите или добави още имена.",
    "p2p": "Към сегашния момент нямаш много избор - трябва да направиш много променливи. Много. По-късно, всеки път, когато трябва да използваш име, трябва да използваш някоя от променливите. Изведнъж обаче идва шефа ти и казва:",
    "p3p": "- Искам всеки път, когато се отвори програмата, да показва различни имена!",
    "p4p": "Това може да се направи със сегашните ти знания - с много if-ове или огромен switch. Все пак, какво правим, ако имената станат 100 или 1000? (най-вероятно не пишем имената в кода, а използваме текстов файл и зареждаме имената от него, но нека да игнорираме това в името на примера)",
    "p5p": "За тази цел съществуват масивите. Масивите са списъци. Всяко нещо в списъка е елемент. Всеки масив си има тип - това е типа на елементите в масива. Масив с тип низ не може да съдържа цяло число. Масивите имат точно определена големина, която не може да се променя след създаването на масива. На всеки елемент съответства индекс. Индексите започват от 0. Нормално е това да ти звучи познато, защото низовете наистина използват същата система - все пак, низът е просто списък от символи, с други думи, масив от символи.",
    "p6p": "Масивите изглеждат удобно за нашия случай, нали? Имаме списък от имена. Можем да направим масив, да сложим имената вътре и имаме една променлива с цялата ни нужна информация. Чрез индексите можем да си изберем точен елемент, тоест точно име, или да генерираме случайно число и по този начин да вземем случайно име от масива.",
    "p7p": "Масивите се показват с [] след типа. Масив от цели числа е int[]. Когато създаваме масив, трябва да запишем колко елемента могат да се съдържат в него. Индексите започват от 0. Тоест, в масив с големина 10, първият индекс ще е 0 и последният ще е 9. За твоя радост,  ако опиташ да достигнеш индекс, който не съществува в Java или C# (напр. 10 в масив с големина 10), ще ти даде грешка. Защо да си щастлив? В някои от по-старите езици се приема, че индексът съществува и се взима от следващите байтове в паметта. Да кажем, че се получават известни проблеми.",
    "p8p": "Когато създадеш масив, индексите се запълват с една уникална стойност - null. Това не е низ или цяло число, а просто нищо. Докато не използваш индекса, за да промениш тази стойност, тя ще си седи така.",
    "p9p": "Ако влезеш в тоалетната и видиш, че има тоалетна хартия в поставка, то имаш стойност - например низ \"тоалетна хартия\". Ако няма тоалетна хартия на поставката, а само ролка, имаш празен низ - \"\". Все пак може да се сложи тоалетна хартия, има \"нещо\". Ако влезеш и видиш, че поставката е празна, това е null - няма тоалетна хартия и няма ролка. Ти може да не познаеш, че поставката е за тоалетна хартия, както език за програмиране не може да познае нищо за null. Последния тип състояние е undefined (недефинирано). Той съществува само в някои езици (не е в Java или C#), най-известният от които е JavaScript. Това е все едно поставката да е изкъртена и да няма нищо там. Няма поставка, няма ролка, няма тоалетна хартия.",
    "s12cj": "package tutorial;\n\npublic class ArraysTutorial {\n\n\tpublic static void main(String[] args) {\n\t\tString[] names = new String[3]; // Създаване на масив от низове с 3 елемента\n\t\t// В момента всички елементи са null, тоест трябва да им присвоим стойности като ги достигнем\n\t\t// Това става чрез индекса\n\t\tnames[0] = \"Виктор\";\n\t\tnames[1] = \"Теодора\";\n\t\tnames[2] = \"Георги\";\n\t\tSystem.out.println(names[2]); // Елементите на масива са просто променливи; можем да правим каквото си искаме с тях\n\t\t// По-късно можем да променим и стойност в индекс\n\t\tnames[2] = \"Петър\";\n\t\tSystem.out.println(names[2]);\n\t}\n\n}",
    "s13ds2": "C#",
    "s14cc": "using System;\n\npublic class ArraysTutorial \n{\n\n\tpublic static void Main()\n\t{\n\t\tstring[] names = new string[3]; // Създаване на масив от низове с 3 елемента\n\t\t// В момента всички елемент са null, тоест трябва да им присвоим стойности като ги достигнем\n\t\t// Това става чрез индекса\n\t\tnames[0] = \"Виктор\";\n\t\tnames[1] = \"Теодора\";\n\t\tnames[2] = \"Георги\";\n\t\tConsole.WriteLine(names[2]); // Елементите на масива са просто променливи; можем да правим каквото си искаме с тях\n\t\t// По-късно можем да променим и стойност в индекс\n\t\tnames[2] = \"Петър\";\n\t\tConsole.WriteLine(names[2]);\t\n\t}\n\n}",
    "s21cj": "package tutorial;\n\npublic class ArraysTutorial {\n\n\tpublic static void main(String[] args) {\n\t\tString[] names = {\"Виктор\", \"Теодора\", \"Георги\"};\n\t\tSystem.out.println(names[2]); \n\t\tnames[2] = \"Петър\";\n\t\tSystem.out.println(names[2]);\n\t}\n\n}",
    "s22ds2": "C#",
    "s23cc": "using System;\n\npublic class ArraysTutorial \n{\n\n\tpublic static void Main()\n\t{\n\t\tstring[] names = {\"Виктор\", \"Теодора\", \"Георги\"};\n\t\tConsole.WriteLine(names[2]); \n\t\tnames[2] = \"Петър\";\n\t\tConsole.WriteLine(names[2]);\n\t}\n}",
    "text": "Където ще научиш как да работиш с много информация",
    "title": "Урок 22"
  },
  "l23": {
    "p10p": "В такъв случай, може би наистина трябва да се научиш да принтираш масиви.",
    "p11p": "Когато искаш да принтираш масив, искаш да принтираш елементите му в конзолата по този начини:",
    "p12p": "Очакван резултат:",
    "p13con": "Виктор\nТеодора\nГеорги",
    "p14p": "Тоест, може да направиш нещо подобно:",
    "p15ds1": "Java",
    "p19p": "Което ще има очаквания резултат... докато масива не стане 10 елемента. Или 50. Какво правим на 1000? А с големина, въведена от потребителя?",
    "p1p": "В този урок ще те науча да принтираш масиви в конзолата. Не се шегувам.",
    "p20p": "Значи ни трябва повтарящо се действие, задвижвано от променлива от тип цяло число. Трябва да е с начална стойност 0 и на всяка итерация да се увеличава с 1. И когато достигне максимална стойност, трябва повторението да спре. Хмммммм, къде ли съм виждал това? Можем да използваме for цикъл, но ни трябва дължината на масива. При Java използваме names.length, а в C# - names.Length. И двете са цели числа, показващи дължината на масив. length означава \"дължина\". За всеки друг масив просто се сменя името на променливата.",
    "p21p": "Код:",
    "p22ds1": "Java",
    "p26p": "Резултат:",
    "p27con": "Виктор\nТеодора\nГеорги",
    "p28p": "Създаваме масив с 3 елемента. След това пишем for цикъл. Първият индекс в масив е 0, тоест променливата i е с начална стойност 0. На всяка итерация увеличаваме i с 1 чрез i++. Условието е дали i е по-малко от големината на масива. Големината на масива е 3, но това не е валиден индекс (2 е максимума, защото масивът започва от 0). Затова използваме <. 0 е по-малко от 3, затова принтираме първия елемент. 1 също е по-малко от 3. 2 е по-малко от 3. Когато стигнем до 3, то не е по-малко от 3 (големината), а равно на 3, тоест цикълът спира. На всяка итерация принтираме елемента с индекс равен на i.",
    "p29p": "Всъщност, когато ти казах, че for е последния цикъл те излъгах. Има още един. Той е познат като foreach цикъла и ти спестява писането за по-лесни задачи за итерация през масиви. Изглежда така:",
    "p2p": "В момента най-вероятно се чудиш \"Не мога ли просто да направя това?:\"",
    "p30ds1": "Java",
    "p34p": "В този цикъл записваме променлива от типа на масива, след това самия масив, както е показано в кода. На всяка итерация променливата сменя стойността си спрямо броя на итерациите. В този случай, на първата итерация променливата е \"Виктор\", на втората е \"Теодора\" и на третата е \"Георги\". След като приключи с масива, цикълът спира. foreach е по-бърз за писане, защото спеставяш условието и променливата брояч, но няма възможностите на нормалния for. Въпреки това е перфектен за бързо принтиране като в нашия случай.",
    "p35rq": "Създай 2 масива, като запълниш първия с лични имена, а втория - с фамилни. Когато програмата стартира, питай потребителя колко двойки имена иска. Приеми цяло число. След това, с помощта на цикъл, генерирай въведения брой двойки лично-фамилия, като имената са случайно избрани от двата масива. Принтирай ги в конзолата, като на всеки ред принтираш по една двойка.",
    "p36rq": "Направи програма, която изисква потребителя да въведе брой числа, след това да въведе и самите числа. Да се изведе сборът на числата. Не забравяй, че можеш да взимаш вход от конзолата и в цикли. Тази задача може да се реши и без масиви, така че пробвай.",
    "p37p": "Пример:",
    "p38p": "Вход:",
    "p39con": "3 // това означава, че трябва да очакваш 3 числа\n1\n6\n3",
    "p3ds1": "Java",
    "p40p": "Изход:",
    "p41con": "10 // сборът на 1, 6 и 3",
    "p7p": "Да, можеш. Дори няма да получиш грешка. Всъщност, пробвай. В момента.",
    "p8p": "Пробва ли?",
    "p9p": "Приемам, че вече си пробвал и си получил или \"[Ljava.lang.String;@случайно число\", ако работиш с Java, или \"System.String[]\", ако работиш с C#.",
    "s16cj": "package tutorial;\n\npublic class ArraysTutorial {\n\tpublic static void main(String[] args) {\n\t\tString[] names = {\"Виктор\", \"Теодора\", \"Георги\"};\n\t\tSystem.out.println(names[0]);\n\t\tSystem.out.println(names[1]);\n\t\tSystem.out.println(names[2]);\n\t}\n}",
    "s17ds2": "C#",
    "s18cc": "using System;\n\npublic class ArraysTutorial \n{\n\tpublic static void Main()\n\t{\n\t\tstring[] names = {\"Виктор\", \"Теодора\", \"Георги\"};\n\t\tConsole.WriteLine(names[0]);\n\t\tConsole.WriteLine(names[1]);\n\t\tConsole.WriteLine(names[2]);\n\t}\n}",
    "s23cj": "package tutorial;\n\npublic class ArraysTutorial {\n\tpublic static void main(String[] args) {\n\t\tString[] names = {\"Виктор\", \"Теодора\", \"Георги\"};\n\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\tSystem.out.println(names[i]);\n\t\t}\t\n\t}\n}",
    "s24ds2": "C#",
    "s25cc": "using System;\n\npublic class ArraysTutorial \n{\n\tpublic static void Main()\n\t{\n\t\tstring[] names = {\"Виктор\", \"Теодора\", \"Георги\"};\n\t\tfor (int i = 0; i < names.Length; i++) {\n\t\t\tConsole.WriteLine(names[i]);\n\t\t}\n\t}\n}",
    "s31cj": "package tutorial;\n\npublic class ArraysTutorial {\n\tpublic static void main(String[] args) {\n\t\tString[] names = {\"Виктор\", \"Теодора\", \"Георги\"};\n\t\tfor (String ime : names) {\n\t\t\tSystem.out.println(ime);\n\t\t}\t\n\t}\n}",
    "s32ds2": "C#",
    "s33cc": "using System;\n\npublic class ArraysTutorial \n{\n\tpublic static void Main()\n\t{\n\t\tstring[] names = {\"Виктор\", \"Теодора\", \"Георги\"};\n\t\tforeach (string ime in names) {\n\t\t\tConsole.WriteLine(ime);\n\t\t}\n\t}\n}",
    "s4cj": "package tutorial;\n\npublic class ArraysTutorial {\n\tpublic static void main(String[] args) {\n\t\tString[] names = {\"Виктор\", \"Теодора\", \"Георги\"};\n\t\tSystem.out.println(names);\n\t}\n}",
    "s5ds2": "C#",
    "s6cc": "using System;\n\npublic class ArraysTutorial \n{\n\tpublic static void Main()\n\t{\n\t\tstring[] names = {\"Виктор\", \"Теодора\", \"Георги\"};\n\t\tConsole.WriteLine(names);\n\t}\n}",
    "text": "Където ще разбереш връзката между последните уроци",
    "title": "Урок 23"
  },
  "l24": {
    "p10p": "{2, 5, 4, 6, 8} си остава {2, 5, 4, 6, 8}, защото 6 < 8, тоест не се извършва смяна",
    "p11p": "Първото преминаване приключва.",
    "p12p": "Започва второто преминаване - отново се започва с първото число, този път 2. Повтаря се действието.",
    "p13p": "{2, 5, 4, 6, 8} си остава {2, 5, 4, 6, 8}, защото 2 < 5",
    "p14p": "{2, 5, 4, 6, 8} се превръща в {2, 4, 5, 6, 8}, защото 5 > 4",
    "p15p": "{2, 4, 5, 6, 8} си остава {2, 4, 5, 6, 8}, защото 5 < 6",
    "p16p": "{2, 4, 5, 6, 8} си остава {2, 4, 5, 6, 8}, защото 6 < 8",
    "p17p": "Завършва третото преминаване. Ние виждаме, че вече масивът е сортиран. Програмата ти няма как да знае това, от друга страна. Започва още едно преминаване. В това преминаване няма да има нито една смяна. Това значи, че масивът вече е сортиран.",
    "p18p": "Може би вече разбираш защо този алгоритъм е бавен. Всички тези преминавания, всички тези смени. Всъщност, ако масивът ти има 5 елемента, този алгоритъм ще продължи 5*5 единици време - 5 преминавания по 5 проверки, ако не го спрем веднага щом не е имало сменяне в преминаване. Ако има 100 елемента, става 10 000 единици време. Да разгледаме нещо друго.",
    "p19h": "Selection sort",
    "p1p": "В този урок ще те науча как се сортират масиви. И още няколко неща.",
    "p20p": "Selection sort, или \"сортиране чрез метода на пряката селекция\", е прост метод за сортиране. За жалост, има същия проблем с бързината като Bubble sort. Най-бързия метод към момента на писане на това би трябвало да е Quicksort (\"бързо сортиране\"). Но така или иначе, училищната програма изисква да знаеш Selection sort.",
    "p21p": "Да вземем отново нашия масив - {6, 2, 5, 3, 8}. Този алгоритъм също се занимава с преминавания.",
    "p22p": "Избираме първото число - 6. Това е минимума засега. След това сравняваме 6 с 2. 2 е по-малко, следователно 2 става минимума. След това сравняваме 2 с 5, 3 и 8. Нито едно от тези числа не е по-малко от минимума (2), следователно накрая 6 и 2 си разменят местата. Масивът става {2, 6, 5, 3, 8}.",
    "p23p": "За второто преминаване, второто число от масива става нашия минимум. В този случай, това е 6. Извършваме сравняване с 5. 5 е по-малко от 6, значи 5 става минимума. 3 е по-малко от 5, значи 3 става минимума. 8 не е по-малко от 3, значи 3 остава минимума в края на преминаването. Сменя позициите си с второто число в масива. Той става {2, 3, 5, 6, 8}.",
    "p24p": "На третото преминаване третото число е минимума - 5. 5 е по-малко от 6 и по-малко от 8, което означава, че масивът е сортиран и няма нужда от смяна. Повечето имплементации биха продължили и с четвърто и пето преминаване, но ние ще приключим тук.",
    "p25p": "Сега искам да отвориш IDE-то си и да напишеш тези алгоритми в код. Преди и двете имплементации да са готови, не си и помисляй да се върнеш тук.",
    "p26a1": "Да",
    "p26a2": "Не",
    "p26tq": "Написа ли кода на алгоритмите за сортиране?",
    "p27h": "Моето решение",
    "p28ds1": "Java",
    "p2p": "Сортирането на масиви се извършва чрез определени алгоритми. Ще разгледаме 2 от тях. Не бих ги учил наизуст на твое място, но ако искаш - изборът е твой.",
    "p32p": "Резултат:",
    "p33con": "2\n3\n5\n6\n8",
    "p3h": "Bubble sort",
    "p4p": "Bubble sort, тоест \"сортирането с мехурчета\" или както би казал някой учител \"сортиране с метода на мехурчетата\", е един от най-бавните методи за сортиране. Също и един от най-простите.",
    "p5p": "Имаш масива от числа {6, 2, 5, 3, 8}.",
    "p6p": "Алгоритъмът започва итерация през числата на масива. Първото преминаване през всички числа започва. С масива се случва следното:",
    "p7p": "{6, 2, 5, 4, 8} се превръща в {2, 6, 5, 4, 8}, защото 6 > 2",
    "p8p": "{2, 6, 5, 4, 8} се превръща в {2, 5, 6, 4, 8}, защото 6 > 5",
    "p9p": "{2, 5, 6, 4, 8} се превръща в {2, 5, 4, 6, 8}, защото 6 > 4",
    "s29cj": "package tutorial;\n\nimport java.util.Arrays;\n\npublic class Sort {\n\t\n\tpublic static void main(String[] args) {\n\t\tint[] arr = {6, 2, 5, 3, 8};\n\t\tArrays.sort(arr);\n\t\t\n\t\tfor(int i = 0; i < arr.length; i++) {\n\t\t\tSystem.out.println(arr[i]);\n\t\t}\n\t}\n}",
    "s30ds2": "C#",
    "s31cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tint[] arr = {6, 2, 5, 3, 8};\n\t\tArray.Sort(arr);\n\n\t\tfor(int i = 0; i < arr.Length; i++) \n\t\t{\n\t\t\tConsole.WriteLine(arr[i]);\n\t\t}\n\t}\n}",
    "text": "Където ще научиш как да сортираш… и как да не го правиш",
    "title": "Урок 24"
  },
  "l25": {
    "p11p": "Второто число за големина е 6 - това е количеството колони. Първото е 5 - то е количеството редове на колона. Тоест, тази матрица ще има 6 колони с по 5 реда.",
    "p12p": "Ако искаме да променим числото на ред 3 на колона 4, бихме написали:",
    "p13ds1": "Java",
    "p17p": "Нормално е да се объркваш от това. Аз също го правя, когато работя с матрици.",
    "p19ds1": "Java",
    "p19p": "За да ти помогна, ще принтираме матрицата на конзолата. Това става чрез вложен цикъл - имаме итерация, за да преминем през всеки масиви в масива, и още една итерация, за да минем през числата на избрания масив. За да ти е по-лесно, ще използвам foreach цикъл за Java. Oпитай да го направиш с нормален for. Ако си на C#, потърси защо не правя примера с foreach",
    "p1p": "Представи си една таблица. Тя има колони и редове. Всяка колона и всеки ред има уникален идентификатор. Когато колона се пресекат се образува клетка. Всяка клетка има адрес, комбинация от идентификаторите на пресичащите се колона и ред. Има списък от колони и списък от редове. Всъщност, можем да представим всяка от колоните като просто списък от редове. Масивът е тип, тоест можем да създадем масив от масиви - списък от колони, като всяка колона е списък от редове. Ще направим именно това в този урок.",
    "p23rq": "Създай матрица с 10 колони, всяка с по 10 реда. Напълни я със случайно генерирани числа. Разучи диагоналите в матрици. След това изведи сбора на всички числа по главния диагонал, умножен по разликата на всички числа от вторичния диагонал.",
    "p2p": "Това може да звучи сложно и наистина е. Не се използва много често, но е хубаво да го знаеш за този един път, в който ще се появи.",
    "p3p": "Нормалният масив е едноизмерен. Той е просто списък от елементи. Ако използваме масив като типа за елементите на масив, ще получим масив пълен с масиви. На всеки индекс има масив, пълен със своите собствени индекси и елементи. Това е двуизмерен/двумерен масив.",
    "p4p": "Сам можеш да предположиш как се казва масив от масиви от тип масив.",
    "p5p": "Двумерните масиви също се наричат и матрици. Пикселите по твоя екран, подредени в колони и редове също са матрица. Как мислиш, че всеки пиксел се представя програмно?",
    "p6p": "Така се създава двумерен масив:",
    "p7ds1": "Java",
    "s10cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tint[,] matrix = new int[5, 6];\n\t}\n}",
    "s14cj": "package tutorial;\n\npublic class Matrix {\n\t\n\tpublic static void main(String[] args) {\n\t\tmatrix[3][4] = 5;\n\t}\n}",
    "s15ds2": "C#",
    "s16cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tmatrix[3, 4] = 5;\n\t}\n}",
    "s20cj": "package tutorial;\n\npublic class Matrix {\t\n\tpublic static void main(String[] args) {\n\t\tint[][] matrix= new int[5][6];\n\t\t\n\t\tfor(int[] i : matrix) { // i е от тип int[], защото arr а масив от масиви\n\t\t\tfor (int j : i) { // j е елемент от масива i\n\t\t\t\tSystem.out.print(j); // тоест можем да принтираме числото j\n\t\t\t}\n\t\t\tSystem.out.println(); // след като сме принтирали всички числа от един масив, слагаме нов ред и продължаваме на следващия\n\t\t}\n\t}\n}",
    "s21ds2": "C#",
    "s22cc": "using System;\n\t\t\t\t\t\npublic class Program\n{\n\tpublic static void Main()\n\t{\n\t\tint[,] arr= new int[5, 6];\n\t\tfor (int i = 0; i < arr.GetLength(0); i++) // .GetLength(0) връща големината на масива с масиви - първото измерение, броено като 0\n\t\t{ \n\t\t\tfor (int j = 0; j < arr.GetLength(1); j++)  // .GetLength(1) връща големината на масив от списъка с масиви - второто измерение, броено от 1\n\t\t\t{ \n\t\t\t\tConsole.Write(arr[i, i]); // Искаме числото на сегашната колона и ред\n\t\t\t}\n\t\t\tConsole.WriteLine(); // след като сме принтирали всички числа от един масив, слагаме нов ред и продължаваме на следващия\n\t\t}\n\t}\n}",
    "s8cj": "package tutorial;\n\npublic class Matrixes {\n\t\n\tpublic static void main(String[] args) {\n\t\tint[][] matrix = new int[5][6];\n\t}\n}",
    "s9ds2": "C#",
    "text": "Където ще научиш, че измеренията са повече от едно",
    "title": "Урок 25"
  },
  "l26": {
    "p10p": "-\tТова изчисление! - Даниел му пробутва няколко листа - Има много по-ефективен начин да го правим! По-добър!",
    "p11p": "Измореният поглед на Петър преминава с поглед листите като скенер търсещ целта си. Намира това, което търси. Изведнъж кръвта му спира. Зачита се по-сериозно в един от листовете, изражението му ставащо по- и по-бледо с всеки ред, докато накрая изглежда все едно ръката му може да мине през лицето му.",
    "p12p": "-\tНе мога да заменя това! Не и днес! - почти извиква той",
    "p13p": "-\tАма, защо? - пита Даниел - Това е само едно изчисление!",
    "p14p": "-\tДа, но е навсякъде в програмата! Няма шанс да намеря всички места, в които е, днес! И в твърде много форми, за да действа \"Търсене и заместване\"! - гласът на Петър зазвучава още по-силно и отчаяно",
    "p15p": "Даниел се замисля за няколко секунди. Почти мъдро, той отбелязва:",
    "p16p": "-\tДобре, предполагам можем да го отложим за понеделник. До после! - казва Даниел",
    "p17p": "Отново се чуват забързаните му стъпки и Даниел излиза от стаята.",
    "p18p": "\"Уууф!\", мисли си Петър, \"минах между капките\". Лицето му се отпуска и той се наслаждава на топлината, породена от това как кръвта му се връща на мястото си, опитвайки се да не мисли за това, колко време ще му отнеме промяната другата седмица.",
    "p19p": "Изведнъж, вратата на офиса отново се отваря рязко. \"Защо би се върнал?\", чуди се Петър, когато осъзнава, че стъпките не са на Даниел. Те са тежки и звучни, много различни от леката стъпка на математика.",
    "p1p": "Петър е човек. Програмист по професия. Работи в средно голяма компания.",
    "p20p": "Прозрението преминава през мозъка му като светкавица и Петър отново усеща как кръвта изчезва от лицето му. Като жица, той се изправя от стола, за да поздрави мъжът стоящ пред него. Около 1,90 метра висок, Петър може напълно да се скрие в сянката му.",
    "p21p": "-\tЧух за новия вариант на изчислението - чува се дебел глас, характерен за човек, който е пушил по една кутия цигари на ден за последните 20 години",
    "p22p": "-\tДа, шефе, Даниел ми даде инструкциите току-що. Започвам замяната сега, но ще я довърша следващата седмица - гласът на Петър почти трепва, стреснат от внезапната поява на своя мениджър.",
    "p23p": "-\tЗа точно това исках да говорим - отбелязва шефа - Искам промяната да е готова до края на работния ден",
    "p24p": "-\tНо, как така, шефе - ужасен отговаря Петър - нямам време!",
    "p25p": "-\tЩе намериш! - казва шефът - Този уикенд ще представим фирмения си софтуер на няколко други компании, за да им го продадем. Искам да няма закъснения и всичко да е перфектно!",
    "p26p": "-\tНо, но…",
    "p27p": "-\tБез но-та!",
    "p28p": "-\tЯсно, шефе... - замълчава Петър - Ще опитам да го довърша днес!",
    "p29p": "-\tТака те искам! - почти се усмихва шефът - Вярвам в теб!",
    "p2p": "Петък. Слънчев, но мразовит февруарски ден. Часовникът показва 14:00. \"Още малко и идва уикендът\", мисли си Петър, разглеждащ отражението на слънцето в тънката снежна покривка отвън. \"Трябва просто да издържа още малко\", умът му препуска.",
    "p30p": "Мениджърът се обръща и излиза от стаята.",
    "p31p": "Петър се строполява на въртящия се стол, отчаян. \"Но как ще го направя! Има толкова много места с това изчисление, с най-различни променливи. Тежко ми и горко!\".",
    "p32p": "Обръща се към компютъра и започва да пише, много добре знаейки, че спокойствието му за този ден е свършило.",
    "p33p": "Надявам се да ти е харесал моя малък опит в художественото изкуство. На мен със сигурност ми беше забавно да го пиша. Вярваш или не, този разказ има директно значение за днешния урок. Докато Петър е зает да преосмисля работното си място и своя живот, аз ще ти покажа нещото, което може да реши неговите проблеми. В този урок ще ти представя един инструмент в програмирането, с който можеш да изолираш парче код и само да го викаш по име. Инструмент, с който можеш да промениш кода само на едно място, и да има въздействие върху всяко друго място където си използвал името -  функции.",
    "p34p": "Първото, което искам да изясня е, че \"функция\" и \"метод\" са синоними. Има известни правила за ползването им, но в днешно време са почти винаги взаимнозаменяеми.",
    "p35p": "Второ, функциите са просто кръщаване на код. Цялата идея е: хващащ едно парче код, слагаш му име, приемаш аргументи, след това вършиш кода и накрая връщаш резултат.",
    "p36p": "Например, трябва да ползваш много пъти в програма x*4, където x е променлива с тип цяло число. В бъдещ момент, това може да стане x*6. Затова взимаш x*4 и го превръщащ във функция - даваш му име, например multiplyX (\"умножи x\"). След това взимаш аргумент - int x. След като изпълниш кода, използваш return, за да върнеш стойността. Така, на всяко място можеш да използваш multiplyX вместо x*4, и когато дойде твоя луд учен, можеш само да смениш кода в multiplyX, а навсякъде другаде ще си остане само multiplyX и няма да редактираш нищо друго.",
    "p37p": "Трето - в един клас не може да има две функции с еднакво име, освен ако не приемат различни аргументи. Две функции mult, които взимат цели числа int не е допустимо, но ако едната взима int, а другата float, няма проблеми. В Java функциите сеКръщаватТака (camelCase), а в C# СеКръщаватТака (PascalCase).",
    "p38p": "Четвърто - всяка функция, когато бъде викната, получава собствено парче на стака. Тоест не може да има достъп до променливите на функциите преди нея. Тя е ограничена само до аргументите си и променливите, създадени в класа. Ако една функция, например main, викне mult, тя спира на място и започва да се извършва кода в mult. Той изпълнява ролята си и връща резултата си на main, който може да продължи да се изпълнява.",
    "p39p": "Пето - функциите имат модификатори. public и private например показват дали една функция е публична (тоест други класове имат достъп до нея) или не. static показва дали може функцията да се вика директно като част от клас (System.out.println() или Console.WriteLine(), където System.out и Console са класовете) или само от негови променливи (например rand.nextInt(), но не Random.nextInt()). Засега ще пишем само \"public static\" методи. След тези модификатори се записва типа, който ще връща функцията - int, String, int[], double, float, Random и т.н. Специален тип за връщане е void. void значи, че метода не връща нищо, подобно на main. Следва името. След името има скоби, в които разделени със запетаи се записват аргументите, които функцията ще приема. Те може да са от всеки тип. Обикновено не е добър знак, ако функция има повече от 5-6 аргумента, въпреки че препоръчания брой са 1-4. Функциите имат една единствена цел и не трябва да вършат твърде много неща.",
    "p3p": "В момента трябва да е обърнат към монитора пред себе си, добавящ нови функции към програмата на компанията и разрешаващ проблеми. Той е единственият, който работи на нея в момента. Другият му колега си пусна 1 седмица отпуска вчера, за да отиде на ски.",
    "p40p": "Последно - аргументите на функциите се предават по референция в Java и обикновено в C#. Това означава, че ако редактираш аргумента във функцията, редактираш и оригиналната променлива - така действат Arrays.sort()/Array.Sort() - функцията редактира и променя масива. Освен в подобни случай е прието функциите да не редактират аргументите си.",
    "p41p": "Да видим main метода:",
    "p42ds1": "Java",
    "p46p": "Main е public static void - публичен, статичен и не връща стойност - затова никога не сме писали return. След това е името на метода/фунцкията - main и аргументите в скобите. В този случай аргументът е един - масив от низове args - всички аргументи от конзолата събрани като низове в масив. Можеш да използваш args в main като всяка друга променлива.",
    "p47p": "Функции се викат като се запише името на функцията, след това скоби и аргументите - тоест ако когато сме създали функцията сме записали, че приема аргумент int, то в скобите можем да запишем 5, но не и 8.6",
    "p48p": "В момента, в който функция стигне return, тя спира изпълнението си и се връща в предната. Тоест, всеки код написан след return е \"мъртъв\" - няма да се изпълни. Важно е да се отбележи, че всеки път на фукцията трябва да връща стойност - ако цялата фунция се състои от if-else блок, то трябва да има return и в if блока, и в else блока.",
    "p49p": "Сега да разгледаме нашия собствен пример.",
    "p4p": "Или поне единственият, който би трябвало да работи. В това време навън, настроението за работа е толкова премръзнало и мъртво, колкото всяко нещо, показало носа си в студа без яке.",
    "p50ds1": "Java",
    "p54rq": "Създай метод, който изчислява средноаритметичното на 3 цели числа. След това създай метод със същото име и в същия клас, който изчислява средноаритметичното на 3 реални числа (float или double по твой избор).",
    "p5p": "Вратата на офиса се отваря рязко и звукът на бързи и развълнувани стъпки нарушава глухата тишина в стаята. Петър знае кой е, преди даже да надигне главата си от ръцете си.",
    "p6p": "\"Открих нещо!\", чува се развълнувания глас на Даниел, математикът на компанията.",
    "p7p": "Даниел е стереотипния \"луд\" учен, същинския наследник на Айнщайн, решаващ кубични уравнения на салфетки, пишейки с кал, докато изкачва Мусала. Толкова добре влиза в рамката, че човек би си помислил че има бяла, разхвърляна коса, все едно го е ударил ток. Това не е съвсем истина.",
    "p8p": "Истината е, че всъщност именно Даниел \"разработва\" програмата. Тя извършва сериозни финансови изчисления, много извън разбирането на Петър. Даниел казва какво трябва да се направи, дава листове с инструкции и оставя него и колегата му само да напишат кода и да завържат нещата. Това е работата на Петър.",
    "p9p": "Още преди Даниел да е отворил устатата си още веднъж, Петър знае че неговото петъчно спокойствие е нарушено за момента. \"Какво има?\", прозвучава отегчения му глас.",
    "s43cj": "package tutorial;\n\npublic class Methods {\n\tpublic static void main(String[] args) {\n\t\t\n\t}\n}",
    "s44ds2": "C#",
    "s45cc": "using System;\n\npublic class Methods \n{\n\tpublic static void Main(string[] args)\n\t{\n\t}\n}",
    "s51cj": "package tutorial;\n\npublic class Methods {\n\tpublic static int multiply(int x) {\n\t\treturn x*4;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tint x = multiply(5);\n\t\tint y = multiply(x);\n\t\tSystem.out.println(multiply(y) + multiply(4));\n\t}\n}",
    "s52ds2": "C#",
    "s53cc": "using System;\n\npublic class Methods \n{\n\tpublic static int Multiply(int x)\n\t{\n\t\treturn x*4;\n\t}\n\n\tpublic static void Main(string[] args) \n\t{\n\t\tint x = Multiply(5);\n\t\tint y = Multiply(x);\n\t\tConsole.WriteLine(Multiply(y) + Multiply(4));\n\t}\n}",
    "text": "Където ще научиш как да организираш програмата си",
    "title": "Урок 26"
  },
  "l27": {
    "p11p": "Ако изпълниш този код, много бързо ще забележиш доста дълга грешка в конзолата.",
    "p12p": "При рекурсията обикновено има условие за спиране:",
    "p13ds1": "Java",
    "p17p": "В този код, функцията sum приема цяло число. След това проверява дали е 0, и ако е, връща 0. Ако върне 0, функцията спира и не достига до следващия return. Ако не върне 0, достига до следващия return, където връща сегашното x + резултата от функцията с аргумент x - 1. Тоест, изпълнението е нещо такова:",
    "p18p": "main започва изпълнението си",
    "p19p": "sum е викната с аргумент 3",
    "p1p": "В този урок ще се запознаем с рекурсията.",
    "p20p": "3 не е равно на 0",
    "p21p": "Връща се 3 + sum(3 - 1)",
    "p22p": "Вика се sum с аргумент 2",
    "p23p": "2 не е равно на 0",
    "p24p": "Връща се 2 + sum(2 - 1)",
    "p25p": "Вика се sum с аргумент 1",
    "p26p": "1 не е равно на 0",
    "p27p": "Връща се 1 + sum(1 - 1)",
    "p28p": "Вика се sum с аргумент 0",
    "p29p": "0 е равно на 0, следователно sum връща 0",
    "p2p": "Рекурсията е сравнително трудна за разбиране. Използва се рядко, сложна е за прочитане, трудно е да си представиш логиката, но трябва да знаеш какво е. За моя радост, може да се обясни в едно изречение.",
    "p30p": "Вече можем да изчислим 1 + sum(1-1), което е 1 + 0. Връщаме 1",
    "p31p": "Вече можем да изчислим 2 + sum(2-1), което е 2+1. Връщаме 3",
    "p32p": "Вече можем да изчислим 3 + sum(3-1), което е 3 + 3. Връщаме 6",
    "p33p": "И вече имаме резултата от sum, тоест го принтираме в конзолата",
    "p34p": "Проверяваме дали 3 + 2 + 1 наистина е 6.",
    "p35rq": "Направи програма, която приема вход число и извежда факториела му. Използвай рекурсия.",
    "p36p": "Пример:",
    "p37p": "Вход:",
    "p38con": "5",
    "p39p": "Изход:",
    "p3p": "Рекурсията е рекурсивно действие.",
    "p40con": "120 // (5*4*3*2*1)",
    "p41p": "Би трябвало да си правил тази задача по-рано, но с цикли. Кое решение ти харесва повече?",
    "p4p": "Наистина, това е - рекурсията е рекурсивно действие. Това определение е рекурсивно. Ако го използваш, ще се чудиш какво е рекурсивно действие, което отново ще те заведе до определението за рекурсия и цикълът се повтаря.",
    "p5a1": "действие, което е уникално",
    "p5a2": "действие, което се повтаря",
    "p5tq": "Рекурсията е:",
    "p6p": "В програмирането рекурсия се получава, когато една функция вика себе си. Използва се за някой изчисления, като редицата на Фибоначи и факториел. Много често обаче се предпочитат цикли, защото всеки път когато викнеш функция, тя се добавя на стака. Стакът има лимит, който обикновено не се проявява като проблем. От друга страна, с рекурсия много често се достига и преминава този лимит, което води до край на програмата и грешка \"StackOverflow\". Да причиним един StackOverflow:",
    "p7ds1": "Java",
    "s10cc": "using System;\n\npublic class Methods \n{\n\tpublic static void Overflow() \n\t{\n\t\tOverflow();\n\t}\n\n\tpublic static void Main(String[] args) \n\t{\n\t\tOverflow();\n\t}\n}",
    "s14cj": "package tutorial;\n\npublic class Methods {\n\tpublic static int sum(int x) {\n\t\tif (x == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn x + sum(x - 1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(sum(3));\n\t}\n}",
    "s15ds2": "C#",
    "s16cc": "using System;\n\npublic class Methods \n{\n\tpublic static int Sum(int x) \n\t{\n\t\tif (x == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn x + Sum(x - 1);\n\t}\n\n\tpublic static void Main(String[] args) \n\t{\n\t\tConsole.WriteLine(Sum(3));\n\t}\n}",
    "s8cj": "package tutorial;\n\npublic class Methods {\n\tpublic static void overflow() {\n\t\toverflow();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\toverflow();\n\t}\n}",
    "s9ds2": "C#",
    "text": "Където ще се объркаш",
    "title": "Урок 27"
  },
  "l28": {
    "p16h": "Проверка за съдържание на низ в низ",
    "p17p": ".contains() метода в Java и .Contains() в C# приемат низ като аргумент. Ако този низ се съдържа в низа, на който са викнати, връщат true. Иначе връщат false. Тоест, \"здравей\".contains(\"дре\") би било false, но \"здравей\".contains(\"дра\") би било true. Тествай сам.",
    "p18h": "Проверка дали низ приключва или започва с друг низ",
    "p19p": ".startsWith() и .endsWith() (и техните C# еквиваленти с главна буква) са методи, които проверяват съответно дали един низ започва или завършва с друг низ. Връщат boolean. Тествай сам.",
    "p1p": "В този урок ще учиш за методите на низовете. Ако зависеше от мен, бих ти дал да ги разгледаш сам като задача. За жалост, не зависи от мен, тоест този урок съществува. Най-важното нещо е да запомниш, че методите ги има, не толкова да запомниш самите методи.",
    "p20h": "Намиране индекс на низ в друг низ",
    "p21p": ".indexOf и .IndexOf са методи, които приемат низ като аргумент и връщат на кой индекс се намира. Например, \"здравей\".indexOf(\"з\") връща 0. Винаги се връща първата намерена позиция - \"зигзаг\".indexOf(\"з\") пак е 0, въпреки че има \"з\" на нулев и трети индекс. Има също и  .lastIndexOf() и .LastIndexOf(), които пък връщат последния индекс на който се среща низа - в \"зигзаг\", това би било индекс 3. Ако низа не се открие, indexOf() връща -1. Тествай сам.",
    "p22h": "Заместване",
    "p23p": ".replace() и .Replace() приемат два низа като аргументи - единият трябва да бъде намерен, а другият трябва да го замести. \"зигзаг\".replace(\"з\", \"к\") би върнало нов низ - \"кигзак\". Не забравяй, че се замества само първата намерена поява на низа за търсене. В Java има .replaceAll(), което заменя всички появи - тоест \"зигзаг\".replaceAll(\"з\", \"к\") ще върне \"кигкаг\". Оригиналният низ ще си остане същия. Тествай сам.",
    "p24h": "Преобразуване в големи или малки букви",
    "p25p": ".toLowerCase() в Java и .ToLower() в C# връщат версия на низа в малки букви - \"зДрАвеЙ\".toLowerCase() връща \"здравей\". .toUpperCase() и .ToUpper() правят същото, само че те превръщат всички букви в главни. Тествай сам.",
    "p26rq": "Разбери как действа .split() в Java или .Split() в C#.",
    "p27p": "Това е още един преминат урок. Надявам се да си тествал/а методите. Следва тест, така че късмет!",
    "p2p": "Методите на низовете не са статични. Те се викат от променлива, не от класа.",
    "p3e": "Най-важното, което трябва да запомниш за методите на низовете, е че те никога не променят самите низове. Винаги връщат нов низ с промените.",
    "p4p": "Методите се викат, като след низ напишеш \".\" и името на метода, заедно с аргументите. Тези, които работят на Java вече са запознати с .equals() и .charAt(). Няма нужда от .equals() в C#, защото сравнението на низове работи винаги, а еквивалента на .charAt() е просто оператора за достъп до индекс - [].",
    "p5h": "Поднизове",
    "p6p": "Substring (или подниз) е низ, който се съдържа в друг низ. В най-прости думи, \"здр\" е подниз на \"здравей\".",
    "p7p": "И в двата езика, .substring() методът приема два аргумента. Първият е индекс на символ от който да започне подниза включително. Вторият е индекс на символ, на който да завършва подниза. В Java не е включителен, а в C# е. Тоест, подниз от 1 до 4 на \"здравей\" е \"дра\" в Java и \"драв\" в C#:",
    "p8ds1": "Java",
    "s10p": "Резултат:",
    "s11con": "дра",
    "s12ds2": "C#",
    "s13cc": "using System;\n\npublic class Methods \n{\n\n\tpublic static void Main(String[] args) \n\t{\n\t\tstring hello = \"здравей\";\n\t\tConsole.WriteLine(hello.Substring(1, 4));\n\t}\n}",
    "s14p": "Резултат:",
    "s15con": "драв",
    "s9cj": "package tutorial;\n\npublic class Methods {\n\tpublic static void main(String[] args) {\n\t\tString hello = \"здравей\";\n\t\tSystem.out.println(hello.substring(1, 4));\n\t}\n}",
    "text": "Където ще научиш, че методите са навсякъде",
    "title": "Урок 28"
  },
  "l29": {
    "p10p": "Това са нестатичните методи и променливи. За тях се казва, че принадлежат на обекта, защото не могат да се използват от класа, а само от обектите му.",
    "p11p": "От друга страна, статичните променливи и методи принадлежат на класа. Те нямат достъп до информацията на обект, защото такъв няма. Затова няма нужда и да създаваш един за да ги използваш. Статичните методи могат да извършват действия само върху статични променливи и променливи, които са създадени в тях. System.out.println() и Console.WriteLine() са статични методи. Те принадлежат на System.out и Console, приемат  аргумент и го принтират, като нямат нужда от друга информация. Методите в класа Math са статични, защото всеки от тях има високоспециализирани аргументи. Статичните методи се викат единствено чрез името на класа и името на метода.",
    "p12p": "Съответно, от всяка статична променлива има точно една инстанция. Ако си представим, че в String класа има статична променлива за максимална големина на низа, то тази променлива съществува само на едно място, защото има само един клас. Можем да създадем 10 000 низа и всеки от тях ще има различни символи, но за всички максималната дължина ще е еднаква. Ако променим статичната максимална дължина, то тя ще се промени в единствената инстанция. Всеки един от тези 10 000 низа ще има достъп до нея от нестатичните си методи и ще използва актуалната стойност.",
    "p13p": "Чертежът изисква части, за да има кола, а класът изисква информация, за да създаде обект. Класовете имат специален метод, който се вика за създаване на обект и на него се дава информацията като аргументи. Този метод се нарича конструктор. Когато напишеш new Scanner(System.in) в Java, ти викаш конструктора на Scanner с аргумент System.in. Конструкторът конструира обекта с тази информация и го връща.",
    "p14p": "Сега, нека да напишем малко код.",
    "p15p": "Първо създай нов клас (файл), различен от този в който ти е main метода. Създай го в същия пакет при Java и в същия namespace при C#. В него не трябва да има main метод. Наречи го \"Book\" (книга). Всички имена на класове започват с главна буква и СеКръщаватТака (Pascal case). Трябва накрая да имаш нещо такова:",
    "p16ds1": "Java",
    "p1p": "Стигнахме до класовете - една от най-важните концепции в програмирането. Нека да се впускаме в урока!",
    "p20p": "Сега да напишем няколко променливи. Запиши в класа като нормални променливи низ \"name\" за името на книгата, низ \"author\" за автора и цяло число \"length\" за дължината (в страници). Да са public, поне засега. В Java променливите на класове се кръщават като нормалните променливи, а в C# СеКръщаватТака. Трябва да имаш нещо такова:",
    "p21ds1": "Java",
    "p25p": "Това са променливите, които ще има крайния ни обект. Сега да създадем конструктора. Имаме 3 променливи в класа, които трябва да запълним, значи ще вземем 3 променливи като аргументи на конструктора - име, автор и дължина:",
    "p26ds1": "Java",
    "p2p": "Всъщност, ние вече сме видели доста класове и как се използват - Random, Scanner, String.",
    "p30w": "Аргументите на конструктора нямат нищо общо с променливите на класа. Прието е да се кръщават с еднакви имена за по-добра четливост.",
    "p31p": "Конструкторът е Book(). Той обаче още е празен - само сме дефинирали аргументите. Сега идва сложната част - трябва да дадем на променливите на новосъздадения обект стойностите, дадени на конструктора, тоест по някакъв начин трябва да достигнем до него. Това става с \"this\". this е самия обект - тоест, можем да използваме него, за да достигнем класовите променливи public name, author, length вместо аргументите на конструктора:",
    "p32ds1": "Java",
    "p36p": "this.name е name променливата на новосъздадения обект и ние и присвояваме подадената на конструктора информация. Накрая ни остава само една задача - да дадем един метод на книгата. Ще го кръстим getFullName()/GetFullName() (\"вземи пълно име\"). Той ще връща нов низ, обединение на името и автора. Да го направим:",
    "p37ds1": "Java",
    "p3p": "Класовете са като \"общи\" чертежи. Те казват как ще се създаде нещо. \"Общ\" чертеж на колата диктува какво трябва да има на колата - двигател, резервоар, акумулатор, шаси. Когато погледнем този чертеж, ние не знаем какъв ще е двигателя на готова кола или вместимостта на резервоара. Не знаем скоростта или точния модел на акумулатора. Единственото което знаем е, че тази кола трябва да има тези неща. Чертежът показва какви компоненти трябва да има завършената кола.",
    "p41p": "Страхотно! Сега да тестваме класа в main на главния файл. Имаме достъп до публичните променливи и методи в класа. Надявам се си спомняш как се създаваха променливи от класове:",
    "p42ds1": "Java",
    "p46p": "Резултат:",
    "p47con": "Вълшебникът от Оз - Лиман Баум\n176",
    "p48p": "Честито! Ти създаде първия си клас! В следващия урок ще продължим развитието на класа.",
    "p49rq": "Огледай се около себе си и представи нещо като клас - например клас Дреха или Мебел.",
    "p4p": "Класовете показват каква информация трябва да има в завършените обекти. В Java, Scanner класът съдържа информация, която показва какво трябва да чете. Той я изисква, по същия начин, по който една кола изисква двигател. Scanner класа не знае какво ще чете, но обектът, създаден по него, знае. String класа знае, че изисква \"масив от символи\", но не знае колко ще е дълъг или кои ще са символите.",
    "p5p": "Чертежът съдържа информацията, че колата ще има двигател и акумулатор. Съдържа и информацията, че ще има фарове и резервоар. Тази информация, сама по себе си, не може да накара колата да върви. Трябва да опишем как частите ще се свързват, как ще протича тока през тях, да обясним как се стартира колата, така че готовата кола да може да се използва. Тогава ние работим с компонентите. В класовете, това се изразява чрез методи.",
    "p6p": "В класа String, символите на низа са информация, но сама по себе си, тази информация не прави нищо. По тази причина низовете имат методи като .substring(), .indexOf(). Те работят със самия низ и извършват логически операции върху него.",
    "p7p": "Съвкупността от информацията, която трябва да се съдържа и как да се работи с нея е клас. Информацията се съдържа в променливи, а как се работи с нея - в методи.",
    "p8p": "Когато използваме чертежа, за да създадем кола, двигателят става истински - той вече не е просто \"трябва ни двигател\", а истински модел. Скоростта на колата получава стойност, фаровете получават силата си, акумулатора - модела. Всяко нещо става конкретно - ние създаваме нова кола. Тази нова кола е обект и тя вече има нещата изискани в чертежа и може да работи с тях.",
    "p9p": "Класовете са типове. Можем да създадем променлива с тип този клас, а променливата е обект на класа. Обектът има цялата нужна информация, дадена при създаването му и чрез методите му. Методите на обекта могат да извършват операциите си, защото те имат нужната информация, уникална за всеки обект.",
    "s17cj": "package tutorial;\n\npublic class Book {\n\n}",
    "s18ds2": "C#",
    "s19cc": "using System;\n\npublic class Book\n{\n\t\n}",
    "s22cj": "package tutorial;\n\npublic class Book {\n\tpublic String name;\n\tpublic String author;\n\tpublic int length;\n}",
    "s23ds2": "C#",
    "s24cc": "using System;\n\npublic class Book\n{\n\tpublic string Name;\n\tpublic string Author;\n\tpublic int Length;\n}",
    "s27cj": "package tutorial;\n\npublic class Book {\n\tpublic String name;\n\tpublic String author;\n\tpublic int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\t\n\t}\n}",
    "s28ds2": "C#",
    "s29cc": "using System;\n\npublic class Book\n{\n\tpublic string Name;\n\tpublic string Author;\n\tpublic int Length;\n\t\n\tpublic Book(string name, string author, int length) \n\t{\n\t\t\n\t}\n}",
    "s33cj": "package tutorial;\n\npublic class Book {\n\tpublic String name;\n\tpublic String author;\n\tpublic int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\tthis.name = name;\n\t\tthis.author = author;\n\t\tthis.length = length;\n\t}\n}",
    "s34ds2": "C#",
    "s35cc": "using System;\n\npublic class Book\n{\n\tpublic string Name;\n\tpublic string Author;\n\tpublic int Length;\n\t\n\tpublic Book(string name, string author, int length) \n\t{\n\t\tthis.Name = name;\n\t\tthis.Author = author;\n\t\tthis.Length = length;\n\t}\n}",
    "s38cj": "package tutorial;\n\npublic class Book {\n\tpublic String name;\n\tpublic String author;\n\tpublic int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\tthis.name = name;\n\t\tthis.author = author;\n\t\tthis.length = length;\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn this.name + \" - \" + this.author;\n\t}\n}",
    "s39ds2": "C#",
    "s40cc": "using System;\n\npublic class Book\n{\n\tpublic string Name;\n\tpublic string Author;\n\tpublic int Length;\n\t\n\tpublic Book(string name, string author, int length) \n\t{\n\t\tthis.Name = name;\n\t\tthis.Author = author;\n\t\tthis.Length = length;\n\t}\n\t\n\tpublic string GetFullName() \n\t{\n\t\treturn this.Name + \" - \" + this.Author;\n\t}\n}",
    "s43cj": "package tutorial;\n\npublic class Classes {\n\tpublic static void main(String[] args) {\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от Оз\", \"Лиман Баум\", 176);\n\t\tSystem.out.println(theWizardOfOz.getFullName());\n\t\tSystem.out.println(theWizardOfOz.length);\n\t}\n}",
    "s44ds2": "C#",
    "s45cc": "using System;\n\npublic class Classes\n{\n\tpublic static void Main(String[] args)\n\t{\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от Оз\", \"Лиман Баум\", 176);\n\t\tConsole.WriteLine(theWizardOfOz.GetFullName());\n\t\tConsole.WriteLine(theWizardOfOz.Length);\n\t}\n}",
    "text": "Където ще научиш защо се нарича софтуерно инженерство",
    "title": "Урок 29"
  },
  "l3": {
    "p10p": "Уникод е създаден от няколко човека през 1991г. Той действа с няколко оптимизации - най-често използваните символи са първите, и те се запаметяват използвайки само 8 бита, а другите - с по 32. Това позволява невероятно количество символи - в последния стандарт през 2021 има 137 439 символа, обхващащи 146 писмености, мъртви и живи, множество символи и емоджита. Днес е в няколко различни версии, като UTF-8, UTF-16, UTF-32. В днешно време се използва почти навсякъде, заради своето огромно разнообразие.",
    "p11a1": "Плаща ти се, за да го използваш",
    "p11a2": "Корупция",
    "p11a3": "Има най-много и разнообразни символи",
    "p11a4": "Заема най-много място",
    "p11tq": "Защо Unicode е толкова популярен?",
    "p12p": "Това е какво ще ти е нужно относно това как компютрите се справят със символи.",
    "p13t": "Всяка буква и място, което напишеш, е символ, който се запазва като число.",
    "p1p": "Вече разбра, че компютърът действа само с нули и единици - от процесора до паметта. Разбра как представя нашите десетични числа само с две цифри и как извършва аритметични действия с тях. Сега идва въпросът \"Но как представя текст?\".",
    "p2p": "Първо, ще се върнем малко във времето. Далечната 1960, когато една група хора трябвало да измислят начин, по който да превръщат символите в числа. Съответно, те мислили, и през 1963 година излиза ASCII (Американски стандартен код за обмен на информация, чете се \"аски\"). Той е сравнително просто решение - всеки нужен символ е свързан с число. Компютъра единствено запазва числото, а по-късно може да го разчете и да представи символа, на който съответства.",
    "p3p": "Общо има 128 символа, и всеки от тях се записва със 7 бита.",
    "p4p": "33 от тях не могат да се разпечатат - не се виждат по никакъв начин. Те обозначават команди, като край на заглавие, абзац, изтриване и т.н.",
    "p5p": "Потърси в Интернет ASCII таблицата - символите, които могат или не могат да се разпечатат, със съответстващите им букви. Преди малките букви са големите, а преди големите - цифрите и препинателните знаци.",
    "p6p": "Така всеки компютър знае, че например символ 32 е празно място, а символ 61 е малко латинско \"a\".",
    "p7fq": "Колко са символите в ASCII?",
    "p8p": "Може би забелязваш лек проблем - в ASCII има само латински символи, препинателни знаци и цифрите. Какво става ако имаш съобщение на кирилица? Или на японски? Ами китайски? И къде се побират емотиконите? Отговорът е, ами, никъде. Този проблем не е важен за дълго време. В държавите, които използват несъществуващи в ASCII символи се ползват различни кодирания на символите. В някакъв момент тези държави трябва да си комуникират. Представи си - на компютър с ASCII, 61 е малко \"a\", но какво става ако нa него се пусне файл, запазен с кодиране, в което 61 е \"и\"? Отговорът е \"пълен хаос\". Създават се много алтернативни кодирания, като например Windows-1251, където 0438 (в база 16, тоест 1080 в десетична бройна система) е \"и\". Какво се случва, когато компютър, който опитва да чете ASCII, където символ 1080 няма, стигне до това? Символът обикновено просто се игнорира или се показва като въпросителни.",
    "p9p": "Тези проблеми се срещат и днес. Не си представяй, че са изчезнали. Но са много по-малко, благодарение на една причина - Unicode (от универсален код, чете се \"юникоуд\", пише се уникод).",
    "text": "Където ще научиш как текст става нули и единици",
    "title": "Урок 3"
  },
  "l30": {
    "p13p": "Резултат:",
    "p14con": "-6\n-456",
    "p15p": "Тоест, за да разрешим проблема трябва да сложим няколко проверки и на двете места. Конструкторът е лесен:",
    "p16ds1": "Java",
    "p1p": "В предния урок написа първия си клас. Той изглежда по следния начин:",
    "p20p": "Обикновено не харесвам да използвам ternary оператора, но в този случай е перфектен - ако стойността дадена за страници в конструктора е по-малка от 0 или по-голяма от 30000 (предполагам, че това е около двойно максимума страници за една книга), променливата на класа става 0",
    "p21p": "Това решава един от проблемите ни...",
    "p22ds1": "Java",
    "p26p": "Резултат:",
    "p27con": "0\n-456",
    "p28p": "…и не другия.",
    "p29p": "Но какво ще направим, за да спрем промяната на… ами… променлива? Не е ли това целта и?",
    "p2ds1": "Java",
    "p30p": "Заради това съществуват get-търите и set-търите. Това са функции, чиято единствена цел е да предоставят и променят променлива на класа. Тяхното име започва с get (вземам) или set (слагам) и името на променливата. С тяхна помощ можем да пишем каквито си искаме проверки, когато променяме стойността на променлива и да я спираме, ако се налага.",
    "p31p": "Това е и едно от местата, където Java и C# доста се различават.",
    "p32ds1": "Java",
    "p36p": "И това вече трябва да е оправило всички проблеми. Да видим:",
    "p37ds1": "Java",
    "p52p": "Вече независимо какво направим, ако опитаме да създадем обект книга с над 30000 страници или с по-малко от 0, готовият обект ще има 0 страници.",
    "p53p": "Този принцип всичко да е максимално затворено и контролирано в един клас се нарича енкапсулация - накратко, освен ако нещо няма да бъде публично използвано, то трябва да е private (или при C# да зависи от get и set). private спира другите разработчици от това да използват нещо различно от предоставените методи за манипулация на променливата и е много добър сигнал, че освен ако не работят по класа, не трябва да се интересуват от нея.",
    "p54p": "Така или иначе започнахме, нека да добавим get-търи и set-търи на всички променливи в класа.",
    "p55ds1": "Java",
    "p59p": "Както може би забелязваш, Book вече е доста голям, поне в Java. От тук нататък няма да изписвам всички get-търи и set-търи когато показвам кода.",
    "p60p": "В този клас има още проблеми. В програмирането, почти никога не трябва да се повтаря един и същи код два пъти - всичко трябва да е изолирано във функции. В този клас имаме повтарящ се код: \"(length < 0 || length > 30000)? 0 : length;\" се среща два пъти - в конструктора и в set-търа на length. От това няма смисъл - просто ще използваме set-търа в конструктора и ще го оставим да си свърши работата.",
    "p61ds1": "Java",
    "p65p": "Добре. Това изглежда почти перфектно. Остава само един малък детайл. В set-търа сравняваме за 0 и 30000. За нас тези числа имат значение, но за някой следващ програмист може и да нямат. Това се наричат магически числа и не е добра практика да ги използваме. Вместо това е прието да се изолират в променливи. Тези променливи са общи за всички книги, не отделни за всяка една. Тоест, тези променливи принадлежат на класа или с други думи те са статични. Ще ги кръстим minLength (минимална дължина) и maxLength (максимална дължина). Да ги създадем и да ги използваме:",
    "p66ds1": "Java",
    "p6p": "С този клас има лек проблем. Той трябва да представя книга. Въпреки това, всяко число може да се въведе като брой страници, включително много големи и отрицателни. После ходи да обясняваш на библиотекарката как може някоя книга да има -5 страници…",
    "p70p": "Вече всеки четящ класа може да разбере кои са тези числа чрез променливите и да ги промени. Тъй като са статични и публични, всеки друг клас също има достъп до тях чрез класа и не чрез обект:",
    "p71ds1": "Java",
    "p75p": "Резултат:",
    "p76con": "0\n30000",
    "p77p": "Нямаш задача. Аз се изморих да пиша думата \"проблем\". В следващия урок продължаваме с разработката на класа.",
    "p7p": "В този урок ще решим този проблем.",
    "p8p": "Има два начина да се зададе дължината на книгата - единият е чрез конструктора когато се създава обекта. Другият е през самата променлива. Това ни позволява да правим нещо такова:",
    "p9ds1": "Java",
    "s10cj": "package tutorial;\n\npublic class Classes {\n\tpublic static void main(String[] args) {\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от Оз\", \"Лиман Баум\", -6);\n\t\tSystem.out.println(theWizardOfOz.length);\n\t\ttheWizardOfOz.length = -456;\n\t\tSystem.out.println(theWizardOfOz.length);\n\t}\n}",
    "s11ds2": "C#",
    "s12cc": "using System;\n\npublic class Classes\n{\n\tpublic static void Main(String[] args)\n\t{\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от Оз\", \"Лиман Баум\", -6);\n\t\tConsole.WriteLine(theWizardOfOz.Length);\n\t\ttheWizardOfOz.Length = -456;\n\t\tConsole.WriteLine(theWizardOfOz.Length);\n\n\t}\n}",
    "s17cj": "public Book(String name, String author, int length) {\n\tthis.name = name;\n\tthis.author = author;\n\tthis.length = (length < 0 || length > 30000)? 0 : length;\n}",
    "s18ds2": "C#",
    "s19cc": "public Book(string name, string author, int length) \n{\n\tthis.Name = name;\n\tthis.Author = author;\n\tthis.Length = (length < 0 || length > 30000)? 0 : length;\n}",
    "s23cj": "package tutorial;\n\npublic class Classes {\n\tpublic static void main(String[] args) {\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от Оз\", \"Лиман Баум\", -6);\n\t\tSystem.out.println(theWizardOfOz.length);\n\t\ttheWizardOfOz.length = -456;\n\t\tSystem.out.println(theWizardOfOz.length);\n\t}\n}",
    "s24ds2": "C#",
    "s25cc": "using System;\n\npublic class Classes\n{\n\tpublic static void Main(String[] args)\n\t{\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от Оз\", \"Лиман Баум\", -6);\n\t\tConsole.WriteLine(theWizardOfOz.Length);\n\t\ttheWizardOfOz.Length = -456;\n\t\tConsole.WriteLine(theWizardOfOz.Length);\n\n\t}\n}",
    "s33cj": "package tutorial;\n\npublic class Book {\n\tpublic String name;\n\tpublic String author;\n\tpublic int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\tthis.name = name;\n\t\tthis.author = author;\n\t\tthis.length = (length < 0 || length > 30000)? 0 : length;\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn this.name + \" - \" + this.author;\n\t}\n\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\tpublic void setLength(int length) {\n\t\tthis.length = (length < 0 || length > 30000)? 0 : length;\n\t}\n}",
    "s34ds2": "C#",
    "s35cc": "using System;\n\npublic class Book\n{\n\tpublic string Name;\n\tpublic string Author;\n\tpublic int Length \n\t{\n\t\tget \n\t\t{\n\t\t\treturn this.Length;\n\t\t}\n\t\tset \n\t\t{ \n\t\t\tthis.Length = (value < 0 || value > 30000)? 0 : value;\n\t\t}\n\t}\n\t\n\tpublic Book(string name, string author, int length) \n\t{\n\t\tthis.Name = name;\n\t\tthis.Author = author;\n\t\tthis.Length = (length < 0 || length > 30000)? 0 : length;\n\t}\n\t\n\tpublic string GetFullName() \n\t{\n\t\treturn this.Name + \" - \" + this.Author;\n\t}\n}",
    "s38p": "В Java вече можем да използваме методите, които създадохме. Те разрешават нашите проблеми - вече дори да опитаме .setLength(-456), дължината в обекта ще е точно 0.",
    "s39cj": "package tutorial;\n\npublic class Classes {\n\tpublic static void main(String[] args) {\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от Оз\", \"Лиман Баум\", -6);\n\t\tSystem.out.println(theWizardOfOz.getLength());\n\t\ttheWizardOfOz.setLength(-456);\n\t\tSystem.out.println(theWizardOfOz.getLength());\n\t}\n}",
    "s3cj": "package tutorial;\n\npublic class Book {\n\tpublic String name;\n\tpublic String author;\n\tpublic int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\tthis.name = name;\n\t\tthis.author = author;\n\t\tthis.length = length;\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn this.name + \" - \" + this.author;\n\t}\n}",
    "s40p": "Резултат:",
    "s41con": "0\n0",
    "s42p": "Обаче с това решение все още има проблем. Нищо не ни пречи да напишем това:",
    "s43cj": "package tutorial;\n\npublic class Classes {\n\tpublic static void main(String[] args) {\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от Оз\", \"Лиман Баум\", -6);\n\t\tSystem.out.println(theWizardOfOz.getLength());\n\t\ttheWizardOfOz.length = -456;\n\t\tSystem.out.println(theWizardOfOz.getLength());\n\t}\n}",
    "s44p": "…и проблемът се появява отново. Затова има public и private модификатори. Ще направим length private. Тогава само и единствено методите в класа Book ще имат достъп до променливата и всеки друг клас ще трябва да разчита на методите.",
    "s45cj": "public class Book {\n\tpublic String name;\n\tpublic String author;\n\tprivate int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\tthis.name = name;\n\t\tthis.author = author;\n\t\tthis.length = (length < 0 || length > 30000)? 0 : length;\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn this.name + \" - \" + this.author;\n\t}\n\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\tpublic void setLength(int length) {\n\t\tthis.length = (length < 0 || length > 30000)? 0 : length;\n\t}\n}",
    "s46p": "Вече не можем да използваме theWizardOfOz.length, защото е private и ще ни даде грешка. Задължени сме да използваме theWizardOfOz.getLength() и theWizardOfOz.setLength().",
    "s47ds2": "C#",
    "s48p": "В C# можем да продължим да използваме променливата.",
    "s49cc": "public class Classes\n{\n\tpublic static void Main(String[] args)\n\t{\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от Оз\", \"Лиман Баум\", -6);\n\t\tConsole.WriteLine(theWizardOfOz.Length);\n\t\ttheWizardOfOz.Length = -456;\n\t\tConsole.WriteLine(theWizardOfOz.Length);\n\n\t}\n}",
    "s4ds2": "C#",
    "s50p": "Резултат:",
    "s51con": "0\n0",
    "s56cj": "package tutorial;\n\npublic class Book {\n\tprivate String name;\n\tprivate String author;\n\tprivate int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\tthis.setName(name);\n\t\tthis.setAuthor(author);\n\t\tthis.length = (length < 0 || length > 30000)? 0 : length;\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn this.getName() + \" - \" + this.getAuthor();\n\t}\n\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\tpublic void setLength(int length) {\n\t\tthis.length = (length < 0 || length > 30000)? 0 : length;\n\t}\n\n\tpublic String getAuthor() {\n\t\treturn author;\n\t}\n\n\tpublic void setAuthor(String author) {\n\t\tthis.author = author;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}",
    "s57ds2": "C#",
    "s58cc": "using System;\n\npublic class Book\n{\n\tpublic string Name {get; set;}\n\tpublic string Author {get; set;}\n\tpublic int Length \n\t{\n\t\tget \n\t\t{\n\t\t\treturn this.Length;\n\t\t}\n\t\tset \n\t\t{ \n\t\t\tthis.Length = (value < 0 || value > 30000)? 0 : value;\n\t\t}\n\t}\n\t\n\tpublic Book(string name, string author, int length) \n\t{\n\t\tthis.Name = name;\n\t\tthis.Author = author;\n\t\tthis.Length = (length < 0 || length > 30000)? 0 : length;\n\t}\n\t\n\tpublic string GetFullName() \n\t{\n\t\treturn this.Name + \" - \" + this.Author;\n\t}\n}",
    "s5cc": "using System;\n\npublic class Book\n{\n\tpublic string Name;\n\tpublic string Author;\n\tpublic int Length;\n\t\n\tpublic Book(string name, string author, int length) \n\t{\n\t\tthis.Name = name;\n\t\tthis.Author = author;\n\t\tthis.Length = length;\n\t}\n\t\n\tpublic string GetFullName() \n\t{\n\t\treturn this.Name + \" - \" + this.Author;\n\t}\n}",
    "s62cj": "package tutorial;\n\npublic class Book {\n\tprivate String name;\n\tprivate String author;\n\tprivate int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\tthis.setName(name);\n\t\tthis.setAuthor(author);\n\t\tthis.setLength(length);\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn this.getName() + \" - \" + this.getAuthor();\n\t}\n\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\tpublic void setLength(int length) {\n\t\tthis.length = (length < 0 || length > 30000)? 0 : length;\n\t}\n…\n}",
    "s63ds2": "C#",
    "s64cc": "public class Book\n{\n\tpublic string Name {get; set;}\n\tpublic string Author {get; set;}\n\tpublic int Length \n\t{\n\t\tget \n\t\t{\n\t\t\treturn this.Length;\n\t\t}\n\t\tset \n\t\t{ \n\t\t\tthis.Length = (value < 0 || value > 30000)? 0 : value;\n\t\t}\n\t}\n\t\n\tpublic Book(string name, string author, int length) \n\t{\n\t\tthis.Name = name;\n\t\tthis.Author = author;\n\t\tthis.Length = length;\n\t}\n\t\n\tpublic string GetFullName() \n\t{\n\t\treturn this.Name + \" - \" + this.Author;\n\t}\n}",
    "s67cj": "package tutorial;\n\npublic class Book {\n\tpublic static int minLength = 0;\n\tpublic static int maxLength = 30000;\n\tprivate String name;\n\tprivate String author;\n\tprivate int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\tthis.setName(name);\n\t\tthis.setAuthor(author);\n\t\tthis.setLength(length);\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn this.getName() + \" - \" + this.getAuthor();\n\t}\n\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\tpublic void setLength(int length) {\n\t\tthis.length = (length < minLength || length > maxLength)? 0 : length;\n\t}\n\n\tpublic String getAuthor() {\n\t\treturn author;\n\t}\n\n\tpublic void setAuthor(String author) {\n\t\tthis.author = author;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}",
    "s68ds2": "C#",
    "s69cc": "public class Book\n{\n\tpublic static int MinLength = 0;\n\tpublic static int MaxLength = 30000;\n\tpublic string Name {get; set;}\n\tpublic string Author {get; set;}\n\tpublic int Length \n\t{\n\t\tget \n\t\t{\n\t\t\treturn this.Length;\n\t\t}\n\t\tset \n\t\t{ \n\t\t\tthis.Length = (value < MinLength || value > MaxLength)? 0 : value;\n\t\t}\n\t}\n\t\n\tpublic Book(string name, string author, int length) \n\t{\n\t\tthis.Name = name;\n\t\tthis.Author = author;\n\t\tthis.Length = length;\n\t}\n\t\n\tpublic string GetFullName() \n\t{\n\t\treturn this.Name + \" - \" + this.Author;\n\t}\n}",
    "s72cj": "package tutorial;\n\npublic class Classes {\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(Book.minLength);\n\t\tSystem.out.println(Book.maxLength);\n\t}\n}",
    "s73ds2": "C#",
    "s74cc": "using System;\n\npublic class Classes\n{\n\tpublic static void Main(String[] args)\n\t{\n\t\tConsole.WriteLine(Book.MinLength);\n\t\tConsole.WriteLine(Book.MaxLength);\n\t}\n}",
    "text": "Където ще научиш кaк да контролираш достъп",
    "title": "Урок 30"
  },
  "l31": {
    "p13p": "Константите са много добър знак за всеки друг програмист, че тази стойност не трябва да се променя, освен ако знаят какво правят. Повечето статични променливи, които ще срещнеш, ще са константи. Обикновено е лош знак да имаш неконстантна статична променлива. Сам ще откриеш причините за това след достатъчно време.",
    "p14p": "Първият ми реален програмен \"проект\" беше много проста игра на карти в Java. Реших да не представям тестето карти като клас, даже не и самите карти. Резултатът не беше нещо, което бих написал днес. По едно време бях убеден, че кода ми не действа, защото IDE-то ми оцветяваше някои от променливите в грешния цвят. В последствие осъзнах, че съм направил всички променливи статични. Опитвах се да създам нов обект на клас без конструктор и се надявах, че всички статични променливи ще променят стойността си. Не проработи. Някак довърших приложението. Още съм горд до някаква степен, защото беше първият път, в който направих нещо, но все пак се надявам, че след тези 3 урока за класовете имаш малко по-добро разбиране, отколкото аз имах тогава.",
    "p15rq": "Спомняш ли си как ти дадох да направиш един клас, който представя обект, намиращ се около теб? Върни се в него и го редактирай с новите си знания.",
    "p16p": "В тези уроците научи принципите не се повтаряй (DRY - Don't repeat yourself) и енкапсулация - два от най-важните принципи за програмирането. Научи се и да създаваш класове, въпреки че още не си покрил напълно обектно-ориентираното програмиране. Въпреки всичко си още една крачка по-близо до края.",
    "p1p": "В края на предния урок създадохме две статични променливи, които съдържат информация за минималното и максималното количество страници на една книга. Това е хубаво, но оставихме една лека... пробойна - всеки може да направи това:",
    "p2ds1": "Java",
    "p6p": "Вече не можем да създаваме книги с валидни страници, защото максимумът ни е 30000, а минимумът - 40000. Някой напусне работа и ще сложи тези редове някъде на случаен принцип из някой масивен блок код. Ако имаш нещастието да няма система за контролиране на версиите или тестове, късмет с откриването на проблема.",
    "p7p": "Трябва някак да предотвратим тези две променливи да променят стойностите си през изпълнението на програмата - щом веднъж са създадени, никога не трябва да могат да се променят извън мястото си на създаване в кода.",
    "p8p": "В математиката тези числа се наричат константи. Разбира се, в програмирането също има константи. Когато една променлива всъщност е константа, тя не може да променя стойността си по време на изпълнение на програмата. Горния код би дал грешка и даже не би компилирал. В Java константите се отбелязват с final (финален), а в C# - с readonly (само за четене). В C# има и думата const. Тя е малко по-различна от readonly и final в Java с това, че const променливи са статични по подразбиране и стойността им трябва да се знае преди компилацията, тоест винаги се инициализира на място и се финализира през компилацията. От друга страна, readonly и final може да се инициализират и в конструктора на клас чрез динамично калкулирана стойност (например като се използва стойност въведена от потребителя време на изпълнение). В Java константите СЕ_КРЪЩАВАТ_ТАКА, а в C# СеКръщаватТака. Да преминаваме към кода:",
    "p9ds1": "Java",
    "s10cj": "package tutorial;\n\npublic class Book {\n\tpublic static final int MIN_LENGTH = 0;\n\tpublic static final int MAX_LENGTH = 30000;\n\tprivate String name;\n\tprivate String author;\n\tprivate int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\tthis.setName(name);\n\t\tthis.setAuthor(author);\n\t\tthis.setLength(length);\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn this.getName() + \" - \" + this.getAuthor();\n\t}\n\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\tpublic void setLength(int length) {\n\t\tthis.length = (length < MIN_LENGTH || length > MAX_LENGTH)? 0 : length;\n\t}\n\n\tpublic String getAuthor() {\n\t\treturn author;\n\t}\n\n\tpublic void setAuthor(String author) {\n\t\tthis.author = author;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}",
    "s11ds2": "C#",
    "s12cc": "public class Book\n{\n\tpublic static readonly int MinLength = 0;\n\tpublic static readonly int MaxLength = 30000;\n\tpublic string Name {get; set;}\n\tpublic string Author {get; set;}\n\tpublic int Length \n\t{\n\t\tget \n\t\t{\n\t\t\treturn this.Length;\n\t\t}\n\t\tset \n\t\t{ \n\t\t\tthis.Length = (value < MinLength || value > MaxLength)? 0 : value;\n\t\t}\n\t}\n\t\n\tpublic Book(string name, string author, int length) \n\t{\n\t\tthis.Name = name;\n\t\tthis.Author = author;\n\t\tthis.Length = length;\n\t}\n\t\n\tpublic string GetFullName() \n\t{\n\t\treturn this.Name + \" - \" + this.Author;\n\t}\n}",
    "s3cj": "package tutorial;\n\npublic class Classes {\n\tpublic static void main(String[] args) {\n\t\tBook.minLength = 40000;\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от оз\", \"Лиман Баум\", 173);\n\t\tSystem.out.println(theWizardOfOz.getLength());\n\t}\n}",
    "s4ds2": "C#",
    "s5cc": "using System;\n\npublic class Classes\n{\n\tpublic static void Main(String[] args)\n\t{\n\t\tBook.MinLength = 40000;\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от оз\", \"Лиман Баум\", 176);\n\t\tConsole.WriteLine(theWizardOfOz.Length);\n\t}\n}",
    "text": "Където ще научиш, че има и непроменливи",
    "title": "Урок 31"
  },
  "l32": {
    "p10p": "abstract метод означава, че методът няма тяло в класа и задължително трябва да бъде написан от този клас, който го наследява. Такъв метод може да съществува единствено в абстрактен клас, защото той реално не съществува в класа. И тъй като не можеш да викнеш метод, който не съществува, то и класът не трябва да може да създава обекти.",
    "p11p": "Абстрактни класове обаче могат да бъдат типа на обект. Ако имаме абстрактен клас животно, който има абстрактен метод \"направи шум\", не можем да направим ново животно, защото метода \"направи шум\" го няма. Ако обаче куче наследи от животно, то е задължено да напише метода \"направи шум\", който да кажем принтира на конзолата \"бау\". Тъй като куче не е абстрактен клас, можем да създадем ново куче. После можем да направим и котка, която принтира \"мяу\" с нейния метод. Накрая можем да превърнем и кучето в животно, което би изглеждало така: Animal anim = new Dog();, и котката в животно, тоест те вече ще имат типа животно, ще можем заедно да ги съхраняваме в масиви, да ги даваме като аргументи за методи, но при двете животни ще има различен резултат от метода \"направи шум\" - едното ще принтира на конзолата \"бау\", а другото \"мяу\".",
    "p12p": "Да видим код, най-после:",
    "p13p": "Пак ще използваме нашия клас Book. Ще му добавим метод getBookType()/GetBookType(), който ще връща типа на книга - книга, роман, автобиография:",
    "p14ds1": "Java",
    "p18p": "След това ще създадем нов клас Novel (роман), който ще наследява от Book:",
    "p19ds1": "Java",
    "p1p": "Ти си човек (предполагам). Притежаваш свойства и характеристики на човек. Също си и животно - притежаваш харектиристики на животно. Животните пък са организми, защото притежават основните свойства на организмите - хранене, растеж, размножаване…. Човек може да бъде разгледан като човек и тогава за него ще се говори с човешки характеристики - например определения спектрум цветове, който вижда. Може да се разглежда като животно - тогава не може да се каже, какви цветове вижда, защото различните животни виждат различни цветове. Може да се кажат само най-общите неща отнасящи се за животните - многоклетъчен организъм са. Може човек да бъде представен само като организъм - тогава за него може да се кажат само неща, валидни за организмите - храни се, размножава се и т.н.",
    "p23p": "Ако сега имаш грешки, това е добър знак. Тъй като наследяваме клас с конструктор, трябва да създадем конструктор и в наследяващия клас:",
    "p24ds1": "Java",
    "p28p": "Следващата стъпка е да направим override на метода getBookType()/GetBookType(), който е в Book, защото искаме Novel да връща \"Роман\", не \"Книга\":",
    "p29ds1": "Java",
    "p2p": "Всяко нещо може да бъде представено като част от по-голяма група, в която е - роман е книга - притежава общите характеристики на книга и уникални за роман свойства. Когато ти кажат \"Това е много добра книга\", не можеш да кажеш нещо специфично за нея, защото може да е учебник, наръчник, фентъзи. Ако ти кажат обаче \"Това е много добър роман\", можеш да питаш за главния герой, защото предполагаш че такъв съществува. Но не ти пречи да говориш и за този роман като за книга, защото той е такава.",
    "p33p": "Това е Novel класа. Да го тестваме:",
    "p34ds1": "Java",
    "p38p": "Резултат:",
    "p39con": "Книга\nПипи Дългото чорапче - Астрид Линдгрен\nРоман\nПипи Дългото чорапче - Астрид Линдгрен\nРоман",
    "p3p": "По този начин ние организираме всичко в групи, които наследяват от нещо общо - месото и растенията могат да са храна. Пилешкото е месо. Доматите са растение. Това е йерархия.",
    "p40p": "Действа точно както очаквахме.",
    "p41p": "В този момент е хубаво да ти кажа, че в новите версии на тези езици освен public и private, има и думата protected. Методи и променливи с protected могат да се използват само от класа и тези, които наследяват от него.",
    "p42p": "Между другото, спомняш ли си как в миналия урок говорихме за константи? Класовете и методите също могат да се отбелязват като такива. Ако клас се означи с final в Java или sealed в C#, от него не може да наследи никой друг клас. Ако метод е отбелязан по такъв начин, на него не може да се приложи override, дори и друг клас да го наследява. Това е много добър начин да сигнализираш на другите програмисти, че нещо не трябва да се пипа.",
    "p43rq": "Задачата ти за този урок е да създадеш Vehicle клас (превозно средство). След това създай класове Car (кола), Plane (самолет) и Boat (лодка), наследяващи от него. Избери си модел кола, самолет или лодка и създай клас за него, който наследява от съответния клас. Създай масив от тип Vehicle и го напълни с инстанции на наследяващите класове. Итерирай през елементите на масиви и принтирай кола и нейните свойства, всеки път когато се мине през такава. За да провериш дали обектът от тип Vehicle е кола, използвай проверки с instanceof в Java и (object.GetType() == typeOf(Car)) в C# или (object is Car) в C#, ако искаш да връща true, дори ако object е от клас, който наследява от Car. Разучи тези методи.",
    "p4p": "В последните няколко урока изследваме принципите на обектно-ориентираното програмиране. Неговата цел е да представя нормалните обекти и отношения от живота ни в код по максимално лесен за разчитане начин. Да организира информация по същия начин, по който ние го правим. И подобно на самата концепция на обектите, ООП използва идеите които описах по-горе чрез наследството (inheritance).",
    "p5p": "Наследството ООП казва, че човекът наследява от животното. Романът наследява от книгата. Ако клас Human (човек) наследи от клас Animal (животно), той наследява всички свойства и методи на животното. След това обект тип човек може да се приравни с обект тип животно, защото задължително има неговите методи и свойства. Но обект с тип животно не може да стане обект с тип човек - отново този начин за представяне на обектите.",
    "p6p": "В повечето езици клас може да наследи само от един друг клас - няма как човек едновременно да е животно и нещо друго - общата група е една. От друга страна, може да се наследи клас, който вече наследява от друг клас - ако животно наследява от организъм, човек може да наследи от животно. Така се изгражда йерархия на кода.",
    "p7p": "В Java и C# всеки нов клас автоматично наследява от Object - това е клас от стандартната библиотека, който има някои методи като  .toString()/.ToString(). Всеки обект ги притежава.",
    "p8p": "По-долни класове могат да използват override, за да променят метод от по-горен клас в себе си - животно може да има метод \"направи шум\", който принтира към конзолата \"шум\". След това клас котка може да наследи \"животно\" и да приложи override на метода \"направи шум\" - да го пренапише, така че да принтира \"мяу\" към конзолата. Всяко животно ще продължи да принтира шум, но котките ще принтират \"мяу\". И ако котка се представи като животно, то на конзолата пак ще се принтира \"мяу\", защото за всички котки този метод е пренаписан.",
    "p9p": "Един клас може също да се отбележи с abstract - това значи, че този клас не следва да се използва за създаване на обекти с неговия тип - само за наследство.",
    "s15cj": "package tutorial;\n\npublic class Book {\n\tpublic static final int MIN_LENGTH = 0;\n\tpublic static final int MAX_LENGTH = 30000;\n\tprivate String name;\n\tprivate String author;\n\tprivate int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\tthis.setName(name);\n\t\tthis.setAuthor(author);\n\t\tthis.setLength(length);\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn this.getName() + \" - \" + this.getAuthor();\n\t}\n\t\n\tpublic String getBookType() {\n\t\treturn \"Книга\";\n\t}\n\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\tpublic void setLength(int length) {\n\t\tthis.length = (length < MIN_LENGTH || length > MAX_LENGTH)? 0 : length;\n\t}\n\n\tpublic String getAuthor() {\n\t\treturn author;\n\t}\n\n\tpublic void setAuthor(String author) {\n\t\tthis.author = author;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}",
    "s16ds2": "C#",
    "s17cc": "public class Book\n{\n\tpublic static readonly int MinLength = 0;\n\tpublic static readonly int MaxLength = 30000;\n\tpublic string Name {get; set;}\n\tpublic string Author {get; set;}\n\tpublic int Length \n\t{\n\t\tget \n\t\t{\n\t\t\treturn this.Length;\n\t\t}\n\t\tset \n\t\t{ \n\t\t\tthis.Length = (value < MinLength || value > MaxLength)? 0 : value;\n\t\t}\n\t}\n\t\n\tpublic Book(string name, string author, int length) \n\t{\n\t\tthis.Name = name;\n\t\tthis.Author = author;\n\t\tthis.Length = length;\n\t}\n\t\n\tpublic String GetBookType() \n`\t{\n\t\treturn \"Книга\";\n\t}\n\t\n\tpublic string GetFullName() \n\t{\n\t\treturn this.Name + \" - \" + this.Author;\n\t}\n}",
    "s20cj": "package tutorial;\n\npublic class Novel extends Book { // В Java се наследява чрез думата extends (продължава, уголемява)\n}",
    "s21ds2": "C#",
    "s22cc": "using System;\n\npublic class Novel : Book // В C# се наследява чрез \":\"\n{\n\t\n}",
    "s25cj": "package tutorial;\n\npublic class Novel extends Book {\n\n\tpublic Novel(String name, String author, int length) { // Това е констуктора\n\t\tsuper(name, author, length); // super е важна част - това представлява констуртора на Book, трябва да го викнем\n\t}\n}",
    "s26ds2": "C#",
    "s27cc": "public class Novel : Book \n{\n\tpublic Novel(string name, string author, int length) : base(name, author, length)\n\t// base е важна част - представлява конструктора на Book, трябва да го викнем\n\t{\n\t}\n}",
    "s30cj": "package tutorial;\n\npublic class Novel extends Book {\n\n\tpublic Novel(String name, String author, int length) {\n\t\tsuper(name, author, length);\n\t}\n\n\t@Override  // Този ред не е задължителен, но някои хора го пишат при всички прилагания на override\n\tpublic String getBookType() {\n\t\treturn \"Роман\";\n\t}\t\n}",
    "s31ds2": "C#",
    "s32cc": "public class Novel : Book \n{\n\tpublic Novel(string name, string author, int length) : base(name, author, length)\n\t{\n\t}\n\t\n\tpublic override string GetBookType() // override не е задължителен, но препоръчителен, за да сигнализира за override. Важно е, че ако метод не е маркиран като abstract, а искаш да му приложиш override, той трябва да се маркира с virtual в класа, от който се наследява; тоест, GetBookType() трябва да е virtual в Book\n\t{\n\t\treturn \"Роман\";\n\t}\n}",
    "s35cj": "package tutorial;\n\npublic class Classes {\n\tpublic static void main(String[] args) {\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от оз\", \"Лиман Баум\", 173);\n\t\tSystem.out.println(theWizardOfOz.getBookType());\n\t\tNovel longSock = new Novel(\"Пипи Дългото чорапче\", \"Астрид Линдгрен\", 350);\n\t\tSystem.out.println(longSock.getFullName());\n\t\tSystem.out.println(longSock.getBookType());\n\t\tBook book = longSock;\n\t\tSystem.out.println(book.getFullName());\n\t\tSystem.out.println(book.getBookType());\n\t}\n}",
    "s36ds2": "C#",
    "s37cc": "using System;\n\npublic class Classes\n{\n\tpublic static void Main(String[] args)\n\t{\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от оз\", \"Лиман Баум\", 173);\n\t\tConsole.WriteLine(theWizardOfOz.GetBookType());\n\t\tNovel longSock = new Novel(\"Пипи Дългото чорапче\", \"Астрид Линдгрен\", 350);\n\t\tConsole.WriteLine(longSock.GetFullName());\n\t\tConsole.WriteLine(longSock.GetBookType());\n\t\tBook book = longSock;\n\t\tConsole.WriteLine(book.GetFullName());\n\t\tConsole.WriteLine(book.GetBookType());\n\t}\n}",
    "text": "Където ще научиш какво е наследяването",
    "title": "Урок 32"
  },
  "l33": {
    "p10ds1": "Java",
    "p14p": "Вече и в двата класа сме имплементирали print(). Вече можем да направим това в main():",
    "p15ds1": "Java",
    "p19p": "Резултат:",
    "p1p": "В предния урок разгледахме наследството - поне относно класове. Наследството от класове е доста \"тежка\" задача и всеки клас може да го прави от само един друг клас. Понякога просто ни трябва да знаем, че няколко различни класа имат общ метод. За това отговаря другата част от наследството - интерфейсите (interfaces).",
    "p21": "Това е очаквания резултат.",
    "p22rq": "Потърси за анонимните функции (ламбди - lambdas)",
    "p23rq": "Всеки клас наследява от Object. Опитай да приложиш override на .toString()/.ToString() (към низ) или .equals()/.Equals() (равно е на).",
    "p2p": "Един клас може да наследява повече от един интерфейса. Птиците могат да ходят и някои роботи също могат да ходят. Това не означава, че бихме представили птиците и роботите като наследяващи от един клас. Интерфейсите представят качество - нещо може да лети, нещо може да бъде сортирано. Интерфейсите имат само и единствено абстрактни методи. Когато клас наследява от интерфейс, той е задължен да имплементира всичките му методи. В този урок ще напишем интерфейс, който показва, че нещо може да се принтира. Да започваме:",
    "p3p": "Първо ще създадем интерфейс. За имена обикновено имат английски прилагателни с глаголен произход. В C# имената им винаги започват с I (главно \"i\" - от Interface). Обикновено се правят в нов файл. Интерфейсът ще се казва \"Printable\"(Java)/\"IPrintable\"(C#) (принтируемо).",
    "p4ds1": "Java",
    "p8p": "Това е интерфейса. Друго не ни трябва.",
    "p9p": "Сега да го наследим в Book и да имплементираме print():",
    "s11cj": "package tutorial;\n\npublic class Book implements Printable { // Наследяване на интерфейс става с implements; implements обикновено стои след extends, ако класа наследява и от друг клас; Ако се наследява повече от един интерфейс, имената се разделят със запетаи\n\tpublic static final int MIN_LENGTH = 0;\n\tpublic static final int MAX_LENGTH = 30000;\n\tprivate String name;\n\tprivate String author;\n\tprivate int length;\n\n\tpublic Book(String name, String author, int length) {\n\t\tthis.setName(name);\n\t\tthis.setAuthor(author);\n\t\tthis.setLength(length);\n\t}\n\t\n\tpublic String getFullName() {\n\t\treturn this.getName() + \" - \" + this.getAuthor();\n\t}\n\t\n\tpublic String getBookType() {\n\t\treturn \"Книга\";\n\t}\n\n\tpublic int getLength() {\n\t\treturn length;\n\t}\n\n\tpublic void setLength(int length) {\n\t\tthis.length = (length < MIN_LENGTH || length > MAX_LENGTH)? 0 : length;\n\t}\n\n\tpublic String getAuthor() {\n\t\treturn author;\n\t}\n\n\tpublic void setAuthor(String author) {\n\t\tthis.author = author;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t@Override\n\tpublic void print() {\n\t\tSystem.out.println(this.getFullName());\n\t}\n}",
    "s12ds2": "C#",
    "s13cc": "using System;\n\npublic class Book : IPrintable // Наследява се отново с \":\". Ако се наследяват няколко интерфейса, или клас с няколко интерфейса, имената се разделят със запетаи\n{\n\tpublic static readonly int MinLength = 0;\n\tpublic static readonly int MaxLength = 30000;\n\tpublic string Name {get; set;}\n\tpublic string Author {get; set;}\n\tpublic int Length \n\t{\n\t\tget \n\t\t{\n\t\t\treturn this.Length;\n\t\t}\n\t\tset \n\t\t{ \n\t\t\tthis.Length = (value < MinLength || value > MaxLength)? 0 : value;\n\t\t}\n\t}\n\t\n\tpublic Book(string name, string author, int length) \n\t{\n\t\tthis.Name = name;\n\t\tthis.Author = author;\n\t\tthis.Length = length;\n\t}\n\t\n\tpublic string GetBookType() \n\t{\n\t\treturn \"Книга\";\n\t}\n\t\n\tpublic string GetFullName() \n\t{\n\t\treturn this.Name + \" - \" + this.Author;\n\t}\n\t\n\tpublic void Print() \n\t{\n\t\tConsole.WriteLine(this.GetFullName());\n\t}\n}",
    "s16cj": "package tutorial;\n\npublic class Classes {\n\tpublic static void main(String[] args) {\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от оз\", \"Лиман Баум\", 173);\n\t\ttheWizardOfOz.print();\n\t\tNovel longSock = new Novel(\"Пипи Дългото чорапче\", \"Астрид Линдгрен\", 350);\n\t\tlongSock.print();\n\t\t/*\n\t\tТова, което правя по-долу е една от магиите на Java\n\t\tНарича се анонимен клас\n\t\tПонякога някоя функция иска интерфейс като тип на аргумент\n\t\tНе можеш да създадеш обект от интерфейс, защото методите са абстрактни и реално не съществуват (не правят нищо)\n\t\tПоради тази причина можеш да напишеш по-долния код и да напишеш методите на място\n\t\tНарича се анонимен клас, защото реално създаваш нов клас, който е празен и е наследил интерфейса\n\t\tСлед това само попълваш методите му и получаваш готов обект\n\t\tТъй като не си декларирал класа, не можеш да го създадеш отново и той е анонимен\n\t\t*/\n\t\tPrintable anonymous = new Printable() {\n\t\t\tpublic void print() {\n\t\t\t\tSystem.out.println(\"Анонимнен клас\");\n\t\t\t}\n\t\t};\n\t\tPrintable[] printables = {theWizardOfOz, longSock, anonymous};\n\t\t\n\t\tfor (int i = 0; i < printables.length; i++) {\n\t\t    printables[i].print();\n\t\t}\n\t}\n}",
    "s17con": "Вълшебникът от оз - Лиман Баум\nПипи Дългото чорапче - Астрид Линдгрен\nВълшебникът от оз - Лиман Баум\nПипи Дългото чорапче - Астрид Линдгрен\nАнонимен клас",
    "s17ds2": "C#",
    "s18cc": "using System;\n\npublic class Classes\n{\n\tpublic static void Main(String[] args)\n\t{\n\t\tBook theWizardOfOz = new Book(\"Вълшебникът от оз\", \"Лиман Баум\", 173);\n\t\ttheWizardOfOz.Print();\n\t\tNovel longSock = new Novel(\"Пипи Дългото чорапче\", \"Астрид Линдгрен\", 350);\n\t\tlongSock.Print();\n\t\tIPrintable printable = theWizardOfOz;\n\t\tprintable.Print();\n\t}\n}",
    "s18con": "Вълшебникът от оз - Лиман Баум\nПипи Дългото чорапче - Астрид Линдгрен\nВълшебникът от оз - Лиман Баум",
    "s5cj": "package tutorial;\n\npublic interface Printable {\n\tvoid print();\n}",
    "s6ds2": "C#",
    "s7cc": "using System;\n\npublic interface IPrintable {\n\tvoid Print();\n}",
    "text": "Където ще научиш, че интерфейсите не са само графични",
    "title": "Урок 33"
  },
  "l34": {
    "p10p": "След това ще декларираме, че искаме типов аргумент чрез <T>. Щом сме написали това, вече T ще може да се използва като тип из целия клас и ще се изисква като аргумент при създаване на обект на класа.",
    "p11ds1": "Java",
    "p15p": "Сега да напишем конструктора. Той ще приема променлива с тип T, която ще наречем value (стойност). Ще я запазим в променлива (свойство) на класа:",
    "p16ds1": "Java",
    "p1p": "Преди доста време четях код и забелязах нещо странно - след имената на някои класове имаше странен синтакс - \"<тип>\". Седях и се чудех какво може да е това. Отворих браузъра и започнах да търся. В процеса установих, че всъщност машините за търсене игнорират специални символи като \"<\" и \">\", което много усложни търсенето. В някакъв момент случайно попаднах на името на оператора - \"diamond operator\" (диамантен оператор). Въоръжен с тази информация, отново се запътих към дълбините на Интернета. В крайна сметка открих каквото търсех в едно видео за C#. Познати под притеснително количество различни имена, в този урок ще учиш за \"Generics\".",
    "p20p": "Сега искаме да създадем get-търи и set-търи. Ако използваш Java, забележи как връщаме и приемаме променливи с тип T. \"newValue\" означава \"нова стойност\".",
    "p21ds1": "Java",
    "p25p": "Вече можем да създадем обект на класа Box като дадем типов аргумент и стойности за конструктора. Типовите аргументи се пишат след името на типа - напр. \"Box<Book>\" е тип Box, в който типовият аргумент е Book, тоест навсякъде в обекта T е Book.",
    "p26ds1": "Java",
    "p2p": "В този урок ще създадем клас Box (кутия). Идеята не е сложна - класът съхранява една единствена променлива, дадена му през конструктура. Има само един проблем - ние не знаем типа на променливата.",
    "p30p": "Резултат:",
    "p31con": "a\nВълшебникът от оз - Лиман Баум",
    "p32p": "Можем и да ограничаваме приеманите типове на такива, които наследяват от специфичен клас или интерфейс.",
    "p33ds1": "Java",
    "p37p": "При тези примери, T би могло да е единствено от тип, който наследява от Book.",
    "p38p": "Може да се приема и повече от един аргумент за тип, стига аргументите да са разделени със запетаи. Обикновено вторият се кръщава V (напр. \"Pair<T, V>\" - клас, представляващ двойка променливи и приемащ два различни типови аргумента, които да са типове за двете му променливи). Ограничения върху типовете все още могат да се прилагат.",
    "p39e": "В Java Generics работи само с класове. Тоест, примитивните типове int, float, double, short, long, char, boolean не могат да са типови аргументи. Ако се налага да използваш един от тези типове като аргументи, трябва да използваш съответните им класове - Integer, Float, Double, Short, Long, Character, Boolean. Тези класове също имат и някои помощни статични и нестатични методи за конверсии и т.н.",
    "p3p": "Това разрешават Generics (\"дженерикс\", идва от generic (\"общо\")). Те ни позволяват да приемем типа на променлива като аргумент.",
    "p40p": "Нямаш задача за този урок. Почини си.",
    "p4p": "Да започваме.",
    "p5p": "Първо ще създадем класа Box.",
    "p6ds1": "Java",
    "s12cj": "package tutorial;\n\npublic class Box<T> {\n}",
    "s13ds2": "C#",
    "s14cc": "public class Box <T>\n{\n}",
    "s17cj": "package tutorial;\n\nclass Box<T> {\n\tprivate T value;\n\t\n\tpublic Box(T x) {\n\t\tthis.value = x;\n\t}\n}",
    "s18ds2": "C#",
    "s19cc": "class Box<T> \n{\n\tpublic  T Value;\n\t\n\tpublic Box(T x) \n\t{\n\t\tthis.Value = x;\n\t}\n}",
    "s22cj": "package tutorial;\n\nclass Box<T> {\n\tprivate T value;\n\t\n\tpublic Box(T x) {\n\t\tthis.value = x;\n\t}\n\t\n\tpublic T getValue() {\n\t\treturn this.value;\n\t}\n\t\n\tpublic void setValue(T newValue) {\n\t\tthis.value = newValue;\n\t}\n}",
    "s23ds2": "C#",
    "s24cc": "class Box<T> \n{\n   public T Value {get; set;}\n\t\n\tpublic Box(T x) \n\t{\n\t\tthis.Value = x;\n\t}\n}",
    "s27cj": "package tutorial;\n\npublic class Generics {\n\tpublic static void main(String[] args) {\n\t\tBox<String> box = new Box<String>(\"\");\n\t\tbox.setValue(\"a\");\n\t\tSystem.out.println(box.getValue());\n\t\tBox<Book> bookBox = new Box<Book>(new Book(\"Вълшебникът от оз\", \"Лиман Баум\", 173));\n\t\tSystem.out.println(bookBox.getValue().getFullName());\n\t}\n}",
    "s28ds2": "C#",
    "s29cc": "using System;\npublic class Generics\n{\n\tpublic static void Main(String[] args)\n\t{\n\t\tBox<String> box = new Box<String>(\"\");\n\t\tbox.Value = \"a\";\n\t\tConsole.WriteLine(box.Value);\n\t\tBox<Book> bookBox = new Box<Book>(new Book(\"Вълшебникът от оз\", \"Лиман Баум\", 173));\n\t\tConsole.WriteLine(bookBox.Value.GetFullName());\n\t\t\n\t}\n}",
    "s34cj": "package tutorial;\n\nclass Box<T extends Book> {\n}",
    "s35ds2": "C#",
    "s36cc": "class Box<T> where T : Book \n{\n}",
    "s7cj": "package tutorial;\n\npublic class Box{\n}",
    "s8ds2": "C#",
    "s9cc": "public class Box\n{\n}",
    "text": "Където ще се научиш да запазваш нещо, без да знаеш какво е то",
    "title": "Урок 34"
  },
  "l35": {
    "p10p": "Първо, можем да представим сезоните като числа или низове:",
    "p11ds1": "Java",
    "p15p": "Може би вече си забелязал проблема - това са или магически числа, или магически низове. Опитай да познаеш за кой сезон генерирам? Всъщност е лято, защото съм решил да броя от 0. Някой друг може да е решил да брои от 1 или 2. Някой може да е решил сезоните да са през 100. Схващаш проблема.",
    "p16p": "Ние вече сме се срещали с магически числа. Последния път решихме проблема със статични константи:",
    "p17ds1": "Java",
    "p1p": "Представи си, че правиш програма, която приема сезон и генерира температура, подходяща за този сезон в сегашната ти локация.",
    "p21p": "Това със сигурност е по-добре. И по-разбираемо. Но няма смисъл да пишеш целия този код. Цялата му цел е да ти представя решението - енумерации (Enum).",
    "p22p": "Така се създава нов enum:",
    "p23ds1": "Java",
    "p27p": "Това е. От тук нататък можем да правим това, за да поискаме enum като аргумент:",
    "p28ds1": "Java",
    "p2p": "Големият въпрос в този случай е \"Как представяме сезоните кодово?\"",
    "p32p": "Можем да викаме функциите така:",
    "p33ds1": "Java",
    "p37p": "И всичко се вижда веднага. Освен това можем да сравняваме:",
    "p38ds1": "Java",
    "p3p": "Първият вариант е чрез различни методи (за целите на този урок - Spring е пролет, Summer е лято, Autumn/Fall е есен, Winter е зима, generate е Генерирай, Temperature е температура и Seasons е сезони):",
    "p42p": "И други подобни неща.",
    "p43p": "Това е от този урок.",
    "p44rq": "Задачата ти е да представиш посоки (ляво, дясно, напред, назад) в енумерация. Създай променлива цяло число с начална стойност 5. Създай метод, който приема променливата и една от посоките. В метода да се открива коя е подадената посока и да се редактира променливата спрямо нея - ляво е +2, дясно е +3, напред е +1, назад е -1, а новата променлива да се връща. Използвай метода, за да опишеш пътя до някоя локация, която посещаваш често - например до магазин - дясно, напред, ляво, напред, дясно, напред, дясно. След като опишеш пътя в програмата, принтирай променливата цяло число и виж как се е променила. При моя пример би била 19.",
    "p4ds1": "Java",
    "p8p": "Както виждаш, това са доста методи и става малко \"манджа с грозде\". Не че не е валиден начин - в този случай би действало перфектно. Но представи си вместо 4 сезона имаш 7 дена или 12 месеца.",
    "p9p": "Значи, целта е да направим един метод generateTemperature()/GenerateTemperature () и той да приема като аргумент сезона. След това да проверява възможните стойност със switch и да генерира температура, когато има съвпадение.",
    "s12cj": "class TemperatureGenerator {\n\n\tpublic static void main(String[] args) {\n\t\tgenerateTemperature(1);\n\t}\n}",
    "s13ds2": "C#",
    "s14cc": "class TemperatureGenerator {\n\n\tpublic static void main(String[] args) {\n\t\tGenerateTemperature(1);\n\t}\n}",
    "s18cj": "class TemperatureGenerator {\n\tpublic static readonly SPRING = 0;\n\tpublic static readonly SUMMER = 1;\n\tpublic static readonly AUTUMN = 2;\n\tpublic static readonly WINTER = 3;\n\t\n\tpublic static void main(String[] args) {\n\t\tgenerateTemperature(SPRING);\n\t}\n}",
    "s19ds2": "C#",
    "s20cc": "class TemperatureGenerator {\n\tpublic static readonly Spring = 0;\n\tpublic static readonly Summer = 1;\n\tpublic static readonly Autumn = 2;\n\tpublic static readonly Winter = 3;\n\t\n\tpublic static void Main(string[] args) {\n\t\tGenerateTemperature(Spring);\n\t}\n}",
    "s24cj": "package tutorial;\n\npublic enum Seasons {\n\tSpring,\n\tSummer,\n\tAutumn,\n\tWinter\n}",
    "s25ds2": "C#",
    "s26cc": "public enum Seasons {\n\tSpring,\n\tSummer,\n\tAutumn,\n\tWinter\n}",
    "s29cj": "class TemperatureGenerator {\n\t\n\tpublic static int generateTemperature(Seasons season) {\n\t\t\n\t}\n}",
    "s30ds2": "C#",
    "s31cc": "class TemperatureGenerator {\n\t\n\tpublic static int GenerateTemperature(Seasons season) {\n\t\t\n\t}\n}",
    "s34cj": "class TemperatureGenerator {\n\t\n\tpublic static void main(String[] args) {\n\t\tgenerateTemperature(Seasons.Summer);\n\t}\n}",
    "s35ds2": "C#",
    "s36cc": "class TemperatureGenerator {\n\t\n\tpublic static void Main(string[] args) {\n\t\tGenerateTemperature(Seasons.Summer);\n\t}\n}",
    "s39cj": "class TemperatureGenerator {\n\t\n\tpublic static int generateTemperature(Seasons season) {\n\t\tif (season == Seasons.Summer) { // може просто с if\n\t\t\treturn 30;\n\t\t}\n\t\n\t\tswitch (season) {\n\t\t\tcase Winter:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\t… // Останала част от проверките в switch\n\t\t}\n\t}\n}",
    "s40ds2": "C#",
    "s41cc": "class TemperatureGenerator {\n\t\n\tpublic static int GenerateTemperature(Seasons season) \n\t{\n\t\tif (season == Seasons.Summer) \n\t\t{ // може просто с if\n\t\t\treturn 30;\n\t\t}\n\t\n\t\tswitch (season) \n\t\t{\n\t\t\tcase Seasons.Winter:\n\t\t\treturn 0;\n\t\t\tbreak;\n\t\t… // Останала част от проверките в switch\n\t\t}\n\t}\n}",
    "s5cj": "class TemperatureGenerator {\n\n\tpublic static int generateTemperatureSpring() {\n\t\t…\n\t}\n\tpublic static int generateTemperatureSummer () {\n\t\t…\n\t}\n\tpublic static int generateTemperatureAutumn () {\n\t\t…\n\t}\n\tpublic static int generateTemperatureWinter () {\n\t\t…\n\t}\n}",
    "s6ds2": "C#",
    "s7cc": "class TemperatureGenerator {\n\n\tpublic static int GenerateTemperatureSpring() {\n\t\t…\n\t}\n\tpublic static int GenerateTemperatureSummer () {\n\t\t…\n\t}\n\tpublic static int GenerateTemperatureAutumn () {\n\t\t…\n\t}\n\tpublic static int GenerateTemperatureWinter () {\n\t\t…\n\t}\n}",
    "text": "Където ще научиш как да не използваш магия",
    "title": "Урок 35"
  },
  "l36": {
    "p10p": "Exception-ите са неприятна, но очаквана част от програмирането. Грешки се случват, а понякога са достатъчно сериозни, че програмата не може да продължи изпълнението си - няма как да се възстановиш от деление на 0.",
    "p11p": "Въпреки това, не може просто програми да спират да работят, защото нещо не се е свързало правилно или някой файл е отказал да бъде прочетен. Представи си ракета със сателит за милиарди да падне, защото файл не е бил отворен правилно и Exception-а е прекъснал изпълнението на контролния софтуер. Би било провала на века.",
    "p12p": "За тази цел е измислена конструкцията try-catch-finally.",
    "p13p": "Първо имаме try (\"опитай\") блок. В него се записва кода, който може да причини изключение. След това има catch (\"хвани\") блок. Той е като функция, която приема тип изключение, който се очаква да хвърли try блока. Всички изключения са класове, които наследяват от един общ клас Exception, тъй че ако не знаеш типа изключение, може просто да напишеш \"Exception <някакво име>\". Ако в try блока се появи Exception, който отговаря на типа в catch блока, изпълнението на кода прекъсва на реда в try блока, на който се е появило изключението и преминава на кода в catch блока. На конзолата не се принтира грешка и програмата не спира, защото изключението е била хванато и кода в catch блока се занимава с възстановяването от него. Ако има finally (\"последно\") блок, той винаги се изпълнява след всички други, независимо дали има изключение или не. Използва се за разчистване, напр. затваряне на файл, отворен в try блока. След като всичко е изпълнено, програмата продължава изпълнението си нормално. Да видим пример:",
    "p14ds1": "Java",
    "p1p": "Ако четеш този урок, предполагам че вече си виждал/а доста грешки в конзолатата по време на изпълнение на програмите ти - страшни дълги червени съобщения, по-голямата част от които са объркващи",
    "p20p": "Резултат:",
    "p21con": "catch\nfinally",
    "p22p": "Можем да причиняваме изключения и сами чрез думата throw (\"хвърлям\") и обект от тип Exception (или наследяващ клас). Конструктора на Exception приема низ, който е съобщението за грешка. Между другото, ако още не си забелязал, всичко говори за хвърляне и хващане на изключения все едно са баскетболни топки. За жалост, не можах да проследя откъде са произлезли наименованията.",
    "p23ds1": "Java",
    "p2p": "Наричат се Exception-и (\"ексепшън\") - \"изключения\". Получават се когато… ами, има изключение в кода ти. Kод, който не отговаря на правилата на езика е изключение в езика. Заедно причинихме StackOverflow, когато говорихме за рекурсия. Това е изключение от правилото за максимакна големина на стака.",
    "p32p": "Try-catch е начин да оправяш очевидните грешки - тези, които пускат огромни червени съобщения в конзолата и спират действието на програмата. Не всички грешки обаче са такива. Понякога резултата излиза с 1 по-малък от очакваното, или с 1 по-голям и нямаш никаква идея как се е случило. Това се разрешава с помощта на Debugger (\"дебъгър\").",
    "p33p": "Ако си стигнал/a дотук, най-вероятно поне веднъж си принтирал/a на конзолата променлива в средата на програмата, за да провериш стойността и. За жалост, Debugger-ът не ти поправя бъговете автоматично както аз си мислех преди, но поне ти позволява да видиш стойностите на всички променливи в програмата (и много други неща) в точен ред от изпълнението.",
    "p34p": "Основния инструмент на всеки debugger са така наречените Breakpoints (\"брейкпойнтс\" - точки на спиране). В повечето IDE-та, те се поставят като натиснеш един (или няколко пъти) от лявата страна на номера на реда, на който искаш да поставиш точката за спиране. Ако се получи, там ще се появи една червена точка. Докато кода се изпълнява в режим \"debug\", изпълнението ще спира всеки път когато стигне до този ред и ще ти дава да разглеждаш стойностите на всички променливи в този момент.",
    "p35p": "Debugger-ът обикновено се стартира чрез иконка, близка до Run (пускане) бутона. Обикновено е показана като буквална хлебарка (от bug - насекомо), понякога по друг начин. Изпълнението спира на breakpoint-ове единствено, когато програмата е стартирана в режим \"debug\".",
    "p36p": "Когато програмата спре на breakpoint, имаш опцията да видиш състоянието на променливите, обикновено в някой страничен панел. Освен това имаш няколко опции - първата обикновено е step-over, която преминава на следващия ред на сегашната функция. Втората обикновено е step-in, която отива в която и да е функция, викната на ред. Най-често последната опция е продължаване на екзекуцията, което продължава програмата нормално, докато не се стигне до нов breakpoint. Може да има и червен квадрат, който е бутона за спиране на екзекуцията на програмата. Той не е част от Debug опциите, но обикновено е близо до тях. Тези опции обикновено са в непосредствена близост до Debug бутона.",
    "p37p": "Сега ти препоръчвам да намериш някоя задача, която си правил/a, да сложиш breakpoint на всеки ред и да я преминеш с Debugger, за да се упражниш.",
    "p38rq": "Тъй като вече би трябвало да имаш основните знания, потърси как се отварят, четат и затварят файлове в избрания ти език. Създай прост текстов файл, напиши нещо в него и създай програма, която чете съдържанието на файла и го принтира на конзолата.",
    "p3p": "За разлика от грешките в компилацията, Exception-ите се случват винаги през изпълнението на програмата (Runtime).",
    "p4p": "Най-бързият начин да причиним Exception е да разделим число на 0. В нормалната математика това не работи и съответно не работи и в програмните езици:",
    "p5ds1": "Java",
    "p9p": "В C# деленето 5/0 не причинява Exception, а грешка в компилацията, защото компилатора предварително сканира за подобни грешки. За да \"излъжем\" езика, делим на променлива равна на 0.",
    "s15cj": "package tutorial;\n\npublic class Exceptions {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tint num = 5 / 0;\n\t\t}\n\t\tcatch (ArithmeticException e) {\n\t\t\tSystem.out.println(\"catch\");\n\t\t}\n\t\tfinally {\n\t\t\tSystem.out.println(\"finally\");\n\t\t}\n\t}\n}",
    "s16t": "Забележи вида Exception - ArithmeticException (\"аритметично изключение\").",
    "s17ds2": "C#",
    "s18cc": "using System;\n\npublic class Exceptions\n{\n\tpublic static void Main(String[] args)\n\t{\n\t\ttry {\n\t\t\tint zero = 0;\n\t\t\tint num = 5 / zero;\n\t\t}\n\t\tcatch (DivideByZeroException e) {\n\t\t\tConsole.WriteLine(\"catch\");\n\t\t}\n\t\tfinally {\n\t\t\tConsole.WriteLine(\"finally\");\n\t\t}\n\t}\n}",
    "s19t": "Забележи вида Exception - DivideByZeroException (\"изключение за делене на нула\").",
    "s24cj": "package tutorial;\n\npublic class Exceptions {\n\tpublic static void main(String[] args) throws Exception {\n\t\tthrow new Exception(\"Някакво съобщение за грешка\");\n\t}\n}",
    "s25p": "Забележи как в края на декларацията на main има \"throws Exception\". Това означава, че този метод може да причини дадения Exception и това е очаквано поведение, тоест не е в try-catch. Ако този метод се викне някъде другаде, викащия да го заобгради с try-catch или да декларира собствения си метод като хвърлящ изключението. Тъй като няма метод преди main, ние можем да изпълним програмата.",
    "s26p": "Резултат:",
    "s27con": "Exception in thread \"main\" java.lang.Exception: Някакво съобщение за грешка\n<<prefix>>\tat tutorial.Exceptions.main(Exceptions.java:5)",
    "s28ds2": "C#",
    "s29cc": "using System;\n\npublic class Exceptions\n{\n\tpublic static void Main(String[] args)\n\t{\n\t\tthrow new Exception(\"Някакво съобщение за грешка\");\n\t}\n}",
    "s30p": "Резултат:",
    "s31con": "Run-time exception (line 9): Някакво съобщение за грешка\n<<prefix>>\n<<prefix>>Stack Trace:\n<<prefix>>\n<<prefix>>[System.Exception: Някакво съобщение за грешка]\n<<prefix>>   at Exceptions.Main(String[] args) :line 9",
    "s6cj": "package tutorial;\n\npublic class Exceptions {\n\tpublic static void main(String[] args) {\n\t\tint num = 5 / 0;\n\t}\n}",
    "s7ds2": "C#",
    "s8cc": "using System;\n\npublic class Exceptions\n{\n\t\n\tpublic static void Main(String[] args)\n\t{\n\t\tint zero = 0;\n\t\tint num = 5 / zero;\n\t}\n}",
    "text": "Където ще научиш как да си оправяш грешките",
    "title": "Урок 36"
  },
  "l37": {
    "p10p": "Можеш да извършиш join (\"присъединяване\") на тред. Това е еквивалента на това да спреш в отбивка, да изчакаш тред 2 да изчезне и чак тогава да си продължиш пътя.",
    "p11p": "Можеш и да извършиш sleep (\"заспи\") на тред. Това е еквивалента на това да замръзнеш докато караш заедно с колата и всичко друго около теб. Единствените, които продължават работата си са другите тредове.",
    "p12p": "Понякога с тредовете се появяват и проблеми. Представи си, че ти трябва номер на улица, записан на листче в жабката. Взимаш го и на него пише 46. Оглеждаш се, поглеждаш отново листчето и този път пише 23! Как така?",
    "p13p": "Това се случва, защото в момента, в който ти не си гледал, тред 2 е използвал листчето от жабката и е записал на него номера на улица, който са му диктували на телефона. Ти и тред 2 не можете да си комуникирате, но ако и двамата използвате едно и също листче, то може стойността да се променя нелогично в рамките на стотни от секундата.",
    "p14p": "Това се случва при тредовете, ако не си внимателен. Може да провериш дали една променлива е равна на 0. Тя не е равна, значи отиваш в if блока и си спокоен, че можеш да делиш с нея. Изведнъж в конзолата се появява Exception . Във времето между двата реда -  проверката и делението - тред 2 е успял да промени стойността на променливата на 0. Това явление се нарича \"race condition\" - \"състезателно условие\", защото двата треда се \"състезават\" за промяна на стойността. Най-лошото е, че при друго изпълнение на програмата, може тред 1 да е по-бърз от тред 2 и грешката да не се появи. Късмет да намериш проблем, който се случва всяко десето изпълнение на програмата.",
    "p15p": "Главният начин за борба с това е просто да не редактираш еднакви променливи в 2 или повече треда. Ако ти се налага, можеш да използва synchronized (\"синхронизирано\") блоковете в Java и lock (\"ключалка\") блоковете в C#. Те гарантират, че кода в тях ще се изпълни само от 1 тред по 1 време. Ако някой тред поиска да изпълни кода, докато друг се занимава с него, той ще трябва да изчака другият да приключи изпълнението си. Тези блокове могат да забавят програмата значително, но много често времовите печалби от изпълнинението на няколко задачи едновременно са по-големи.",
    "p16p": "Тредовете се използват навсякъде. Например, повечето игри имат поне 2 треда - 1 се занимава с играта, докато друг прави \"обаждания\" към сървъра и чака отговор. Повечето приложения също имат поне 2 треда - 1 се занимава с показването на графика, а дргуия - с изчисления и сложни операции. Поради тази причина интерфейсът на калкулатора не спира да действа, докато той изчислява някоя огромна стойност. Да преминем към следващия начин - async.",
    "p17p": "Използвайки отново нашия пример с колата, ти отново си главния тред. Ти отново управляваш колата. Отново ти звъни телефона. Но този път, вместо да създадеш нов тред, ти продължаваш да караш, докато видиш отбивка. Спираш там, и чак тогава вдигаш телефона. Извършваш обаждането и си продължаваш по пътя.",
    "p18p": "Както забеляваш, реално ти не правиш две неща едновременно по този начин. Дългата задача просто се отлага до момент, в който имаш време. Поради тази причина Javascript няма тредове - има само един главен тред, а почти всяка друга задача е асинхронна. Можеш да използваш и await (\"изчакай\"), което означава, че спираш да караш по средата на пътя, трафикът спира и извършваш обаждането - тогава не си изпълнил главната си задача, но нямаш избор - трябва да спреш. След това продължаваш по пътя си.",
    "p19p": "Към момена, асинхронното изпълнение не е много разпространено. Има го в Javascript, C#, Python, Kotlin. В Java трябва да разчиташ на библиотеки, създадени от други хора, ако искаш As of now, asynchronous execution is not very common. It's in Javascript, C#, Python, Kotlin. In Java, you have to rely on libraries created by other people if you want to use it. In some languages like C++ it is now appearing, via the C++20 standard (2020).да го използваш. В някои езици като C++ то сега се появява, чрез стандарта C++20 (2020 година).",
    "p1p": "Караш кола. Докато караш въпросната кола ти звъни телефона.",
    "p20rq": "Ако не си забелязал, през целия урок не съм написал и един ред код. Твоята задача е да разучиш как се създават и използват тредове в твоя език. Ако използваш C# (или когато четеш това вече има async в Java), намери и как се използва async.",
    "p2p": "Каквo можеш да направиш?",
    "p3p": "Ако си добър член на обществото, няма да вдигнеш телефона или ще използваш hands free устройство. Ако не си, най-вероятно ще вдигнеш телефона и ще говориш, докато караш.",
    "p4p": "Компютърът няма тези варианти, обаче понякога на програмистите им се налага да изпълняват 2 или повече задача едновременно в една програма.",
    "p5p": "За изпълнението на това има два начина - threads (\"тредове\" - нишки) и async (\"ейсинк\" - aсинхронно/несингронно - идва от \"asynchronous\").",
    "p6p": "Тредовете са най-стария и най-разпространения начин. Почти всеки език ги има, а малкото, които ги нямат, имат много добри извинения (напр. Javascript). Използвайки нашия пример с колата, приеми, че ти си главния тред. Ти управляваш колата. Когато ти звънне телефона, ти, като главния тред, създаваш още един човек - втори тред. Даваш му телефона с някаква информация и му казваш:",
    "p7p": "- Проведи разговора.",
    "p8p": "Съответно, вторият човек провежда разговора, докато ти караш. Той не осъзнава накъде караш, и ти не можеш да чуеш какво си говори с другия човек по телефона. Двамата съществувате отделно един от друг.",
    "p9p": "В някакъв момент, тред 2 приключва своя разговор, връща ти телефона и изчезва.",
    "text": "Където ще научиш как да правиш няколко неща едновременно",
    "title": "Урок 37"
  },
  "l38": {
    "p13p": "Dictionary/Map (Речник/Карта) е структура, която подобно на речник ни позволява да запазим ключ и негова стойност. Ако си спомняш, формата JSON е нещо подобно. Ключовете трябва да са уникални, но стойностите може да не са.",
    "p14p": "Речникът/Картата приема два аргумент за тип - единият е типа на ключовете, а другият е типа на стойностите - <String, String> би означавало, че ключовете са низове и стойностите -също. По този начин можем да запазим информация като \"режим\" - \"светъл\", където \"режим\" е ключа. По-късно, от речника можем да поискаме стойността на низа \"режим\" и да получим \"светъл\". Чрез ключа можем да заменяме и изтриваме стойността му. Можем да проверяваме и дали съществува ключ.",
    "p15p": "В Java тази структура е позната като HashMap (Map отново е зает), а в C# е Dictionary.",
    "p16ds1": "Java",
    "p1p": "В този урок ще се запознаем с концепцията за Data structures (структури от данни).",
    "p22p": "Това е последния урок, в който ще пишеш код. Има нещо, което искам да ти кажа. В някакъв момент ще ти се наложи да превръщаш низ в някой от другите типове. За тази цел съществуват така наречените \"Utility типови класове\" (\"полезни типови класове\"). Те представят примитивните типове като int и boolean/bool като класове. В Java са съответно Integer, Short, Long, Float, Double, Character, Boolean. В C# са Int32, Int16, Int64, Double, Char, Boolean. Те имат някои статични константи - максимални и минимални стойности и други подобни. По-важното за тях е, че в Java имат методи .parse<тип> (.parseInt(), .parseDouble()), а в C# - .parse(). Препоръчвам да ги разгледаш добре. Character и Char имат някои особено добри общи методи.",
    "p23p": "Уау, какво приключение. 38 урока по-късно и вече ти показах повечето неща, които се срещат в повечето езици. Има още много за учене, но оттук нататък ти поемаш щафетата. За остатъка от уроците ще ти покажа едни от най-използваните инструменти от професионалните разработчици и ще ти помогна да си избереш и да се насочиш към някоя сфера на компютърните науки.",
    "p2p": "Както подсказва името, структурите от данни са структури, които съдържат информация. Засега сме разгледали поне три - хийп, стак, масиви. Има много други - Queue (\"кю\" - опашка), двоични дървета, списъци, свързани списъци (\"Linked lists\"), двоични дървета.",
    "p3p": "В този урок ще разгледаме 2 - списъци (List) и речници (Dictionary).",
    "p4p": "Списъците са структура, подобна на масивите. Имат едно уникално свойство - при тях големината може да се променя. Когато създадеш масив с големина 5, този масив ще има големина 5 елемента до изчезването си от паметта. Но към списък, създаден с големина 5, могат да се добавят допълнителни елементи.",
    "p5p": "Списъкът в Java и C# е част от стандартната библиотека. Използва Generics, за да вземе аргумент тип за типа на елементите. Обикновено в конструктора създава масив с определена големина - да кажем 5. След това има метод за добавяне - той проверява последното свободно място в масива и поставя елемент там. Ако няма свободно място, създава нов, по-голям масив, в който копира елементите от стария и добавя новия елемент. Има също метод за вмъкване, който приема елемент и индекс. След това замества елемента на този индекс с подадения. Има метод, който връща колко елемента има в масива в момента. Обикновено има и метод за изчистване на масива, който го изпразва.",
    "p6p": "В Java списъкът е познат с класа ArrayList (тъй като List е интерфейс, от който наследяват всички вариации), а в C# е просто List.",
    "p7ds1": "Java",
    "s10ds2": "C#",
    "s11p": "Импортирай System.Collections.Generic",
    "s12p": "Сега опитай да създадеш нов List от низове. Пробвай следните неща - добави 5 нови елемента (.Add()), вмъкни елемент на индекс 5 (.Insert()), вземи големината на List-а (.Count), провери дали елемент съществува в List-а (.Contains()), премахни елемент на индекс 3 (.RemoveAt()), вземи елемента на индекс 4 ([]), изчисти List-а (.Clear()).",
    "s17p": "Импортирай java.util.HashMap",
    "s18rq": "Създай нова карта. Добави първата двойка по свой избор (.add()), провери дали има даден ключ в картата (.containsKey()) или дадена стойност (.containsValue()). Добави още една двойка и премахни първата (.remove()). Вземи големината на картата чрез .size(). Вземи стойност чрез .get() и ключа. Накрая изчисти картата чрез .clear().",
    "s19ds2": "C#",
    "s20p": "Импортирай System.Collections.Generic",
    "s21rq": "Създай нов речник. Добави първата двойка по свой избор (.Add()), провери дали има даден ключ в речника (.ContainsKey()) или дадена стойност (.ContainsValue()). Добави още една двойка и премахни първата (.Remove()). Вземи големината на речника чрез .Count. Вземи стойност чрез [] и ключа. Накрая изчисти речника чрез .Clear().",
    "s8p": "Импортирай java.util.ArrayList",
    "s9p": "Сега опитай да създадеш нов ArrayList от низове. Пробвай следните неща - добави 5 нови елемента (.add()/.addAll() - добави/добавиВсички), вмъкни елемент на индекс 5 (.set()), вземи големината на ArrayList-а (.size()), провери дали елемент съществува в ArrayList-а (.contains()/.containsAll()), премахни елемент на индекс 3 (.remove()), вземи елемента на индекс 4 (.get()), изчисти ArrayList-а (.clear()).",
    "text": "Където ще научиш как да направиш живота си по-лесен... или поне кода си",
    "title": "Урок 38"
  },
  "l39": {
    "p10p": "Върни се в конзолата и напиши следното, където * значи \"който и да е файл\" и може да бъде заменено с точно име:",
    "p11con": "git add *",
    "p12p": "Това добавя всички променени файлове в папката към файловете готови за запазване.",
    "p13p": "След като файловете са добавени, можеш да извършиш commit (\"комит\" - идва от \"да извърша\"), което ги добавя към историята на репозиторията, където * значи \"който и да е файл\" и може да бъде заменено с точно име:",
    "p14con": "git commit * -m \"съобщение по твой избор; да се отнася към промените; първият commit обикновено се нарича Initial commit\"",
    "p15p": "Това добавя сегашната версия на файловете към историята заедно със съобщението.",
    "p16p": "Сега промени съдържанието на .txt файла.",
    "p17p": "Отново добави файловете и извърши commit.",
    "p18p": "Вече имаш два commit-а в историята на репозиторията на git.",
    "p19p": "Можеш да видиш всички commit-и в дадена репозитория чрез командата:",
    "p1p": "Git е инструмент за контрол на версиите - всъщност е и най-широко използвания.",
    "p20con": "git log",
    "p21p": "Това ти показва всеки commit, с неговия commit идентификатор (гореразположения низ), името на създалия го, датата и съобщението.",
    "p22p": "Използвайки идентификатора, можем да се върнем на по-стар commit:",
    "p23con": "git revert --no-commit <идентификатор>HEAD\ngit commit",
    "p24p": "Изпълни тази команда, използвайки идентификатора на първия commit. Технически, git създава нов commit със съдържанието на първия. Представи си, че във файла имаш работещ код. Промени съдържанието на файла отново. Сега си представи, че вече кодът не работи (доста честа ситуация). Ctrl + z също не работи. Трябва да се върнеш на състоянието на последния commit на файла, тоест в състоянието веднага след като се върнахме на първия commit. Това се извършва като направиш reset (\"рестарт\") до HEAD (\"глава\") - последния commit:",
    "p25con": "git reset --hard HEAD",
    "p26p": "Друго нещо, което git може да прави е да създава клони (branches). Досега работихме в главния клон на git - master или main. Когато създадем нов клон на git, той получава перфектно копие на клона, от който го създаваме. След това можем да правим промени в новия клон, без да се появяват в който и да е друг клон. Когато сме готови, можем да обединим два клона (merge). Когато два клона се обединят, промените от единия се добавят в другия. Проблемът е, че е възможна е следната ситуация:",
    "p27p": "В главния клон има файл със съдържание \"Версия 1\".",
    "p28p": "От главния се създава нов клон.",
    "p29p": "В новия клон, съдържанието на файла се променя на \"Версия 2.1\".",
    "p2p": "Git ти позволява да запазиш файл в дадено състояние във времето, след това да го променяш, запазваш, или дори изтриваш и накрая да го възстановиш от тази запазена версия. Това се случва чрез програма от конзолата (която има и графичен интерфейс). Нарича се инструмент за контрол на версиите, защото позволява на програмистите да запазват версии на програма и да възстановяват по-стари такива. Освен това позволява цялата история и целия код да се запазват на далечен сървър, така че всеки програмист да има достъп до целия код от всяка точка на света.",
    "p30p": "През това време, друг разработчик променя съдържанието на файла в главния клон на \"Версия 3\".",
    "p31p": "Някой опитва да обедини втория клон в главния, но в единия клон имаме \"Версия 3\", а в другия - \"Версия 2.1\". git не знае коя версия е \"по-правилна\" и се получава merge conflict (конфликт в обединението). Потърси как се разрешават конфликтите в обединението.",
    "p32p": "Клоните имат много широко разпространение. Mного често има два клона - един за разработка (обикновено се казва dev), и един главен. Главният е официалната версия на програмата, докато в другия се правят промени. Приета практика е и за всяка нова функция или проблем да се отваря нов клон, на който да бъде добавена функцията или да бъде разрешен проблема и новият клон да се обедини с dev.",
    "p33p": "Така се създава клон:",
    "p34con": "git checkout -b <име на клон>",
    "p35p": "Това създава нов клон и те праща в него.",
    "p36p": "Промени съдържанието на файла отново и извърши commit.",
    "p37con": "git add *\ngit commit * -m \"Съобщение\"",
    "p38p": "Използвай следната команда, за да се върнеш на главния клон:",
    "p39con": "git checkout master",
    "p3p": "За целта на този урок, инсталирай git от официалния сайт - https://git-scm.com/download Хубаво ще е и да си направиш профил в една от главните платформи - GitHub, GitLab или BitBucket (лично предпочитам GitHub).",
    "p40p": "Провери дали промените от втория клон ги има и в master. Няма ги, нали? Сега да обединим новосъздадения клон с master.",
    "p41e": "Винаги, когато обединяваш 2 клона, се убеди, че се намираш в този, който искаш да получи промените.",
    "p42p": "Извърши следната команда:",
    "p43con": "git merge <име на клон>",
    "p44p": "Също има команди git push и git pull. Тези команди ти позволяват да изпращаш и теглиш код от далечна репозитория, до която имаш достъп.",
    "p45p": "Изполвай своя GitHub, GitLab или Bitbucket профил. Създай новa репозитория там и използвай инструкциите, за да публикуваш своя код.",
    "p46p": "Оставам на теб да разбереш как действат git pull и git push. Задачата ти е да качиш репозиторията си в GitHub/GitLab/BitBucket чрез команди в git, да я изтриеш от локалния си компютър и да я възстановиш от GitHub/GitLab/BitBucket чрез команди.",
    "p47p": "Нормално, програмите се разпространяват в компилиран вариант, тоест програмата до голяма степен не може да се редактира и да се види оригиналния код е почти невъзможно.",
    "p48p": "От друга страна, има и open source програми (\"програми с отворен код\"). Техният код е публично достъпен в публични репозитории, независимо дали на някоя от горните платформи или на специално направена. Всеки има достъп до кода и може да го прочете. Всеки може да изтегли кода, да направи промени върху него и да ги предложи, след което maintainer (наблюдател) може да ги одобри и обедини в главния проект. Може някой дори да направи собствена версия на проекта, наричана fork (\"вилица\").",
    "p49p": "Така действат много от безплатните програми - операционните системи Linux и Android (която е fork на Linux), Blender, Gimp, Audacity и много други.",
    "p4p": "След инсталацията, отвори новоинсталирания Git Bash (създаден да подражава на Linux терминала bash). Има нормалните команди като cd и touch (за създаване на файлове). Чрез cd навигирай до някоя празна папка, в която да експериментираш.",
    "p50p": "Съответно, този отворен код се защитава с определени лицензи. Някои от тях са по-затворени - те декларират, че всяко нещо в което се използва код лицензиран с тях, също трябва да е с отворен код или да позволява на потребителя да редактира лицензирания код. Такива лицензи са GNU GPL и други. Те лицензират повечето програми, за да не може някой да открадне кода и да започне да го продава като програма със затворен код. Те гарантират, че отворения код ще си остане такъв.",
    "p51p": "Други са по-отворени - тези лицензи накратко казват, че всеки може да прави каквото си иска с кода лицензиран с тях, без да включва лиценза или да споменава по каъвто и да е начин как и откъде е взел кода. Такива лицензи са MIT и Apache. Ако някога използваш публична програмна библиотека, най-вероятно тя ще е лицензирана по този начин. За всеки случай, винаги проверявай лицензa на публичен код, който използваш.",
    "p52p": "Предстои ти да се срещнеш с git и отворения код още много пъти, така че дори да не си разбрал нещо в този урок, ще имаш време.",
    "p5p": "Основата на git е repository (\"репозитория\"). Репозиторията съдържа цялата история на файловете в нея.",
    "p6p": "Създава се чрез:",
    "p7con": "git init",
    "p8p": "Това създава нова репозитория в папката. Ще го забележиш по скритата .git папка. Ако не я виждаш във file explorer, напиши tree командата и трябва поне да я видиш в конзолата.",
    "p9p": "След това създай .txt файл. Напиши нещо в него.",
    "text": "Където ще научиш как да пътуваш назад във времето",
    "title": "Урок 39"
  },
  "l4": {
    "p10p": "Първо, да отбележим, че кореновата папка се записва с \":\" преди разделителя. Тоест имаме \"C:\".",
    "p11p": "Това е Windows, тоест разделителят е \"\\\". С разделител \"/\" бихме имали същия ефект:",
    "p12pre": "C:/Users/Gosho/Documents/nominacii.docx",
    "p13p": "Този случай е по-практичен за целите на програмирането. Символът \"\\n\" в \"\\nominacii.docx\" би бил интерпретиран като нов ред от повечето езици, което ще доведе до грешки. За остатъка на този \"курс\", ще използвам главно \"/\" поради тази причина.",
    "p14p": "Освен това можем да поставим и разделител след края на пътя, но не е препоръчително:",
    "p15pre": "C:/Users/Gosho/Documents/nominacii.docx/",
    "p16a1": "Грозно е",
    "p16a2": "Не работи в Windows",
    "p16a3": "Защото може да се интерпретира като различни контролни символи",
    "p16tq": "Защо не е препоръчително да използваме \"\\\" за разделител в програмирането?",
    "p17p": "Да си представим обаче, че нашият потребител иска да започне от папка на име \"Проекти\" (\"Proekti\"), която се намира в \"Документи\" и да стигне до \"nominacii.docx\". За това ще използваме относителен път.",
    "p18p": "Нека да видим абсолютния път на папката \"Proekti\":",
    "p19pre": "C:/Users/Gosho/Documents/Proekti",
    "p1p": "Информацията в компютър се разделя на файлове - парчета информация. Всеки файл си има име и големина - обикновено измервана в байтове (1 байт = 8 бита). Файловете се групират в папки, като във всяка папка може да има файлове и други папки. Така се оформя модел на организация, подобен на дърво - всяка папка е нов клон, в който има файлове и от който започват още клони - папки.",
    "p20p": "След това, абсолютния път на файла nominacii.docx:",
    "p21pre": "C:/Users/Gosho/Documents/nominacii.docx",
    "p22p": "Забелязваме, че и двете са в папка \"Documents\". Само че едното е папка, а другото - файл.",
    "p23p": "В относителните пътища имаме активна (или работна) папка. От нея започва пътят. Има няколко специални символи за навигация. \"./\" означава работната папка. Тоест, ако работна папка е  \"Proekti\", и в нея има файл \"proekt1.txt\", можем да достигнем този файл чрез пътя:",
    "p24pre": "./proekt1.txt",
    "p25p": "Тоест, \"./\" просто значи \"папката, в която съм\".",
    "p26p": "Но ако искаме да достигнем елемент в предна папка от работната, използваме \"../\". Това значи \"предната папка от работната\". Спрямо \"Proekti\", това е папката \"Documents\". Така, ако искаме да достигнем \"nominacii.docx\" от Proekti използваме пътя:",
    "p27pre": "../nominacii.docx",
    "p28p": "Така можем да се връщаме и повече папки назад. Например, ако в \"Gosho\" има файл с име \"hello.txt\", можем от работна папка \"Proekti\" да го достигнем така:",
    "p29pre": "../../hello.txt",
    "p2a1": "Само папки",
    "p2a2": "Само файлове",
    "p2a3": "Хард дискове",
    "p2a4": "Папки и файлове",
    "p2tq": "Във всяка папка може да има:",
    "p30p": "Както си забелязал/а, не съм писал име на папка или потребител с кирилица. Това е така, защото някои системи поддържат единствено ASCII и кирилицата създава проблеми с тях.",
    "p31a1": "работната папка",
    "p31a2": "предната папка",
    "p31a3": "следващата папка",
    "p31a4": "файл",
    "p31tq": "В относителен път \"./\" е:",
    "p32p": "Заглавието на този урок казва, че разширенията са лъжа, но не сме говорили за това. Като става на въпрос, от началото на урока не съм написал думата \"разширение\" и веднъж. Разширенията на файл са последната част от него, отделена с \".\" от остатъка. Всички разширения досега са написани като част от имената на файловете:",
    "p33p": "nominacii.docx - \".docx\" е разширението",
    "p34p": "project1.txt, hello.txt - \".txt\" е разширението",
    "p35p": "Но истината е, че разширенията са лъжа. Предложение, ако трябва да сме точни.",
    "p36p": "Първо, всеки файл е просто текст или двоичен формат (нули и единици, без текстово значение). Нищо друго. А разширенията са част от името.",
    "p37p": "Разширенията са само предложение. Когато операционната система види \".docx\" файл, знае да го отвори с Word. Когато види \".mp3\" файл, знае че е музика. Но това не ни пречи да го отворим с друго приложение. Можем да натиснем файла с десен бутон на мишката, да натиснем \"Отвори с\", да натиснем \"Още приложения\", да намерим Notepad и да отворим файла с него и виждаме само текст. Може файлът да е двоичен , тоест когато го отворим, виждаме странни символи - няма кодиране, което да може да бъде прочетено.",
    "p38p": "Файлът може дори и да няма разширение. Популярната платформа Heroku използва файла \"Procfile\" - чете го и го отваря като текстово, но той няма разширение.",
    "p39p": "Един от най-честите проблеми на програмистите е да запазват информация, заедно с това за какво е предназначена тя. Например, искаш да запазиш езика на приложение и после да го прочетеш от файл. Можеш просто да направиш файл \"ezik.txt\" и да го запишеш там. Но е непрактично. После можеш да имаш настройка като режим - тъмен или светъл. И за нея ли ще създадеш файл? За това съществуват ключ-стойност форматите. Да ги разгледаме:",
    "p3p": "В повечето операционни системи (Windows, Linux, MacOS), главната папка се нарича \"C\" (\"це\"), често наричана и корен (\"root\"), защото се явява корен на файловото дърво. Пътят (\"path\") на файл или папка е последователността папки, през които потребител трябва да премине, за да стигне до файла или папката. Пътищата са 2 вида: абсолютни и относителни. Абсолютният път винаги започва от главната папка и завършва на файл или папка. Относителният път може да започва от която и да е папка. Тоест, той се отнася към други папки и файлове.",
    "p40h": "XML",
    "p41p": "XML е един от най-старите формати. Той е на основата на тагове. Един таг може да е отваряш или затварящ. Отварящ таг изглежда така:",
    "p42pre": "<име на тага>",
    "p43p": "Затварящ таг изглежда така:",
    "p44pre": "</ име на тага>",
    "p45p": "Може да има и таг, който е самостоятелен - тоест <самостоятелен />. Такива тагове се изполват за информация като нов ред. Таговете позволяват запазване на информация. Например (ще използвам английското съкращение \"lang\" за език и английската дума \"mode\" за режим - прието е да не се пишат тагове на друго освен латиница):",
    "p46pre": "\n<lang> Български </lang>\n<mode> Светъл </mode>",
    "p47p": "Друго уникално свойство на xml е, че между таговете може да има и други тагове (\"settings\" - настройки):",
    "p48pre": "\n<settings>\n\t<lang> Български </lang>\n\t<mode> Светъл </mode>\n</settings>",
    "p49p": "Забележи как с всяко следващо ниво на тагове слагаме повече място вляво.",
    "p4a1": "От корена на файловото дърво",
    "p4a2": "От която и да е папка",
    "p4a3": "От който и да е файл",
    "p4a4": "От файла, до който е",
    "p4tq": "Откъде започва абсолютен път?",
    "p50p": "Използвайки този формат, програмистът може после да поиска стойността на lang в settings и да получи \"Български\".",
    "p51p": "XML се използва широко - \".docx\" са архиви, но когато се разархивират са главно .xml файлове. Също и целият Интернет зависи от xml - неговия подезик html е основната структура на всеки сайт. Mоже да носи и информация в таговете - така се добавя картина в уебсайт:",
    "p52pre": "<img src=\"път към картина\"></img>",
    "p53p": "Тук \"src\" дава пътя към картината (относителен). След това браузърът иска стойността на \"src\" в \"img\" и получава пътят, от който да зареди картината.",
    "p54fq": "Напиши отварящ и затварящ таг \"version\", между които е записано 17.2",
    "p55h": "JSON",
    "p56p": "XML обаче не е удобен за пренос на голямо количество информация. Всяко име на таг се пише по два пъти (за отварящ и затварящ), което е много байтове информация. Затова се използва JSON (нотация на обекти на Javascript). Първо, този формат се чете много лесно от Javascript, динамичния език на всеки уебсайт, както подсказва и името. Да си представим, че ти си правиш профил в някоя мрежа. Слагаш си име, e-mail, възраст и парола. След това натискаш \"регистрация\". Към сървъра тръгва съобщение, което изглежда така:",
    "p57pre": "\n{\n\t\"ime\": \"Gosho\",\n\t\"email\": \"gosho@email.email\",\n\t\"parola\": \"dobraparola\",\n\t\"vuzrast\": 18\n}",
    "p58p": "Toва е JSON. Започва с \"{\" и завършва с \"}\". Отляво винаги има ключ - например \"ime\". След това има \":\", което значи край на ключа. Всеки ключ е обграден в кавички. След \":\" е стойността. Тя може да е няколко вида. Първият е текст, ограден с кавички. Може да е просто число като 18. Може и да е списък:",
    "p59pre": "\n{\n\t\"spisuk\": [\"яйца\", \"хляб\", \"масло\"]\n}",
    "p5p": "Когато пътищата се записват, между всяка папка или файл се записва разделител. В Linux и MacOS, това обикновено е \"/\". В Windows, разделителят е \"\\\". Това обаче не е практично в програмирането, заради множеството запазени символи с \"\\\". Например, в повечето файлове \"\\n\" означава нов ред и не се показва на потребителя, а \"\\t\" означава таб.",
    "p60p": "Или дори още един обект JSON:",
    "p61pre": "\n{\t\"ime\": \"Gosho\",\n\t\"email\": \"gosho@email.email\",\n\t\"parola\": \"dobraparola\",\n\t\"vuzrast\": 18,\n\t\"dopulnitelno\": {\n\t\t\"spisuk\": [\"яйца\", \"хляб\", \"масло\"]\n\t}\n}",
    "p62p": "След края на стойност има запетая, следващ ключ и така нататък.",
    "p63p": "JSON е най-честия формат за пренасяне на информация в Интернет.",
    "p63w": "След последната стойност няма запетая.",
    "p64a1": "списък",
    "p64a2": "текст",
    "p64a3": "число",
    "p64a4": "файл",
    "p64tq": "Стойността на ключ в JSON не може да е:",
    "p65rq": "Намери информация за файловите формати TOML и YAML",
    "p6a1": "Нов ред",
    "p6a2": "Празно пространство",
    "p6a3": "Таб",
    "p6a4": "Главна буква",
    "p6tq": "Какво означава символът \"\\n\"?",
    "p7p": "Нека да разгледаме пример. Ние сме в Windows. Влезли сме в потребител на име \"Gosho\". Този потребител има файл на име \"nominacii.docx\" в папката си \"Документи\" (\"Documents\"). Тази папка се намира в папката му потребители (\"Users\"), която е в кореновата му папка (\"C\").",
    "p8p": "Така би изглеждал абсолютния път до този файл:",
    "p9pre": "C:\\Users\\Gosho\\Documents\\nominacii.docx",
    "text": "Където ще научиш, че разширенията са лъжа",
    "title": "Урок 4"
  },
  "l40": {
    "p10h": "Обобщавай",
    "p11p": "Ако използваш някоя библиотека и имаш проблем, обикновено търсиш тази специфична грешка от библиотеката. Освен ако въпросната библиотека не е известна, има много нисък шанс да намериш нещо. Търси по-общо. Вместо да търсиш тази грешка в библиотеката, потърси какво може да я причинява. Може да се окаже, че тази страшна грешка е резултат на това, че си написал 0 като стойност, което не се е харесало на някоя функция от библиотеката.",
    "p12h": "Различни източници за различни неща",
    "p13p": "За различните неща трябва да търсиш различни източници.",
    "p14p": "Като цяло, текст е по-добре от видео. В началото обаче много често видеото е по-разбираемо.",
    "p15p": "Например, ако искаш да научиш някой програмен език, насочи се към документацията или към някое видео. Ако ти се чете, можеш да се за хванеш с някоя книга, но внимавай да не е твърде остаряла - езиците еволюират постоянно.",
    "p16p": "Ако искаш да си припомниш нещо за език, препоръчвам текстови формати - първо търсиш официалната документация. Ако тя не е достатъчна, премини на другите сайтове, които са най-горе в резултатите. Мога да препоръчам и сайта https://learnxinyminutes.com/ (с който не съм обвързан), ако искаш да си припомниш синтакса или някои основни неща.",
    "p17p": "Ако имаш проблем, най-добрият ти залог е сайта StackOverflow - обикновено е най-горния резултат. Само внимавай, когато взимаш код и чети решения от отговорите, не от текста на въпроса. Погледни всички въпроси, които отговарят на търсенето ти.",
    "p18p": "Ако там няма отговор, пробвай и в другите форуми в резултатите като Reddit. Въпреки че рядко, понякога там има отговори на крайно специфични проблеми.",
    "p19p": "Само ако не намериш нищо, може да създадеш въпрос на някое от тези места и да се надяваш на отговор.",
    "p1p": "Търсенето е основна част от програмирането. Има толкова много библиотеки, езици, рамки (framework-ове) и т.н., че един човек не може да знае всички и не за всички има книги и каквито и да е други ресурси. Единственият човек, който може да те обучи, си ти.",
    "p20p": "Ако имаш проблем с някоя библиотека, най-добре е да намериш публичната ѝ репозитория и да разгледаш отбелязаните там проблеми - има много висок шанс да намериш и своя.",
    "p21h": "Внимавай за лоши резултати",
    "p22p": "Понякога има лоши резултати в Интернет. Червени флагове са лошо форматиране, лоши имена на методи и променливи или грешки при използването на начините за кръщаване (например, именанаписанитака, вместо имена, написани в препоръчания формат на езика). Внимавай също за много остарели сайтове или резултати.",
    "p23p": "Никога не copy-paste-вай без да разбираш какво и не прави copy-paste на повече от няколко реда. Ако се налага, конвертирай имена и скоби, за да се сливат с останалия код. На всички се случва да им трябва някое много сложно изчисление за цветове или нещо подобно, което не могат да напишат сами. Това не значи, че трябва да \"изтряскаш\" 30 реда код от неизвесто място с неизвестно качество, който не разбираш. Току-виж успееш да добавиш някоя дупка в сигурността.",
    "p24p": "Също не обръщай внимание на сайтове, които просто крадат отговори от известните форуми чрез ботове и ги поставят в техен си сайт. Забелязват се лесно, но могат да те подведат в началото.",
    "p2p": "Освен това от програмистите не се очаква да знаят всичко. Бих казал, че мога да програмирам в няколко различни езика, но ми се случва да търся и най-простите неща, например точния синтакс за създаване на enum или switch.",
    "p3p": "В този урок ще ти дам някои съвети за търсенето, които съм установил през времето.",
    "p4h": "Винаги търси на английски",
    "p5p": "Ако се налага, използвай онлайн преводач. Няма значение. На български или на повечето други езици, резултатите ти са крайно лимитирани. Английски е езикът на програмирането.",
    "p6h": "Не се обяснявай много",
    "p7p": "Повечето търсещи машини разчитат на ключови думи. Не пиши дълги сложни въпроси. Например:",
    "p8p": "\"how to find square root in java\" (\"как да намериш квадратен корен в Java\") изглежда като добро търсене, само че от него няма смисъл. Дълго е и е възможно да покаже някои объркващи резултати, защото търсещата машина ще има много ключови думи. По-бързо за теб е да се напише следното:",
    "p9p": "\"square root java\" (\"квадратен корен java\") е крайно опростено. Съдържа само три важни думи и нищо повече. Това е от какво се интересуваш - квадратен корен в Java. Ненужните частици и други части на речта са премахнати, за да не трябва да ги пишеш или да натоварват търсещата машина. Резултатите са по-точни и директни.",
    "text": "Където ще научиш как да използваш Интернет",
    "title": "Урок 40"
  },
  "l41": {
    "p10p": "Тази позиция обхваща горните две плюс добри знания за датабази. Доста често има изисквания за подобна позиция, като обикновено изглежда сякаш работодателя си търси цял програмистки отдел, съдено по дължината на списъка с изискваните технологии. Много често се искат даже знания в сървърната архитектура - Docker, Kubernetes, известните платформи. Хората отговарящи на всички тези изисквания обикновено не са експерти в нито едно от тях. Цялостните им знания обаче могат да се докажат като много полезни в някои случаи.",
    "p11h": "Database administrator - датабазов администратор",
    "p12p": "Тези хора се занимават със създаването и администрацията на датабази. Те са запознати с различните видове датабази, като относителни (relational), документни (document store) и други. Обикновено знаят много добре езика SQL. Занимават с проектирането на датабази, отговарящи на всички познати принципи, така че да могат да побират максимални количества информация с максимална производителност. Осигуряват 100% наличност и бързина на датабазите.",
    "p13h": "Server architect - сървърен архитект",
    "p14p": "Тези хора се занимават със сървъри и Интернета като цяло. Те са запознати с протоколи за комуникация и основните Интернет понятия, като DNS система (Domain Name System - система за имена на домейни). Очаква се да са отлично запознати с операционните системи, използвани в сървъри, като Linux и Windows Server и да познават сървърен софтуер като Nginx. В днешно време почти винаги се изисква и знание за работа с обалчни платформи като AWS (Amazon Web Services), Microsoft Azure и Google Cloud. Тези хора се занимават и с проблеми отнасящи се до разпространението на сървъри и кеширането на информация. Осведомени са в основни мерки за сървърна сигурност и защита от различни атаки. Трябва да постигнат 100% наличие на сървърите с максимална произведолност. Това е една много широка, но и много интересна сфера от компютърния свят.",
    "p15h": "Мобилно програмиране",
    "p16p": "Тези хора се занимават със създаването на приложения за мобилни устройства, обикновено Android или iOS. Те използват невероятно широката екосистема от библиотеки и инструменти. Ако си ползвал приложение на телефон, един от тези хора го е създал. Специфична характеристика е специализацията - обикновено разработчик се занимава главно с технологиите на Android (Java, Kotlin, Android Apis) или с тези на iOS (Objective-C (остарял), Swift, iOS Api-s). С появата на библиотеки и framework-ове като Flutter и React Native, някои от тези разработчици могат да пишат код, който да върви и на двете споменати платформи. Препоръчвам на всеки поне веднъж да се опита да създаде мобилно приложение.",
    "p17h": "Десктоп програмиране",
    "p18p": "Тези хора се занимават със създаването на приложения за десктоп устройства като настолни компютри и лаптопи. Тези устройства обикновено използват операционните системи Windows, MacOS и Linux. Използвани езици са Java, C#, C++. Създаването на подобни приложения винаги е било трудно и сложно. В последните години, технологии като Electron превзеха пазара. Те позволяват уебсайт да се инсталира с браузъров двигател и да се пуска като десктоп приложение. Въпреки че са малко по-тежки за компютъра от нормалните приложения, те са крайно по-лесни за създаване и по-универсални. Всъщност, първоначалната ми идея беше този сайт да се разпространява като такова приложение.",
    "p19h": "Game development - разработка на игри",
    "p1p": "Докъде стигнахме! Вече си почти на края на този \"курс\". Това е урока, в който ще ти обясня различните сфери на програмирането и езиците и технологии, използвани в тях.",
    "p20p": "Това е една от най-често исканите, но и най-сложни сфери на програмирането. Игрите са трудни за създаване, изисквайки невероятни количества математика (и понякога физика), труд и време. Въпреки това, хората, които правят това много често намират удоволствие в него. Приготви се да използваш game engine (игрови двигател) като Unity или Unreal Engine и езици като C# (Unity), C++ (Unreal Engine) и C. Единственият ми съвет е да не започваш с твърде голяма игра. Може да имаш огромна идея, но започни с нещо по-малко, защото разработката отнема много време. Тази сфера има и друга страна в модификацията на игри. Тя е главно хоби и няма голям паричен потенциал, но все пак може да е забавна. За нея може да ти трябват езици като Java, Lua, C++ и други.",
    "p21h": "Системно програмиране",
    "p22p": "Това е най-важната сфера за компютрите. От нея произлизат операционните системи и почти целия софтуер на всяко друго компютърно устройство. Независимо дали стартираш компютъра си, колата си или тостера си, най-вероятно това се случва заради продуктите на тази сфера. Приготви се за свят на Assembly, C, C++, може би Rust в бъдеще, сериозни оптимизации и нечовешки ограничения в процесорната сила и паметта. Въпреки това, все пак на някои хора им харесва. Можеш да започнеш с някои от платките Arduino (не съм обвързан с тях), които ти дават C++ с лесна за ползване библиотека.",
    "p23h": "Data Science и Machine learning - Информационни науки и машинно обучение",
    "p24p": "Както имената подсказват, тези дисциплини са повече математически отколкото програмни. Отново големи количества математика. Те се занимават с информацията и нейните приложения, както и възможностите в обучаване на компютри. В програмната им част, най-вероятно ще използваш C библиотеки с интерфейси в Python или R. Колкото повече се изкачваш по нивата им, толкова по-висок е шанса да ти се наложи да пишеш сам код в C, представяйки собствени алгоритми. Обещават труден, но интересен път.",
    "p25p": "Като цяло, независимо какво правиш, ето някои съвети:",
    "p26p": "Никога не създавай сам система за автентикация и профили, освен ако нямаш нужните знания (най-вероятно ги нямаш) или не го правиш за учебни цели.",
    "p27p": "Никога не запазвай пароли без да ги хашираш. При криптирането се получава низ, който може да бъде декриптиран. Но, хашираш ли парола, тя вече никога не може да бъде върната в първоначално състояние от хаша. Единствения начин за проверка дали потребител е въвел правилна парола след това е като се сравни хаш на въведената с хаша на паролата. Не забравяй да провериш алгоритъма за хаширане - не използвай твърде стари или вече пробити алгоритми. И използвай сол, така че да се защитиш от атаки с таблици (когато някой вземе речник и калкулира хаша на всяка парола). Солта се прибавя към началото на паролата преди хаширане и е винаги случайна (например $hau53). След това солта се записва пред хаша. Така атакуващ трябва да генерира всяка дума от речника с дадената сол за всяка парола, правейки разбиването почти невъзможно или непрактично. Да не забравяме, че много малко хора имат думи за пароли.",
    "p28p": "Никога не се доверявай на потребителя и винаги приемай, че има лоши намерения. На сървъра е единственият код, на който можеш да разчиташ, защото върви на контролирани от теб компютри. Потребителят в игра може да ти каже, че е пропътувал 6км за 1 секунда или е уцелил някой през стена, но сървърът не трябва да се довери. Сървърът винаги трябва да ограничава всичко в реални граници, за да не се окаже, че някой го е \"гръмнал\" като е качил 2TB файл. И ако някой ти каже, че всъщност възрастта му е \"12 метрова мечка с розови крила\", също не трябва да му се доверяваш. По-добре да си параноичен, отколкото да съжаляваш. А дори и най-добрe защитената програма може да бъде модифицирана от достатъчно упорит човек. Всеки код, който върви на компютъра на потребителя е несигурен, независимо дали Javascript в браузъра или машинен код. Единствената защита е през сървъра.",
    "p29p": "Сигурност през тайнственост не е сигурност.",
    "p2h": "Frontend - преден край",
    "p30p": "Важно е да разбереш това - обикновено ще работиш върху код, до който потребителите нямат достъп. Код, който не могат да прочетат. Въпреки това, ако единствено знанието за кода е достатъчно за някой да премине през сигурността, то сигурност никога не е имало. Приеми, че всеки ред код, който напишеш, може да бъде прочетен от някой в бъдещето. Единствената истинска сигурност идва от сигурен код. Не от това, че някой не знае, че кодът е несигурен.",
    "p31p": "Не се занимавай да създаваш собствена библиотека за време или локализация (локализация е превеждането на програма на множество езици). Времето е една от много сложните теми, държавите постоянно преминават от една в друга времева зона и всичко се променя. Просто запазвай времето в Unix време (секунди или милисекунди от Unix epoch, където 0 е 1 януари 1970 - затова когато нещо не показва време правилно, това е първата дата, която избира) и се довери на широко използвана библиотека. Локализацията е много труден процес - например, в някои езици имаш \"1 маса\" и \"2 маса\". В други имаш \"1 маса\" и \"2 маси\". А има случаи, където има специална дума за 2 неща и друга за повече от две неща. Има езици, които се пишат отдясно наляво. Просто не се занимавай с всичкo това и се довери на някой друг. Задача на преводачите е само да напишат преводите - не да ти звънят на всеки 15 минути за нещо специално в езика им, което трябва да добавиш. Освен това, ако имаш намерение да превеждаш приложение, разгледай нужните библиотеки за локализиране преди да започнеш да пишеш кода, защото обикновено са трудни за добавяне по-късно в разработката.",
    "p32p": "Не копирай код от Интернет без да се замислиш. Огледай го за грешки и други подобни. Ако е повече от 1 ред, например функция, опитай да го препишеш. Даже и да е 1 ред, ако не го разбираш, го препиши. Програмистът не може да знае всичко, затова има Интернет, но не трябва да му се доверява на 100%.",
    "p33p": "Когато учиш нещо, винаги започвай с малко. Разбирам, че най-вероятно искаш да направиш новата голяма социална медия, или онлайн игра за милиони хора, или изкуствен интелект подобаващ на Терминатора, но най-вероятно няма да можеш от първия път. За да разбереш как се прави сайт с 300 страници, трябва да направиш един с 3.",
    "p34p": "Кодът се пише за други хора, не за компютъра. Така или иначе, той ще види само каша от нули и единици. Главната ти задача е да създадеш четлив код. След като си създал четлив код за човека, можеш да го оптимизираш за компютъра.",
    "p35p": "Идеята рограмирането се крие в обмислянето на всяка възможност и разрешаването на логически проблеми. Всеки път, когато правиш нещо, трябва да мислиш какво може да се случи заради него. Например, имаме игра със случайно генериран свят, в който има структури. Някой добавя опция да се генерира свят без структури. Години след това трябва да се добави предмет, който показва къде е най-близката структура. Той е добавен и актуализация е пусната, но изведнъж идват съобщения за странни крашове на играта. Оказва се, че този, който е добавял новия предмет, не се е замислил за възможността да няма структури в света, което е довело до проблеми. Подобни грешки се случват често и единствения начин да бъдат спрени е като се обмисли и покрие всяка възможност. Преди да разрешиш проблем ти трябва максимално много информация за него, но най-добре е да няма проблем.",
    "p36p": "Надявам се този урок да ти е и помогнал. Запомни - най-добрият начин да се ориентираш е да пробваш всичко.",
    "p3p": "Тези разработчици се занимават с това как изглежда и се държи сайт. Те му придават структура чрез HTML (XML вариант), изглед чрез CSS и динамичност чрез JS (JavaScript). Те се занимават с това, което се случва на браузъра на потребителя - няма да ги видиш да правят системи за автентикация или нещо друго. Те не се занимават със сървъри, но те са тези, благодарение на които има сайт, който да гледаш.",
    "p4p": "Използвани езици са HTML, CSS, JavaScript. Използвани технологии са SCSS, JQuery, React, Angular, Vue и т.н. Препоръчвам ти да направиш сайт с горните езици преди да се захванеш с технологиите.",
    "p5h": "Backend - заден край",
    "p6p": "Това са хората, които се занимават с това, което се случва на сървъра. Те пишат системите за влизане и излизане от профили, те се занимават със запазването на информация. При тях се случва всичко, за което не можеш да се довериш на потребителя. Ако си се насочил/a към това, няколко съвета:",
    "p7p": "Не откривай топлата вода - не създавай системи за автентикация на профили и други подобни. Винаги хаширай паролите с някой от добре тестваните алгоритми. Ако ти се наложи да пишеш SQL (езика на относителните датабази), никога не използвай конкатенация на низове, защото създаваш огромна дупка в сигурността.",
    "p8p": "В тази сфера на програмирането се използват и най-много технологии и езици. Някои от тях са Java (Spring), C# (.Net/.Net Core), Node.js, Go, Ruby (Ruby on Rails), PHP, Python и множество други. Хубавото е, че научиш ли една от тези технологии, знаеш всички други. Те работят по сходен начин, тоест трябва само да погледнеш специалните неща на новия език и framework.",
    "p9h": "Full Stack - пълен",
    "text": "Където ще научиш опциите си",
    "title": "Урок 41"
  },
  "l42": {
    "p1p": "Не мога да повярвам, че дойде и този момент. Това е последния урок.",
    "p2p": "Уроците не бяха малко, но ми беше забавно да пиша (почти) всеки един от тях.",
    "p3p": "През последните 42 теми предадох на теб цялото общо знание за програмирането, което мога да ти дам. Без уловки, по същия начин, по който аз го събрах. Надявам се и ти да можеш да свършиш нещо подобно.",
    "p4p": "Надявам се да си разбрал/a всичко или поне нещо. Надявам се от теб да излезе отличен програмист, дори да не се занимаваш с това в живота си. В крайна сметка, работи много добре и като хоби.",
    "p5p": "Аз мога да ти дам стартови знания, но аз не мога да ти обясня всичко. Това е твоя работа. Програмирането е една от тези сфери, които постоянно еволюират и новата технология винаги идва. Препоръчвам ти да не изоставаш, иначе ще ръждясаш :)",
    "p6p": "От момента, в който започна да четеш тези уроци, ти пое знанията си в собствените си ръце. Вярвам, че щом си стигнал дотук, можеш да постигнеш и повече. Пътешествието ти тепърва започва.",
    "p7p": "За един последен засега път,",
    "p8p": "Късмет!",
    "text": "Където ще те изпратя",
    "title": "Урок 42"
  },
  "l5": {
    "p10con": "<<prefix>>C:/Users/Потребител> cd ../",
    "p11p": "Ще получим:",
    "p12con": "<<prefix>>C:/Users>",
    "p13p": "Защото сме се върнали папка назад. За да се върнем в \"Потребител\" можем да напишем:",
    "p14con": "<<prefix>>C:/Users> cd Потребител",
    "p15p": "Което ще има резултат:",
    "p16con": "<<prefix>>C:/Users/Потребител>",
    "p17p": "Ако искаме да навигираме до папка, в чието име има празно място, заграждаме името в кавички:",
    "p18con": "<<prefix>>C:/Users/Потребител> cd \"Папка с празно място\"",
    "p19p": "Ако отново имаме абсолютния път \"C:/Users/Gosho/Documents/nominacii.docx\" и имаме конзола в \"C:/Users/\", можем директно да стигнем до \"Documents\" по следния начин:",
    "p1p": "В този урок ще се върнем към древните времена, когато е нямало графични интерфейси. Когато всеки, който е работил с компютър е навигирал само чрез текст в един тъмен прозорец, наречен \"конзола\"",
    "p20con": "<<prefix>>C:/Users/> cd Gosho/Documents/",
    "p21p": "Ще имаме резултат:",
    "p22con": "<<prefix>>C:/Users/Gosho/Documents/>",
    "p23a1": "Ще останем в сегашната",
    "p23a2": "Ще отидем в \"Gosho\"",
    "p23a3": "Ще отидем в \"Users\"",
    "p23a4": "Ще отидем в \"C:/\"",
    "p23tq": "При работна папка \"C:/Users/Gosho/Documents/\" и изпълнена команда \"cd ./\" ще отидем в папка:",
    "p24p": "От конзолата могат и да се пускат приложения. Ако имаш файл с име \"program.exe\" (поне на Windows) в работната си папка и напишеш в конзолата \"program.exe\", програмата ще стартира.",
    "p25con": "<<prefix>>C:/Users/Gosho/> program.exe",
    "p26p": "Много от програмите изскват и аргументи. Те се пишат във формат \"-ключ стойност\". Например: (\"light\" - светъл)",
    "p27con": "<<prefix>>C:/Users/Gosho/> program.exe -mode light",
    "p28a1": "-mode",
    "p28a2": "*mode",
    "p28a3": "mode",
    "p28a4": "/mode",
    "p28p": "Програмата ще получи тази информация. В уроците напред ще се научиш да четеш и пишеш в конзолата чрез програми и да взимаш и ползваш аргументи.",
    "p28tq": "Кое е валиден ключ за аргумент?",
    "p29rq": "Потърси как се създават, трият, копират и местят файлове в твоята конзола.",
    "p2p": "Конзолата е различна според операционната система. На Windows е CMD или PowerShell. На Linux обикновено е Bash. На MacOS е Terminal (\"терминал\"). Последните две са базирани на Unix конзолата, тоест имат подобни команди. CMD и PowerShell се различават малко. Тук ще покрия главно CMD и Unix конзолите.",
    "p3p": "Когато отвориш конзола, тя ще стартира с активна папка в потребителя ти. Ще видиш нещо подобно:",
    "p4con": "<<prefix>>C:/Users/Потребител>",
    "p5p": "След \">\" ще имаш поле за писане. Можеш да напишеш команда и да натиснеш \"Enter\" (\"нов ред\"), за да я изпълниш. Първата команда, която ще разгледаме е \"tree\" (\"дърво\"). Тази команда показва всички папки и файлове като дърво. Понякога е полезна, особено ако работиш в среда без графичен интерфейс. Действа и много добре за показване на \"умения\" и хвалене.",
    "p6a1": "Картинка на дърво",
    "p6a2": "Структурата на файловете",
    "p6a3": "Структурата на папките",
    "p6a4": "Структурата на папките и файловете",
    "p6tq": "tree командата показва:",
    "p7p": "Освен това в случая \"C:/Users/Потребител>\" е нашата работна папка. Можем да я сменим. Това става чрез командата \"cd\" от \"change directory\" (\"промени директория\" (директория е синоним на папка)). Конзолата действа с относителни адреси. Тоест, ако напишем:",
    "p8con": "<<prefix>>C:/Users/Потребител> cd ./",
    "p9p": "Ще останем в същата папка. Ако напишем:",
    "text": "Където ще научиш как са управлявали компютрите преди графиката",
    "title": "Урок 5"
  },
  "l6": {
    "p10a1": "Различни действия",
    "p10a2": "Различен резултат",
    "p10a3": "Еднакъв резултат",
    "p10a4": "Различни алгоритми",
    "p10tq": "При две извършвания един алгоритъм се очаква да има:",
    "p11p": "Подобно е в програмирането. Всяка програма действа с множество алгоритми. Ти ще създадеш много. Някои ще трябва да прочетеш, защото са били измислени от хора по-умни от мен и теб. Да разгледаме един:",
    "p12p": "Представи си, че пред теб има 10 числа в редица. Всъщност, няма нужда да си ги представяш. Ето ги:",
    "p13p": "1, 5, 78, 6, 9, 127, 6758, 89, 9680, 9679",
    "p14p": "Намери най-голямото число.",
    "p15p": "\"9680!\", разбира се. Но как го намери? \"Видях го\" не е валиден отговор. Компютрите не виждат. Нека да създадем алгоритъм за намиране на най-голямото число:",
    "p16p": "Ти най-вероятно първо си взел/а числото, което ти е изглеждало най-голямо. На компютъра обаче не му \"изглежда\", така че за целта на този алгоритъм ще изберем първото число. \"1\" в този случай. След това ще погледнем следващото число. То е 5, което е по-голямо от 1. Значи нашето число вече е 5. След това имаме 78. То е по-голямо от 5, значи нашето число вече е 78. След това има 6. 6 е по-малко от 78. Значи го пропускаме и 78 остава нашето число. Това продължава до края на редицата числа. Накрая, гарантирано нашето число ще бъде най-голямото - 9680.",
    "p17a1": "Слагаме минус пред крайния резултат",
    "p17a2": "Вместо за по-голямо, проверяваме за по-малко",
    "p17a3": "Обръщаме редицата преди това",
    "p17a4": "Изваждаме сбора на числата от редицата от резултата",
    "p17tq": "Как да модифицираме горния алгоритъм, за да намира най-малкото число от редицата?",
    "p18p": "Това е един от множеството алгоритми, които ще срещнеш, но със сигурност е един от най-простите и най-често използваните.",
    "p19t": "Алгоритъм не се учи наизуст. Същестуват прекалено много и не можеш да запомниш всички. Важно е да развиваш собственото си мислене, да вникнеш в логиката на задачата, така че и ти да можеш да пишеш свои алгоритми.",
    "p1p": "Аххх - алгоритъм! Една от по-криворазбраните думи като цяло. И сега ще си говорим точно за нея.",
    "p2p": "Да изясним първо какво е алгоритъм. Алгоритъм е последователност от действия за постигане на резултат.",
    "p3p": "Това е всичко. Алгоритъм е например сутрешната рутина:",
    "p4p": "Ставам. Измивам си зъбите. Закусвам. Резултатът е, че съм готов за деня.",
    "p5p": "За постигане на един и същ резултат може да има няколко различни алгоритъма:",
    "p6p": "Ставам. Измивам си зъбите. Къпя се. Закусвам. Пак съм готов.",
    "p7p": "Ставам. Гледам часовника. Закъснявам с 30 минути. Мия си зъбите докато се обличам. Отново съм готов.",
    "p8p": "Резултатът също е общ. Например, ако сортирам една купчина предмети по един начин и друга по същия начин, купчините не са еднакви, но резултатът от алгоритъма за сортиране е еднакъв - елементите са сортирани. По същия начин, алгоритъмът за тотото винаги има еднакъв резултат - винаги има 6 изтеглени числа, нищо че са различни всеки път. Всяко действие се раздробява до съставните си части, за да бъде част от алгоритъм. Ако някой те пита: \"Каква е сутришната ти рутина\", и ти отговориш \"Ами, просто се приготвям\", няма да помогнеш много, обаче ако отговориш с някои от горните примери, ще дадеш пълен отговор. След това може да те питат как си миеш зъбите. Подобен отговор за всяко действие би последвал. В известен смисъл, програмирането се свежда именно до раздробяване на проблеми до най-малките им съставни части.",
    "p9p": "Да се повтори алгоритъм и да се очаква различен резултат е съмнително, а ако това се случи има грешка в алгоритъма. Очаква се резултатът от алгоритъма за пране да е \"чисти дрехи\", не \"наводнена стая\".",
    "text": "Където ще научиш какво е алгоритъм",
    "title": "Урок 6"
  },
  "l7": {
    "p10p": "За да реши предните проблеми, на помощ идва Stack паметта (\"стак / стек\"). Тя не е голяма, но е подредена и бърза. Тя е и общото между пакетите обикновени бисквити и компютрите. Остави ме да обясня:",
    "p11p": "Стакът е много прост. Той е като кутия, при която е открита горната част:",
    "p12alt": "Правоъгълник с открита горна част",
    "p13p": "В тази кутия могат да се слагат единствено други кутии, които са една върху друга:",
    "p14alt": "Кутията от по-горе, този път с три други правоъгълника вътре, поставени един върху друг",
    "p15p": "Както забелязваш, към кутията може да се прибави само отгоре. И може да се извади само последното добавено нещо. Като пакетите с обикновени бисквити. Това е стакът. Но как решава проблемите с хийпа?",
    "p16p": "Всеки път когато програмата навлезе в нов блок код, към стака се добавя още една кутия. Можем да запазваме на кутийката на блока в стака. Ако обаче ни трябва хийпа заради големината му, изпращаме подобно на горното съобщение на процесора. Той заема паметта и ни отговаря с адрес. Ние можем да запазим този адрес в кутийката ни на стака. Ако имаме нужда, можем да използваме този адрес, за да се върнем на заетата памет, да я променим, или да кажем да бъде маркирана като свободна за заемане.",
    "p17p": "Има един проблем обаче. Когато нашия блок код свърши, кутийката ни в стака изчезва. С нея изчезва и запаметения адрес. Тоест, ние вече нямаме достъп до заетата памет от хийпа - тя ще продължи да съществува до затваряне на програмата. Това се нарича memory leak - теч на памет. Течовете на памет водят до огромни проблеми със сигурността и ресурсната тежест на програмите. В следващия урок ще разберем как различните езици за програмиране се справят с това.",
    "p18a1": "Разливане на вода върху RAM",
    "p18a2": "Разливане на вода върху ROM",
    "p18a3": "провал да се маркира като свободна памет от стака",
    "p18a4": "провал да се маркира като свободна памет от хийпа",
    "p18tq": "Течовете на памет се получават от:",
    "p19p": "Може би си забелязал/а, че след този урок има тест. Късмет!",
    "p1p": "Това е един от по-сложните уроци, тоест внимавай. Ще се занимаем с паметта.",
    "p2p": "Първо да ти обясня, че компютърът има 2 типа памет - RAM и ROM. ROM паметта е в хард дискове, SSD-та и т.н. Това е постоянна памет - тя продължава да съществува дори и да няма ток към нея. На нея се съхраняват файловете и някои други неща. Представи си, че всеки път, когато рестартираше компютъра си, трябваше да преинсталираш операционната си система… и всичките ти файлове се губеха… и трябваше да преинсталираш всяко приложение... Хаос, нали? Това е проблема, който решава ROM паметта. Тя обикновено е и голяма - трябва да има място за всичко. Обикновено се проваля в бързината - ROM паметта не е позната като бърза.",
    "p3p": "Вторият тип памет е RAM паметта. Тя обикновено е много по-бърза и много по-малка от ROM. Тя обаче зависи от източника на енергия - в момента, в който той вече отсъства, тя се изпразва напълно. В нея се зареждат приложенията - например, когато отвориш калкулатора и напишеш число в него, то се запазва в RAM. Така го виждаш докато пишеш. Текстът, който пишеш в Word се запазва в ROM, но го виждаш, защото е бил зареден в RAM. RAM е паметта, до която приложенията имат директен достъп. Затова и всичко се затваря, когато рестартираш компютъра си. Запазването в ROM е малко по-сложно.",
    "p4a1": "е енергийно зависима",
    "p4a2": "върви само на екологична енергия",
    "p4a3": "запазва в перманентна форма",
    "p4a4": "e вида на хард дисковете",
    "p4tq": "RAM е памет, която:",
    "p5p": "Да преминем на двете части, на които се разделя RAM паметта при всяка програма.",
    "p6h": "Heap",
    "p7p": "Heap (чете се \"хийп\", означава \"купчина\") е единия вид памет, до който има достъп всяка програма. Както показва името, той е купчина от информация - буквално. Представи си купчина играчки, нахвърляни една върху друга. Друго важно нещо за хийпа е, че той има случайна подредба. Освен това е доста голям. Тоест, ако процесора получи команда от типа \"запази ми 4 байта на хийпа\", той ще започне да минава през хийпа от началото му. В някакъв момент ще намери празно място. След това ще преброи битовете до края на празното място и ако има достатъчно, ще маркира паметта като заета - 4 байта, както гласи съобщението. Веднъж заета, паметта седи така до един от следните случаи - или бива маркирана като свободна на по-късен етап, или при край на изпълнението на програмата. Това е хубаво, но след като заемем памет на хийпа, как стигаме до нея? Все пак тя е случайно разхвърляна. И всеки, който е търсил играчка в купчината знае, колко е сложно това. Да не говорим, че целият процес на заемане на памет не е особено бърз - просто паметта е много.",
    "p8a1": "голям",
    "p8a2": "малък",
    "p8a3": "подреден",
    "p8a4": "много бърз",
    "p8tq": "Хийпът е:",
    "p9h": "Stack",
    "text": "Където ще научиш връзката между бисквитите и паметта",
    "title": "Урок 7"
  },
  "l8": {
    "p10p": "Стигаме и до езиците, които ще се използват тук - Java (\"джава\") и C# (\"си шарп\"). Те са два от най-ползваните езици в световен мащаб. Освен това са много подобни на повърхностното ниво. И двата езика са някъде между C и Python като ниво.",
    "p11p": "Уникалното при Java е, че тя е компилирана и интерпретирана. Всяка Java програма първо се компилира в нещо, наречено byte code (\"байт код\"). Този код се разпространява като програма. За да бъде стартиран, компютърът, на който е, трябва да има инсталирана Java. При стартиране JVM (Java virtual machine - Java виртуална машина) взима байт кода и започва да го интерпретира. Това позволява на Java бързина подобна на тази на компилираните езици и способността да върви на всеки компютър с наличен инсталиран JVM.",
    "p12p": "C# е подобен. Той първо се компилира до код наречен IL. Когато се стартира на друг компютър, .NET Common Language Runtime (\"точка нет общ езиков изпълнител\") го компилира втори път, този път до машинен код и го пуска. Това му позволява да е бърз като компилиран език, но и да върви на всеки компютър с .NET Common Language Runtime.",
    "p13p": "Езиците за програмиране обаче не са прости. И не можем просто да ги пишем в Notepad - би било твърде трудоемко. Затова съществуват IDE-та (\"Integrated development environment\" - интегрирана среда за разработка). Те са редактори на текст, които позволяват бърза смяна на отворени файлове, опитват да предскажат какъв код ще напишеш, опитват да поправят грешките ти, помагат да ги откриваш сам и обикновено имат бутон за пускане на програмата, за да не трябва да запомняш дългите команди на конзолата, които се искат, за да компилираш и пуснеш код. Те обаче са само това - те не могат да променят езика, не могат да причиняват грешки сами в кода ти и т. н.",
    "p14p": "От следващия урок започва програмирането. Избери си кой език ще използваш - C# или Java. Няма особено значение, защото винаги можеш да научиш и другия.",
    "p15p": "Избра ли?",
    "p16p": "Ако си избрал/а Java, най-добрите избори за IDE са Eclipse и IDEA (според мен), които аз използвам. За начинаещи, препоръчвам Eclipse, но ако искаш, можеш да започнеш и веднага от IDEA.",
    "p17p": "Ако си избрал/а C#, най-добрият избор е Visual Studio (според мен).",
    "p18p": "Надолу ще обясня процеса на инсталация на всичко нужно и започването на проект.",
    "p19ds1": "Eclipse",
    "p1p": "Какво е програмен език? Програмен език е език, с който се програмира, очевидно. Програмните езици са изкуствени и конструирани, създадени са от хора, съответно те си приличат много. Почти всеки език има концепциите на почти всеки друг език и в повечето случаи даже и думите са еднакви - като нашите говорими езици от латинското семейство, или от германското семейство, или от славянското семейство. Стига да знаеш един език от семейството, другите са много по-малка пречка. А един бонус на програмните езици е, че те имат по около 100 думи, а не по 1000 страници думи като нормалните езици. Това, което искам да ти кажа е, че програмният език няма особено значение. Важни са концепциите. И за остатъка от този \"курс\" ще научиш повечето от тях. След това ще си свободен да ползваш всеки програмен език.",
    "p2p": "Програмните езици водят началото си от 20 век. Първоначално, на процесорите е трябвало да се дават команди, написани чрез дупки на картончета - дупка означавала 0, а място - 1. След това, някой е измислил Assembly - първия \"истински\" програмен език. Той не е много над нулите и единиците обаче - просто командите се пишели с текст, не с числа, което е огромно подобрение. А и е специфичен за всяка архитектура процесори - представяш ли си да напишеш една програма 3 пъти за 3 различни архитектури!?",
    "p3p": "След това се случва чудо. Появява се \"C\" (\"си\") - първия модерен програмен език! Той има повечето от функциите, които и всеки друг модерен програмен език има. Но преди толкова много време - през 1972г! Това е революция - най-после кодът прилича повече на нещо, написано в днешно време. А и можеш да напишеш код веднъж и да създадеш от него програми за множество архитектури.",
    "p4p": "Обаче \"C\" не е само рози. Езикът оставя програмистът сам да контролира паметта си. Което е много хубаво, ако разбираш какво правиш и много лошо, ако не, защото създаваш код пълен с течове на памет и проблеми.",
    "p5p": "Днес много голяма част от света продължава да работи на C. И на неговия следващ език - C++. Даже и операционната система, която ползваш, най-вероятно е написана на тях.",
    "p6p": "Езиците, споменати до сега са от ниско ниво - те са близко до компютъра - дават на програмиста контрол над паметта и накрая стигат директно до компютърни команди. Това се случва, благодарение на компилатор. Компилаторът е програма, която \"превежда\" (компилира) изходен код до код, отговарящ на език от (обикновено) по-ниско ниво, който извършва същите действия. Например, C компилира до машинен код. Машинният код вече може да се разпространява и да върви на компютъра.",
    "p7p": "От създаването на C до днес много езици са били направени, станали са популярни, и даже са изчезнали - BASIC, Visual Basic, COBOL, Fortran (този продължава да се ползва в математиката). Много и продължават да съществуват - Java, C#, Python, Perl, Ruby, Javascript. А нови езици се появяват постоянно - Kotlin, Go, Rust, Typescript.",
    "p8p": "Езици като Java и C# са от високо ниво - те са по-прости, по-контролирани и не позволяват управление над паметта - обикновено всяко парче памет се запазва на хийпа с адрес в стака. От време на време, през хийпа минава програма на езика, наречена \"Garbage collector\" (събирач на боклук), която проверява дали парчетата памет имат запазен адрес някъде в стака. Ако нямат - биват изтрити. Автоматично. Директно на стака се запазват обикновено примитивните типове (int, short, long, float, double, char, boolean, които ще разгледаме в следващите уроци), когато са локални (не са част от или общи за клас - ще разбереш по-късно).",
    "p9p": "Има и езици като Python (\"пайтън\", питон). Той е най-добре описан чрез една шега: Да си направиш къща с Assembly е като да си отсечеш сам дървета и да си я построиш ръчно. Cъс C вече имаш дъски и само трябва да построиш къщата, а при Python ти доставят къщата готова. Python е интерпретиран език. Това значи, че за да пуснеш програма с него, трябва да инсталираш езика на компютъра си. Когато стартираш програмата, интерпретатора започва да чете файла в движение - това прави езика по-бавен, но му позволява да върви навсякъде - ако на устройството може да се инсталира Python, то всяка програма написана на него върви там.",
    "s19ds2": "IDEA",
    "s19ds3": "Visual Studio",
    "s19p": "Трябва да инсталираш Eclipse. Отиди на следния сайт: https://www.eclipse.org/downloads/",
    "s20p": "и натисни Download бутона. Ще бъдеш заведен на друга страница. Натисни бутона за теглене там. Операционната ти система автоматично ще бъде разпозната. След изтегляне на файла го отвори. Ще ти излезе списък с опции. Искаш \"Eclipse IDE for Java Developers\". Ще ти излезе меню, където можеш да редактираш папката за инсталация. Освен това Eclipse инсталира Java автоматично за теб, така че избери версия от същото меню. След това следвай инструкциите за инсталация. След инсталацията, стартирай програмата.",
    "s21p": "Когато програмата стартира, в горния ляв ъгъл ще видиш бутон File. Натисни го и избери опцията New. После избери Java Project. Ще ти излезе прозорец, където да кръстиш проекта си - избери име на латиница. Пробвай да няма празни пространства в името. Натисни Finish. В левия панел ще се появи проекта ти. Той ще има две неща под себе си - JRE System Library и src. Интересуваш се само от src. Натисни с десния бутон на мишката на src и избери New от появилото се меню. След това избери Package. Това е пакет и ще разбереш неговата функция по-късно. Дай му име, с малки букви, на латиница и натисни Finish. Ще се появи новосъздадения пакет. Избери го и го натисни с десния бутон на мишката. Отново ще се появи менюто. Отново избери New. Този път на New избери Class. Избери име, което да започва с голяма буква и да е на латиница. Без празни пространства. Отдолу ще видиш опция за тикче \"public static void main(String[] args)\". Натисни я, така че да се появи тикчето. Натисни Finish. Току-що създаде първия си Java файл! Пред теб трябва да стои нещо такова:",
    "s22cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n}",
    "s23p": "Редактирай го, така че да стане:",
    "s24cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Здравей свят!\");\n\t}\n\n}",
    "s25p": "Горе намери зелена, кръгла иконка с триъгълник вътре. Натисни я. Натисни OK, ако те пита нещо. Ще се отвори конзола долу. На нея трябва да пише \"Здравей свят!\". Пусна първата си програма. Браво!",
    "s26p": "Трябва да инсталираш IDEA. Отиди на следния сайт - https://www.jetbrains.com/idea/download/",
    "s27p": "и натисни Download бутона под Community текста. Ще започне изтеглянето на файла. След това го стартирай и изпълни инструкциите за инсталация.",
    "s28p": "Стартирай програмата. Възможно е да те пита няколко въпроса за режима (светъл или тъмен).",
    "s29p": "Ще ти излезе меню. Избери New Project. В ляво се увери, че е избранa Java. От менюто в дясно избери Project SDK. Ще ти излезе списък. Натисни Download JDK. Натисни Download на новото меню. Това ще изтегли Java вместо теб, автоматично. Натисни Next долу вдясно. Натискай Next докато се появи менюто с Project name. Напиши име на проекта си, на латиница, без празни места. Натисни Finish. Проектът ще се отвори. Вляво ще видиш няколко неща. Интересуваш се от папката src. Натисни с десния бутон на мишката на src и избери New от появилото се меню. След това избери Package. Това е пакет и ще разбереш неговата функция по-късно. Дай му име, с малки букви, на латиница и натисни Enter. Ще се появи новосъздадения пакет. Избери го и го натисни с десния бутон на мишката. Отново ще се появи менюто. Отново избери New. Този път на New избери Java Class. Избери име, което да започва с голяма буква и да е на латиница. Без празни пространства. Натисни Enter, за да го завършиш. Току-що създаде първия си Java файл! Пред теб трябва да стои нещо такова:",
    "s30cj": "package hello;\n\npublic class Hello {\n}",
    "s31p": "Редактирай го, така че да стане:",
    "s32cj": "package hello;\n\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Здравей свят!\");\n    }\n}",
    "s33p": "Натисни с десния бутон на мишката върху текста. Ще се отвори меню. От него избери Run.",
    "s34p": "Ще се отвори конзола долу. На нея трябва да пише \"Здравей свят!\". Пусна първата си програма. Браво!",
    "s35t": "Интересно: Забележи текста над \"Здравей свят!\". Това е командата нужна за пускане на кода. Започва с пътя към Java. След това има други настройки и пътя към файла, който си пуснал. IDE ти спестява да пишеш нещо такова, за да стартираш файл.",
    "s36w": "Visual Studio е наличен само за Windows към момента на писане",
    "s37p": "Трябва да инсталираш Visual Studio. Отиди на следния сайт: https://visualstudio.microsoft.com/downloads/",
    "s38p": "и натисни Free Download бутона под Community текста. Ще се изтегли файла. Пусни го. Натискай Continue, докато се появи меню със заглавие Workloads. Избери .Net desktop development. По-късно можеш да инсталираш и други пакети. Натисни Install. Чакай да приключи инсталацията. Възможно е да се поиска рестартиране на компютъра. Извърши го. След това стартирай Visual Studio. Ще ти бъдат зададени въпроси за режима (светъл или тъмен). Избери както искаш. След това ще се появи меню. Вдясно избери опцията Create a new project. Менюто ще се промени на такова със заглавие Create a new project. При менюто на езиците (първи правоъгълник горе вдясно) избери C#. Долу избери Console App (.NET Core). Натисни Next. Избери име на проекта при Project Name. То да е на латиница и да започва с главна буква, без празни пространства. Натисни Create. Ще се отвори нов проект. В него ще е отворен файл Program.cs. Намери файла вляво. Натисни с десен бутон на мишката. Ще се появи меню. Натисни Delete и след това OK. Натисни името на проекта вляво и го натисни с десния бутон на мишката. Натисни Add от менюто и после натисни New item. Ще се появи меню. Избери Class. Долу напиши име, на латиница, започващо с главна буква, без празни пространства. Трябва да завършва на .cs, тоест не редактирай разширението. Натисни Add. Ще се появи нещо подобно:",
    "s39cc": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n    }\n}",
    "s40p": "Редактирай го, така че да стане:",
    "s41cc": "using System;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Здравей свят!\");\n        }\n    }\n}",
    "s42p": "Горе трябва да има правоъгълник с името на проекта и зелен триъгълник. Натисни го и избери името на проекта. Ще се отвори конзолата в черен прозорец. На нея трябва да пише \"Здравей свят!\". Пусна първата си програма. Браво!",
    "text": "Където ще научиш какво ще учиш",
    "title": "Урок 8"
  },
  "l9": {
    "p15p": "Резултат в конзолата:",
    "p16con": "<<output>>Как си?\n<<output>>Добре. Ти как си от 1 до 10?\n<<output>>5И по-добри дни съм имал",
    "p17p": "Забелязваш сливането на последния ред. Можеш ли да го обясниш?",
    "p18p": "Това е принтирането на конзолата. Сега трябва да говорим за променливите. Променливите имат свойството да се променят. Във всеки сериозен програмен език има променливи. Те са начина, по който се използва паметта. Винаги следват следната формула:",
    "p19pc": "num = 5; //num идва от number / число",
    "p1p": "В миналия урок принтирахме към конзолата. Всяка програма има main метод (\"главен\"). Ще разбереш по-късно какво е метод. Програмата винаги стартира от main, тоест, ние ще пишем кода си вътре.",
    "p20p": "След това, напред в кода, num може да се използва. Например:",
    "p21pc": "print(num); // В този език, приеми, че принтирането става с print  - това би принтирало 5\n//самата практика наричам общ код - код, който не е на никой език, а вместо това обединява няколко за по-лесно писане и обяснение",
    "p22p": "Тук num е името, а 5 е стойността",
    "p23p": "Променливите се кръщават по различен начин спрямо програмния език, но почти винаги следват определени правила:",
    "p24p": "Имената винаги са една дума",
    "p25p": "Имената не могат да съдържат друго освен букви, цифри и \"_\" или \"-\"",
    "p26p": "Думи, които езикът използва (например class), не могат да бъдат имена на променливи",
    "p27p": "Името на променлива не може да започва с число - обяснението за това е просто - ако може да започва с цифра, името може да е число. Това може да породи ситуация от рода на:",
    "p28pc": "6 = 5",
    "p29p": "И после, ако имаме print(6);, езикът ще се чуди дали да принтира 6 или 5. Тоест, това просто не се позволява.",
    "p2ds1": "Java",
    "p30p": "Освен това има и някои стандарти за кръщаване.",
    "p31p": "В Java и C# повечето променливи се кръщават с camelCase (камилов тип). При него първата буква от първата дума е малка, а първата буква на всяка следваща дума е главна и всички думи са слети. Например:",
    "p32pc": "имеНаПроменливаВКамиловТип = 5;",
    "p33p": "За някои други неща (като класовете) се ползва PascalCase (Паскалов тип). При него първата буква от всяка дума е главна и всички думи са слети. Например:",
    "p34pc": "ИмеНаПроменливаВПаскаловТип = 5;",
    "p35p": "Има и snake_case (змийски тип). При него всички букви са малки и всяка дума е отделена от долна черта - \"_\". Например:",
    "p36pc": "име_на_променлива_в_змийски_тип = 5;",
    "p37e": "Тук пиша имената на кирилица, за да са по-лесни за четене, но когато програмираш, винаги използвай само латиница!",
    "p38p": "Освен това винаги давай значими имена на променливите. След компилацията така или иначе ще са по няколко случайни букви, така че в оригинал ги пиши обяснителни:",
    "p39p": "Най-вероятно не е добра идея да кръщаваш така:",
    "p40pc": "r = 5; // това се предполага, че е радиус на кръг",
    "p41p": "Ще е по-четимо така:",
    "p42pc": "radiusCircle = 5;",
    "p43p": "Така всеки човек, дори ти самият, веднага ще знае, че това е радиус на кръг, а не на пирамидите в Гиза",
    "p44p": "Трябва да ти кажа и за типовете на променливите. Това, което гледа досега е \"общ\" език. В него променливите сами знаят какво съдържат. Но в Java и C# това не е така. Всяка променлива има тип. Типът определя какъв вид информация ще съдържа променливата. Това осигурява, че няма да опитаме да съхраним в една променлива и текст, и по-късно число. Първия тип, който ще учим е Integer (целочислен тип) - или съкратено, както е и в езиците - int. Целочисленият тип съдържа цели числа - 56 е цяло число, тоест може да бъде такава променлива, но 56.78 не е.",
    "p45p": "int е с големина 4 байта в почти всеки език. 4 байта е 32 бита, тоест най-големия възможен int би трябвало да е 4,294,967,295. Първия от тези битове обаче се запазва за знака - \"+\" или \"-\". Тоест int може да съдържа числа от -2,147,483,648 до 2,147,483,647.",
    "p46p": "Освен int има и два други целочислени типа - short и long - от \"къс\" и \"дълъг\" на английски. short има два байта - 16 бита. Първия е знак, тоест short може да съдържа числата между -32,768 и 32,767. long на своя страна е дълъг - има цели 8 байта - 64 бита. Дори и с първия си бит използван за знак, той може да съдържа числата между -9,223,372,036,854,775,808 и 9,223,372,036,854,775,807.",
    "p47p": "Прието е да се използва int, освен ако не си сигурен, че имаш малки числа - тогава се ползва short. Ако пък имаш неадекватно големи числа се използва long.",
    "p48p": "В някои езици има и така наречените \"беззнакови\" типове (\"unsigned\"). Те обикновено се записват като uint, ushort, ulong. При тях първия бит не се ползва за знак, тоест uint може да съдържа числата от 0 до 4,294,967,295. Тях няма да ги обсъждаме повече, но е хубаво да знаеш, че ги има.",
    "p49a1": "1 байт",
    "p49a2": "4 бита",
    "p49a3": "4 байта",
    "p49a4": "8 байта",
    "p49tq": "int е голям:",
    "p50p": "Сега да преминем към кода:",
    "p51pc": "int num = 5; // Така се създава променлива с целочислен тип. Типът е преди името на променливата\nint num = 5.56 // Това би ни дало грешка, защото 5.56 не е целочислено число.\n// Ако сме създали int num = 5;, по-късно можем да го променяме. Като го променяме не записваме типа.",
    "p52ds1": "Java",
    "p55p": "Резултат в конзолата:",
    "p56con": "<<output>>5\n<<output>>6\n<<output>>5",
    "p57p": "Ако запишем типа докато променяме стойността, програмният език ще реши, че създаваме нова променлива. След това ще види, че вече има променлива с такова име и ще ни даде грешка.",
    "p58e": "Всяка променлива в един блок код трябва да има уникално име спрямо всяка променлива над нея.",
    "p59p": "Например:",
    "p5p": "\"//\" означава коментар. Когато го напишем на ред в програмата, остатъка от този ред вече не е код; той е коментар, който програмата не чете. През компилацията той се изтрива. Идеята е да можеш да обясниш какво прави дадено парче код до самия код. Запомни, с коментар не описвай какво си направил/а - това е очевидно, независимо дали четеш файл или махаш последния символ на файл. В коментар описвай защо си направил нещото - четеш файл, за да заредиш настройки, или махаш последния символ, за да не причиниш грешка. Това са неочевидни неща. При много усложнена логика, която не може да бъде разделена във функции и класове, можеш да използваш коментар, за да опишеш какво се случва.",
    "p60pc": "int num = 5; // Създаваме / инициализираме променливата\nint num = 6; // Грешката е тук - ще получим грешка, че вече има такава променлива - програмата ще спре, или \"крашне\".",
    "p61p": "По същия начин се създават и променливи от други типове:",
    "p62pc": "short shortNum = 1;\nlong  longNum = 900000000000; //Обикновено не се позволяват и разделители на групи в число; 9,000,000 би причинило грешка.",
    "p63p": "Освен това можем да създаваме няколко променливи с еднакъв тип на един ред по следния начин:",
    "p64pc": "int x = 5, y = 6;",
    "p65p": "Даденият код създава две променливи x и y, които могат да съхранят цели числа, като x има стойност 5, а y има стойност 6.",
    "p6pc": "/* Това пък е коментар на повече от 1 ред. Той не приключва до поява на */",
    "p7w": "В края на всеки ред код се записва точка и запетая - \";\"",
    "p8p": "Освен това си забелязал/а {} - тези скоби означават нов блок код. Забележи, че всеки блок код отива по-навътре в полето - или с един tab, или с три празни пространства. В Java, когато започва нов блок, пишем отварящата скоба { на предния ред. При C# е на следващия. Забележи, че и на двете места има main (string[] args) / Main(string[] args). Важно е да се отбележи, че в Java main е с малка буква, а String - с голяма, а в C# е обратното. Това нещо \"args\" съдържа аргументите дадени на програмата от конзолата. Помниш ли? Онези неща, които се записваха \"-аргумент стойност\". Останалата част от кода също е нужна за функциониране на програмата. Да видим как се принтира на конзолата в двата езика:",
    "p9ds1": "Java",
    "s10p": "Ето го нагледно:",
    "s11cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Как си?\");\n\t\tSystem.out.print(\"Добре. \");\n\t\tSystem.out.println(\"А ти как си от 1 до 10?\");\n\t\tSystem.out.print(5);\n\t\tSystem.out.print(\"И по-добри дни съм имал\");\n\n\t}\n\n}",
    "s12cc": "Console.WriteLine() // Това принтира и след това оставя един ред - идва от write line - напиши ред\nConsole.Write() // Това принтира, но не оставя един ред. Console.WriteLine() използва това, \n//само че добавя един \"\\n\" символ накрая, за да покаже нов ред. Спомняш ли си, че това беше символа за нов ред?",
    "s13p": "Ето ги нагледно:",
    "s14cc": "using System;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n        static void Main(string[] args)\n        {\n\t\tConsole.WriteLine(\"Как си?\");\n\t\tConsole.Write(\"Добре. \");\n\t\tConsole.WriteLine(\"А ти как си от 1 до 10?\");\n\t\tConsole.Write(5);\n\t\tConsole.Write(\"И по-добри дни съм имал\");\n\n        }\n    }\n}",
    "s2ds2": "C#",
    "s3cj": "package hello;\n\npublic class Hello {\n\n\tpublic static void main(String[] args) {\n\t\t// Пишем кода си тук\n\t}\n\n}",
    "s4cc": "using System;\n\nnamespace Tutorial\n{\n    class Hello\n    {\n        static void Main(string[] args)\n        {\n            // Пишем кода си тук\n        }\n    }\n}",
    "s52ds2": "C#",
    "s53cj": "int num = 5; // Създаваме / инициализираме променливата\nint secondNum = num; // Променливите може да са равни и на други променливи и взимат моментната им стойност\nSystem.out.println(num);\nnum = 6; // Променяме стойността на променливата. Не се записва типът.\nSystem.out.println(num);\nSystem.out.println(secondNum);",
    "s54cc": "int num = 5; // Създаваме / инициализираме променливата\nint secondNum = num; // Променливите може да са равни и на други променливи и взимат моментната им стойност\nConsole.WriteLine(num);\nnum = 6; // Променяме стойността на променливата. Не се записва типът.\nConsole.WriteLine(num);\nConsole.WriteLine(secondNum);",
    "s9cj": "System.out.println() // Това принтира и след това оставя един ред - идва от print line - принтирай ред\nSystem.out.print() // Това принтира, но не оставя един ред. System.out.println() използва това, \n//само че добавя един \"\\n\" символ , накрая, за да покаже нов ред. Спомняш ли си, че това беше символа за нов ред?",
    "s9ds2": "C#",
    "text": "Където ще видиш код за първи път",
    "title": "Урок 9"
  },
  "t1": {
    "p10a1": ".docx файлове",
    "p10a2": "HTML",
    "p10a3": "YAML",
    "p10tqc": "XML НЕ се използва за:",
    "p11a1": "ключ-стойност",
    "p11a2": "информация - размер",
    "p11a3": "стойност - обяснение",
    "p11a4": "файл-стойност",
    "p11tqc": "JSON следва модела:",
    "p12a1": "променя директорията",
    "p12a2": "създава файл",
    "p12a3": "изтрива директорията",
    "p12a4": "изтрива файл",
    "p12tqc": "Командата \"cd\":",
    "p13a1": "Се очаква да имат повече от един резултат",
    "p13a2": "Са последователност от действия",
    "p13a3": "При всяко изпълнение действията се променят",
    "p13a4": "При всяко изпълнение не действат",
    "p13tqc": "За алгоритмите е вярно, че:",
    "p14a1": "Да",
    "p14a2": "Не",
    "p14tqc": "ROM паметта зависи от енергия.",
    "p15a1": "Да",
    "p15a2": "Не",
    "p15tqc": "RAM паметта зависи от енергия.",
    "p16a1": "Да",
    "p16a2": "Не",
    "p16tqc": "Приложенията зареждат на RAM паметта.",
    "p17a1": "хаотичен",
    "p17a2": "подреден",
    "p17tqc": "Хийпът е:",
    "p18a1": "Да",
    "p18a2": "Не",
    "p18tqc": "Можем да извадим елемент от стака, дори ако върху него има друг елемент.",
    "p19a1": "memory leak",
    "p19a2": "теч на памет",
    "p19fqc": "Какво се случва, когато загубим адреса на парче памет в хийпа, без да сме го маркирали като свободно?",
    "p1a": "245",
    "p1fqc": "Превърни двоичното 1111 0101 в десетично число.",
    "p20fqc": "Опитай да си обобщиш какво научи в предния раздел в няколко изречения.",
    "p2a": "1000 1000",
    "p2fqc": "Превърни десетичното 136 в двоично число.",
    "p3a": "91",
    "p3fqc": "Пресметни 1011 1010 - 0010 0100, като знаеш че и двете числа са двоични. Запиши резултата като число в база 16.",
    "p4a": "22",
    "p4fqc": "Пресметни 1011 умножено по 10, като знаеш че и двете числа са двоични. Резултата запиши като десетично число.",
    "p5a1": "Координати",
    "p5a2": "Цветове",
    "p5a3": "Мерни единици",
    "p5a4": "Аритметични действия",
    "p5tqc": "Къде най-често се използват така наречените \"хексове\"?",
    "p6a1": "Да",
    "p6a2": "Не",
    "p6tqc": "ASCII поддържа ли кирилица?",
    "p7a1": "Съхранява най-често използваните с 4 бита",
    "p7a2": "Съхранява най-често използваните с 8 бита",
    "p7a3": "Съхранява рядко използваните с 2 байта",
    "p7a4": "Съхранява най-често използваните с 8 байта",
    "p7tqc": "Каква оптимизация използва UTF-8, за да съхранява ефективно всички символи?",
    "p8a1": "Предишна папка",
    "p8a2": "Сегашна папка",
    "p8a3": "Сегашен файл",
    "p8a4": "Работна папка",
    "p8tqc": "Относителният път \"../\" означава:",
    "p9a1": "помага за организацията на файловете",
    "p9a2": "е част от името на файл",
    "p9a3": "показва за коя програма е предназначен файла",
    "p9a4": "лимитира с каква програма може да бъде отворен файла",
    "p9tqc": "Разширението на файла НЕ:",
    "text": "Където ще провериш уменията си с компютри",
    "title": "Тест 1"
  },
  "t2": {
    "p10a1": "това, че може да съдържа два пъти по-големи числа от long",
    "p10a2": "има два пъти по-голяма големина от float",
    "p10a3": "има два пъти по-малка големина от float",
    "p10a4": "нито едно от посочените",
    "p10tqc": "Името на \"double\" (двойно) идва от:",
    "p11a1": "f",
    "p11a2": "float",
    "p11a3": "a",
    "p11a4": "l",
    "p11tqc": "Какво трябва да се постави след число, за да се индикира, че то е от тип float:",
    "p12pc": "int num = 10;\nint num1 = 12;\nint num2 = 13;\nint num3 = num++ - ++num1 + num2--;",
    "p13a1": "9",
    "p13a2": "10",
    "p13a3": "11",
    "p13a4": "12",
    "p13tqc": "След изпълнение на кода по-горе, num3 ще е равно на:",
    "p14a1": "00010100",
    "p14a2": "00101000",
    "p14a3": "01010010",
    "p14a4": "00101001",
    "p14tqc": "Ако x е двоично число, равно на 10100101, то тогава x >> 3 ще е равно на:",
    "p15a1": "Вярно",
    "p15a2": "Невярно",
    "p15tqc": "Можеш да събираш променливи от тип char с променливи от тип int.",
    "p16a1": "о",
    "p16a2": "в",
    "p16a3": "е",
    "p16a4": "з",
    "p16tqc": "Символът на индекс 5 в низа \"низове\" е:",
    "p17a1": "Вярно",
    "p17a2": "Невярно",
    "p17tqc": "Низовете могат да се конкатенират с цели числа.",
    "p18a1": "съдържат код, който обикновено има обща цел",
    "p18a2": "съдържат код, който обикновено няма обща цел",
    "p18a3": "са стандартни",
    "p18a4": "винаги идват с програмния език и не могат да се добавят",
    "p18tqc": "Библиотеките в програмирането:",
    "p19a1": "-10",
    "p19a2": "-16",
    "p19a3": "10",
    "p19a4": "5",
    "p19tqc": "В Java и C# уравнението (6*5-4*20) / 5 е равно на:",
    "p1a": "са естествени",
    "p1a2": "са създадени от хората",
    "p1tqc": "Програмните езици:",
    "p20fqc": "Опитай да си обобщиш какво научи в предния раздел в няколко изречения.",
    "p2a": "Да",
    "p2a2": "Не",
    "p2tqc": "Един от първите програмни езици е Python.",
    "p3a1": "грешки в кода",
    "p3a2": "бъгове",
    "p3a3": "крашове",
    "p3a4": "течове на паметта",
    "p3tqc": "Garbage collector осигурява липсата на:",
    "p4a1": "Да",
    "p4a2": "Не",
    "p4tqc": "Интерпретацията се случва всеки път когато се изпълнява файл в интерпретиран език:",
    "p5a1": "превежда изходен код до код, отговарящ на език от (обикновено) по-ниско ниво, който извършва същите действия",
    "p5a2": "поправя грешки",
    "p5a3": "се случва, когато се отвори файл с bytecode",
    "p5a4": "нито едно от посочените",
    "p5tqc": "Компилацията:",
    "p6a1": "4 байта",
    "p6a2": "2 байта",
    "p6a3": "1 байта",
    "p6a4": "8 байта",
    "p6tqc": "int обикновено има големина от:",
    "p7a1": "Не се",
    "p7a2": "Като един от битовете",
    "p7a3": "Като един от байтовете",
    "p7a4": "Нито едно от посочените",
    "p7tqc": "Как се запазва знака за положителност или отрицателност при променливи от тип short?",
    "p8a1": "типът има големина от много битове",
    "p8a2": "името е дълго",
    "p8a3": "името е иронично",
    "p8a4": "нито едно от посочените",
    "p8tqc": "Името \"long\" (дълъг) идва от факта, че:",
    "p9a1": "не се губи бит за запазване на знака",
    "p9a2": "не се губи бит за посока на числото",
    "p9a3": "няма беззнакови типове",
    "p9a4": "беззнаковите типове не се различават по големина от нормалните",
    "p9tqc": "Беззнаковите (unsigned) типове могат да съдържат по-големи числа, защото:",
    "text": "Където ще провериш способността си да запазваш информация",
    "title": "Тест 2"
  },
  "t3": {
    "p10a1": "324",
    "p10a2": "387",
    "p10a3": "156",
    "p10a4": "5",
    "p10tqc": "След изпълнение на по-горния код, резултатът в конзолата ще бъде:",
    "p11h": "Задачи",
    "p12p": "Следващите 2 въпроса са задачи, които трябва да направиш сам.",
    "p13rq": "Създай програма, с която потребител да се регистрира за сайт. Когато се стартира програмата, в конзолата да бъде попитан за името си, възрастта си и четно число. Когато се въведе тази информация, програмата проверява три неща - дали името е с дължина над 0 символа, дали възрастта е над 0 години и дали числото, което е въведено е четно. Ако и трите условия са изпълнени, изведи на конзолата \"Добре дошли, <името, което е въвел потребителят>.\". Иначе изведи \"Грешна информация!\".",
    "p14rq": "Опитай се да направиш предната задача, но този път приеми две различни имена (първо и фамилно), пол вместо възраст, като полът се въвежда чрез String и случайно трицифрено число (трябва да провериш дали числото е трицифрено).",
    "p15fqc": "Опитай да си обобщиш какво научи в предния раздел в няколко изречения.",
    "p1a1": "1 възможна стойност",
    "p1a2": "2 възможни стойности",
    "p1a3": "3 възможни стойности",
    "p1a4": "4 възможни стойности",
    "p1tqc": "Типът boolean има:",
    "p2a1": "true",
    "p2a2": "false",
    "p2tqc": "Твърдението 5 != 6 е:",
    "p3a1": "true",
    "p3a2": "false",
    "p3tqc": "Твърдението 7 <= 7 е:",
    "p4a1": "true",
    "p4a2": "false",
    "p4tqc": "Твърдението \"!(56 == 7 || 8 < 9) && 7 > 6\" е:",
    "p5pc": "int result = (5 < 6)? 7: 8;",
    "p6a1": "7",
    "p6a2": "8",
    "p6a3": "5",
    "p6a4": "6",
    "p6tqc": "След изпълнение на по-горния код, променливата result ще е равна на:",
    "p7pc": "int num = 7;\nfloat num1 = 7.6f;\nstring result = \"\";\nif (num == num1) {\n\tresult = \"Равни\";\n}\nelse if (num < num1) {\n\tresult = \"Първото е по-малко\";\n}\nelse {\n\tresult = \"Второто е по-малко\";\n}",
    "p8a1": "Равни",
    "p8a2": "Първото е по-малко",
    "p8a3": "Второто е по-малко",
    "p8a4": "Нито едно от посочените",
    "p8tqc": "След изпълнение на по-горния код, променливата result ще е равна на:",
    "p9pc": "int num = 5;\nswitch (num) {\ncase 1:\n\tprint(num * 65 - 1);\n\tbreak;\ncase 2:\n\tprint(num * 78 - 3);\n\tbreak;\ncase 15:\n\tprint(num * 32 - 4);\n\tbreak;\ndefault:\n\tprint(num);\n\tbreak;\n}",
    "text": "Където ще провериш способността си да контролираш програма",
    "title": "Тест 3"
  },
  "t4": {
    "p10con": "-10",
    "p11p": "Резултат:",
    "p12con": "-10\n-5\n0",
    "p13h": "Задача 2",
    "p14rq": "Създай програма, която избира случайно число x с максимална стойност 20. След това създай цикъл, който на всяка итерация избира ново случайно число y с максимална стойност 20 и спира, когато y е равно на x. Изведи през колко итерации е минал цикълът в конзолата.",
    "p15p": "Пример:",
    "p16p": "Резултат:",
    "p17con": "10 итерации",
    "p18h": "Задача 3",
    "p19rq": "Създай програма, която приема низ от конзолата. Ако низът е равен на ключовата дума \"влез\", изведи \"Влязохте в система\" и остави програмата да приключи. Ако низът не е равен на ключовата дума, изведи \"Грешна дума. Опитайте отново. Остават x опити\"  и позволи на потребителя отново да въведе дума. x е число, показващо колко опита остават. Максималният брой опити е 10. Когато потребителя превиши позволения брой опити, остави програмата да приключи. Използвай цикли.",
    "p1p": "Това е един по-уникален тест. Той се състои само и единствено от задачи, тоест няма въпроси с кръгче и никоя от задачите не подлежи на проверка. Твоята задача е да натиснеш бутона за край, когато си готов. Късмет!",
    "p22h": "Задача 4",
    "p23rq": "Използвай цикли, за да направиш програма, която пресмята факториела на число и го извежда на конзолата. Факториел на числото 3 е 3*2*1 = 6.",
    "p24p": "Пример:",
    "p25p": "Вход:",
    "p26con": "6",
    "p27p": "Изход:",
    "p28con": "720",
    "p29p": "(намерено чрез 6*5*4*3*2*1)",
    "p2h": "Задача 1",
    "p30h": "Задача 5",
    "p31rq": "Знаеш следните неща:",
    "p32p": "На малко латинско \"a\" съответства кода 97",
    "p33p": "На \"b\" съответства кода 98",
    "p34p": "На голямото латинско \"A\" съответства кода 65 (разликата между \"A\" и \"a\" е 32 позиции)",
    "p35p": "На \"B\" съответства кода 66",
    "p36p": "Всяка друга буква в  азбука е разпределена по същите правила",
    "p37p": "Буквите в английската азбука са 26",
    "p38p": "Изведи подредена цялата английска азбука в конзолата използвайки цикли, в следния формат:",
    "p39p": "Пример:",
    "p3rq": "Абсолютна стойност на число е разстоянието му до 0, тоест абсолютната стойност на 5 е 5, а абсолютната стойност на -7 е 7. Създай програма, която приема цяло число x от конзолата. Ако числото е кратно на 5, изведи него и всички други числа с абсолютна стойност по-малка от неговата, които са кратни на 5. Не забравяй, че има отрицателни числа. Използвай цикли.",
    "p40p": "Резултат:",
    "p41con": "A a\nB b\nC c\nD d\nE e\nF f\nG g\nH h\n<<prefix>>… // Други букви - няма да напиша цялата английска азбука в пример\nX x\nY y\nZ z",
    "p42p": "Късмет!",
    "p43p": "Преди да натиснеш край, реши ли задачите? Надявам се, че да. Без практика програмирането не се получава.",
    "p4p": "Пример:",
    "p5p": "Вход:",
    "p6con": "10",
    "p7p": "Резултат:",
    "p8con": "10\n5\n0",
    "p9p": "Вход:",
    "text": "Където ще провериш способността си да повтаряш",
    "title": "Тест 4"
  },
  "t5": {
    "p10rq": "Създай масив с големина 100 000 елемента. Напълни го със случайни числа между 0 и 100. След това го сортирай по всички методи, които съм ти показвал, без да забравяш тези от стандартната библиотека. Измери времето за изпълнение на програмата (или го прочети в IDE-то си) с всеки различен метод. Ако между начините няма разлика, просто добави една или повече нули към големината на масива. Потърси и изпробвай и други методи за сортиране.",
    "p11h": "Задача 3",
    "p12rq": "Създай програма, която приема от конзолата цяло число и след това масив с големина въведеното число. Ако перфектен квадрат е число, чийто квадратен корен е цяло число, изведи в конзолата сбора на всички числа в масива, които са перфектни квадрати. Не забравяй да използваш стандартната библиотека на езика!",
    "p13p": "Пример:",
    "p14p": "Вход:",
    "p15con": "3\n25\n5\n49",
    "p16p": "Изход:",
    "p17con": "74 // Тук перфектни квадрати са 25 и 49 - тоест 25+49 = 74",
    "p18h": "Задача 4",
    "p19rq": "Създай матрица с големина 5 колони и 5 реда. Приеми 25 цели числа от конзолата и запълни матрицата с тях. Намери сбора на всички числа в първия и последния ред на матрицата. Начертай си таблица, за да си представиш това. Умножи намерения сбор по сбора на всички числа от първата и последната колона. Изведи резултата.",
    "p1p": "Време е за задачи. Не забравяй да ползваш всички налични ресурси. Може задачите да ти се сторят трудни (най-вероятно защото това е така), но съм опитал да ги направя максимално интересни. Късмет!",
    "p20h": "Задача 5",
    "p21rq": "Приеми от конзолата 6 цели числа между 1 и 50. Запази ги в масив x. След това генерирай 6 случайни числа между 1 и 50 и ги запази в друг масив y. Изведи числата от y в конзолата. След това провери колко съвпадения има между числата в масива x и масива y. Ако съвпаденията са 0, 1 или 2 изведи \"Не печелиш\". Иначе изведи съответно:",
    "p22p": "3 правилни - \"Тройка\"",
    "p23p": "4 правилни - \"Четворка\"",
    "p24p": "5 правилни - \"Петица\"",
    "p25p": "6 правилни - \"Шестица\"",
    "p26p": "Пример:",
    "p27p": "Вход:",
    "p28con": "5\n42\n3\n24\n36\n20",
    "p29p": "Изход:",
    "p2h": "Задача 1",
    "p30con": "Изтеглени числа: 36, 43, 5, 1, 3, 15\nТройка",
    "p3rq": "Създай програма, която приема от конзолата цяло число, масив с целочислен тип и с големина въведеното число и символ - +, - или *. Изведи според символа сбора (+), разликата (-) или произведението (*) на всички числа във въведения масив.",
    "p4p": "Пример:",
    "p5p": "Вход:",
    "p6con": "5 // Големина на масива\n3\n4\n7\n8\n10\n+ // Символ",
    "p7p": "Изход:",
    "p8con": "22 // Сборът на числата",
    "p9h": "Задача 2",
    "text": "Където ще провериш способността си да работиш с много информация",
    "title": "Тест 5"
  },
  "t6": {
    "p10p": "каруца",
    "p11p": "(буквата \"у\" в куца е заменена от \"ару\", превръщайки низа в \"каруца\")",
    "p12h": "Задача 2",
    "p13rq": "Просто число е число, което се дели без остатък само на 1 и на себе си - напр. 5. Създай функция, която проверява дали едно число е просто, наречена isPrime (IsPrime в C#). Функцията приема като аргумент цяло число x и връща boolean - true, ако числото е просто, иначе false.",
    "p14h": "Задача 3",
    "p15rq": "Създай функция, която приема цяло число като аргумент и принтира в конзолата него и всички числа от него до 0, като спира на 1. Припомни си какво е абсолютна стойност. Използвай рекурсия.",
    "p16p": "Пример:",
    "p17p": "Аргументи:",
    "p18p": "5",
    "p19p": "Изход:",
    "p1p": "Знаеш какво те очаква. Късмет!",
    "p20con": "5\n4\n3\n2\n1",
    "p21h": "Задача 4",
    "p22rq": "Създай функция, която приема низ като аргумент и го връща като масив от символи. След това създай функция, която приема масив от символи като аргумент и връща сбора на цифрените стойности на всички символи в масива.",
    "p23p": "Пример:",
    "p24p": "Фукнция 1:",
    "p25p": "Аргументи:",
    "p26p": "да",
    "p27p": "Връща:",
    "p28p": "['д', 'а']",
    "p29p": "Функция 2:",
    "p2h": "Задача 1",
    "p30p": "Аргументи:",
    "p31p": "['a', 'b']",
    "p32p": "Връща:",
    "p33p": "195 (сбора на 'a' и 'b')",
    "p34h": "Задача 5",
    "p35rq": "Създай функция, която приема цяло число като аргумент и връща сбора на неговите цифри.",
    "p36p": "Пример:",
    "p37p": "Аргументи:",
    "p38p": "127",
    "p39p": "Връща:",
    "p3rq": "Създай функция, която приема за аргументи низ original, низ replacement и индекс x и връща нов низ replaced. replaced е низа original, но символа на индекс x е заменен с низа replacement. Ако индексът x не се намира в низа original (напр. x = 5, а original е с дължина 5 символа), върни null. Използвай поднизове.",
    "p40p": "10",
    "p41p": "(10 = 1+2+7)",
    "p4p": "Пример:",
    "p5p": "Аргументи:",
    "p6p": "original = \"куца\"",
    "p7p": "index = 1",
    "p8p": "replacement = \"ару\"",
    "p9p": "Връща:",
    "text": "Където ще провериш колко си организиран",
    "title": "Тест 6"
  },
  "t7": {
    "p10p": "Действия:",
    "p11con": "x = 10\nдобавяне 5, изваждане 3, умножение 4, деление 3, корен квадратен\nx = 4",
    "p12p": "Бонус - добави един статичен метод, който приема 3 числа double a, b, c и решава квадратно уравнение с тях. Съответно връща масив с резултатите - празен ако няма x, с 1 елемент ако има само 1 решение и с два елемента, ако има 2 решения.",
    "p13h": "Задача 4",
    "p14rq": "Създай клас House (къща), който има свойства като: брой етажи, брой прозорци, брой стаи, стил (модерен, ренесанс - бих препоръчал енумерация), квадратура и др. След това приложи override на .toString()/.ToString() метода, така че да връща низ във формата \"Къща с <брой етажи> етажа, <брой прозорци> прозорци, <брой стаи> стаи в <стил> стил, голяма <квадратура> кв.м. …<други свойства>\".",
    "p15p": "Създай метод getPrice()/GetPrice(), който изчислява цената на къщата и я връща. Формулата е следната:",
    "p16p": "Избрана цена на квадрат * квадратура",
    "p17p": "Бонус: Направи така, че когато има само 1 прозорец, етаж и т.н. в низа се изписва \"… 1 прозорец…\" вместо \"…1 прозорци…\"",
    "p18h": "Въпрос 5",
    "p19rq": "Създай клас Library (библиотека), който има класова променлива от тип масив от книги с големина приета в конструктора. Масивът се инициализира в конструктора. Има метод .add()/.Add(), който добавя книга в последното свободно място и връща true, ако има свободно място и false, ако няма, метод .empty()/.Empty(), който изпразва масива, метод .getSize()/.GetSize(), който връща колко книги има в масива, метод .getBooks()/.GetBooks(), който връща всички налични книги в нов масив с точна големина и метод .getBookByAuthor()/.GetBookByAuthor(), който приема име на автор и връща в масив всички книги, които имат същия автор.",
    "p1p": "Този тест символизира края на \"учебното\" ти обучение. В момента на писане на това, след последните няколко теми, в учебната програма от теб се очаква да правиш графични интерфейси. Аз няма да се впускам в това, защото вярвам, че трябва да ги разбереш сам. От този тест нататък, уроците ще представят неща извън учебната програмата и също някои допълнителни знания от мен. Следват 5 задачи, които да обхванат по-голямата част от материала до този момент. Късмет!",
    "p20t": "Последната задача има доста дълго условие и е разбираемо, ако ти отнеме повече време да се справиш с нея. Не забравяй, че вече имаш готов клас Book и не се предавай!",
    "p2h": "Задача 1",
    "p3rq": "Създай клас Cipher (шифър). Той има два статични метода - encipher (шифрирай) и decipher (дешифрирай). И двата метода приемат низ и ключ цяло число k. В методите имплементирай прост Цезаров шифър. След като класът е готов, създай main метод в друг клас, чрез който да тестваш. Приеми цяло число от конзолата. Ако е 0, приеми низ и число и изведи шифриран низ. Ако е 1, приеми низ и число и изведи дешифрирания низ. При което и да е друго цяло число, питай за въвеждане отново. Използвай Интернет.",
    "p4h": "Задача 2",
    "p5rq": "Създай клас \"WeatherForecast\" (прогноза за времето), който приема сезон (елемент на енумерация) и час в конструктора си (часът е цяло число - напр. 12 или 23, 25 не е валиден час) и генерира случайна прогноза според дадените аргументи. Например, лято, 14 - 36 градуса, 0% влажност, усеща се като 40 градуса. Всяко от тези свойства на прогнозата да има свои get-тър.",
    "p6t": "Вместо да правиш много проверки, опитай да използваш аритметика - например, започваш с начална стойност 0 градуса, \"лято\" добавя 35 градуса и 14 часа през деня добавя 7 градуса.",
    "p7h": "Задача 3",
    "p8rq": "Създай клас Calculator (калкулатор), който приема double x в конструктура си и има нестатични методи за добавяне, изваждане, умножение, деление и квадратен корен. Методите за добавяне, изваждане, умножение и деление приемат по един друг double, с който да се извършат действието. Метода за квадратен корен не приема аргументи. Всички методи извършват действието си, запазват новата стойност на x в класа и връщат новата стойност на x. Има get-тър и set-тър за x.",
    "p9p": "Пример:",
    "text": "Където ще провериш знанията си за софтуерната архитектура",
    "title": "Тест 7"
  },
  "t8": {
    "p10p": "Идеята ми е, че няма нужда да започваш веднага. Но когато видиш възможност, когато имаш идея, когато ти дойде музата - опитай. Няма да загубиш нищо, дори времето си, защото независимо какво направиш, ще си научил нещо и ще имаш повече опит отпреди това.",
    "p11p": "Късмет!",
    "p1p": "В този тест няма въпроси или задачи.",
    "p2p": "Добре де, има една задача. Иначе технически нямаше да е тест. Практикувай сам. Избери си нещо и създай проект. Интентум наближава своя край и скоро ще си пред избора да се откажеш или да продължиш. Вече би трябвало да имаш теоритичните знания, тоест единствения начин да продължиш е да пишеш истински код в истински проекти.",
    "p3p": "Има само два начина да се интересуваш от личен проект.",
    "p4p": "Единият е да имаш готова причина за проекта. Моят първи проект беше игра на карти на Java, защото я бях видял някъде и ми беше интересно да я пренаправя. Вече съм ти разказвал историята как се получи това. Въпреки това, от тази програма научих много неща и беше само първия ми опит, така че не се оплаквам.",
    "p5p": "Вторият начин е проекта да решава някакъв твой проблем.",
    "p6p": "През 2020 година преминахме на електронно обучение. Нямаше готова платформа, затова учениците организирахме сървър в Discord. Имаше проблеми, но особено досадно беше, че в разговорите винаги забравяхме да излезем от часа. Времето си минаваше и даже изпускахме междучасия. Това, разбира се, беше неприемливо. Учителите също се оплакваха от това, че учениците не присъстваха. Това, разбира се, не беше толкова неприемливо. Тогава на мен ми хрумна идеята да създам бот в Discord. Няколко дена по-късно имах бот на Python, който стартирах в началото на деня и автоматично влизаше в разговора и пускаше запис на звънец. Преди това нямах никакви знания нито за Discord, нито за Python и до голяма степен кодът беше спагети залепени с дъвки и тиксо. По-късно добавих част за следене на времето в часове (резултатите от която не дадох нито веднъж на учител, но това е друга тема), която имаше даже още по-лош код и беше проблемна за близо 2 месеца преди да я оправя. Цялото приключение беше като да водя битка с въздуха, но беше забавно. Вече са минали почти 2 години от това време. Ние вече не караме в Discord, имаме различни учители по всичко, библиотеката, която използвах за създаване на бота не се поддържа и може би съм няколко идеи по-добър програмист. Въпреки това, знанията от онезе месеци още си остават.",
    "p7p": "Първият ми сайт беше за училищен проект. Опитах да пренаправя сайта на училището ми. Получи се \"интересен\" резултат, който в крайна сметка не замени истинския сайт, но абсолютно си заслужаваше само за учебната част.",
    "p8p": "По-късно направих сайт за рисуване, защото не ми се стартираше програма на компютъра, а трябваше да си надраскам нещо бързо и без реклами. Знам, върха на мързела. Проекта трябваше да отнеме 2 седмици, в крайна сметка отне към 2 месеца, което вече може би трябваше да очаквам с над година опит.",
    "p9p": "И сега създавам Интентум, защото се оплаквах че няма добри, достъпни източници за програмиране на български. Доста е ироничен факта, че има английски превод, но както и да е.",
    "text": "Където ще се тестваш сам",
    "title": "Тест 8"
  }
}